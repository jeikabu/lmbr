/* automatically generated by rust-bindgen */

type F32 = f32;
type F64 = f64;
type U8 = u8;
type U16 = u16;
type U32 = u32;
type U64 = u64;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align> {
        storage: Storage,
        align: [Align; 0],
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub type f32 = crate::F32;
    pub type f64 = crate::F64;
    pub type u8 = crate::U8;
    pub type u16 = crate::U16;
    pub type u32 = crate::U32;
    pub type u64 = crate::U64;
    pub mod AZ {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type f32 = crate::F32;
        pub type f64 = crate::F64;
        pub type u8 = crate::U8;
        pub type u16 = crate::U16;
        pub type u32 = crate::U32;
        pub type u64 = crate::U64;
        pub mod Debug {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Trace {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?Instance@Trace@Debug@AZ@@SAAEAV123@XZ"]
                pub fn Trace_Instance() -> *mut root::AZ::Debug::Trace;
            }
            extern "C" {
                #[link_name = "\u{1}?GetDefaultSystemWindow@Trace@Debug@AZ@@SAPEBDXZ"]
                pub fn Trace_GetDefaultSystemWindow() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?IsDebuggerPresent@Trace@Debug@AZ@@SA_NXZ"]
                pub fn Trace_IsDebuggerPresent() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?HandleExceptions@Trace@Debug@AZ@@SAX_N@Z"]
                pub fn Trace_HandleExceptions(isEnabled: bool);
            }
            extern "C" {
                #[link_name = "\u{1}?Break@Trace@Debug@AZ@@SAXXZ"]
                pub fn Trace_Break();
            }
            extern "C" {
                #[link_name = "\u{1}?Terminate@Trace@Debug@AZ@@SAXH@Z"]
                pub fn Trace_Terminate(exitCode: ::std::os::raw::c_int);
            }
            extern "C" {
                #[link_name = "\u{1}?Assert@Trace@Debug@AZ@@SAXPEBDH00ZZ"]
                pub fn Trace_Assert(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Error@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Error(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Warning@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Warning(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Printf@Trace@Debug@AZ@@SAXPEBD0ZZ"]
                pub fn Trace_Printf(
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Output@Trace@Debug@AZ@@SAXPEBD0@Z"]
                pub fn Trace_Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?PrintCallstack@Trace@Debug@AZ@@SAXPEBDIPEAX@Z"]
                pub fn Trace_PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?GetNativeExceptionInfo@Trace@Debug@AZ@@SAPEAXXZ"]
                pub fn Trace_GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void;
            }
            impl Trace {
                #[inline]
                pub unsafe fn Instance() -> *mut root::AZ::Debug::Trace {
                    Trace_Instance()
                }
                #[inline]
                pub unsafe fn GetDefaultSystemWindow() -> *const ::std::os::raw::c_char {
                    Trace_GetDefaultSystemWindow()
                }
                #[inline]
                pub unsafe fn IsDebuggerPresent() -> bool {
                    Trace_IsDebuggerPresent()
                }
                #[inline]
                pub unsafe fn HandleExceptions(isEnabled: bool) {
                    Trace_HandleExceptions(isEnabled)
                }
                #[inline]
                pub unsafe fn Break() {
                    Trace_Break()
                }
                #[inline]
                pub unsafe fn Terminate(exitCode: ::std::os::raw::c_int) {
                    Trace_Terminate(exitCode)
                }
                #[inline]
                pub unsafe fn Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                ) {
                    Trace_Output(window, message)
                }
                #[inline]
                pub unsafe fn PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                ) {
                    Trace_PrintCallstack(window, suppressCount, nativeContext)
                }
                #[inline]
                pub unsafe fn GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void {
                    Trace_GetNativeExceptionInfo()
                }
            }
            pub type ProfileCategoryPrimitiveType = root::AZ::u64;
            pub const ProfileCategory_Any: root::AZ::Debug::ProfileCategory = 0;
            pub const ProfileCategory_Renderer: root::AZ::Debug::ProfileCategory = 1;
            pub const ProfileCategory_ThreeDEngine: root::AZ::Debug::ProfileCategory = 2;
            pub const ProfileCategory_Particle: root::AZ::Debug::ProfileCategory = 3;
            pub const ProfileCategory_AI: root::AZ::Debug::ProfileCategory = 4;
            pub const ProfileCategory_Animation: root::AZ::Debug::ProfileCategory = 5;
            pub const ProfileCategory_Movie: root::AZ::Debug::ProfileCategory = 6;
            pub const ProfileCategory_Entity: root::AZ::Debug::ProfileCategory = 7;
            pub const ProfileCategory_Font: root::AZ::Debug::ProfileCategory = 8;
            pub const ProfileCategory_Network: root::AZ::Debug::ProfileCategory = 9;
            pub const ProfileCategory_Physics: root::AZ::Debug::ProfileCategory = 10;
            pub const ProfileCategory_Script: root::AZ::Debug::ProfileCategory = 11;
            pub const ProfileCategory_ScriptCFunc: root::AZ::Debug::ProfileCategory = 12;
            pub const ProfileCategory_Audio: root::AZ::Debug::ProfileCategory = 13;
            pub const ProfileCategory_Editor: root::AZ::Debug::ProfileCategory = 14;
            pub const ProfileCategory_System: root::AZ::Debug::ProfileCategory = 15;
            pub const ProfileCategory_Action: root::AZ::Debug::ProfileCategory = 16;
            pub const ProfileCategory_Game: root::AZ::Debug::ProfileCategory = 17;
            pub const ProfileCategory_Input: root::AZ::Debug::ProfileCategory = 18;
            pub const ProfileCategory_Sync: root::AZ::Debug::ProfileCategory = 19;
            pub const ProfileCategory_LegacyNetworkTrafficReserved:
                root::AZ::Debug::ProfileCategory = 20;
            pub const ProfileCategory_LegacyDeviceReserved: root::AZ::Debug::ProfileCategory = 21;
            pub const ProfileCategory_LegacyLast: root::AZ::Debug::ProfileCategory = 22;
            pub const ProfileCategory_AzCore: root::AZ::Debug::ProfileCategory = 23;
            pub const ProfileCategory_AzRender: root::AZ::Debug::ProfileCategory = 24;
            pub const ProfileCategory_AzFramework: root::AZ::Debug::ProfileCategory = 25;
            pub const ProfileCategory_AzToolsFramework: root::AZ::Debug::ProfileCategory = 26;
            pub const ProfileCategory_ScriptCanvas: root::AZ::Debug::ProfileCategory = 27;
            pub const ProfileCategory_FirstDetailedCategory: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_RendererDetailed: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_ThreeDEngineDetailed: root::AZ::Debug::ProfileCategory = 29;
            pub const ProfileCategory_JobManagerDetailed: root::AZ::Debug::ProfileCategory = 30;
            pub const ProfileCategory_FirstReservedCategory: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_MemoryReserved: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_Global: root::AZ::Debug::ProfileCategory = 32;
            pub const ProfileCategory_Count: root::AZ::Debug::ProfileCategory = 33;
            pub type ProfileCategory = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerThreadData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Profiler {
                pub m_data: *mut root::AZ::Debug::ProfilerData,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Profiler_Descriptor {
                pub _address: u8,
            }
            pub type Profiler_ReadProfileRegisterCB = root::AZStd::function;
            pub const Profiler_m_maxNumberOfThreads: ::std::os::raw::c_int = 32;
            pub const Profiler_m_maxNumberOfSystems: ::std::os::raw::c_int = 64;
            extern "C" {
                #[link_name = "\u{1}?s_instance@Profiler@Debug@AZ@@0PEAV123@EA"]
                pub static mut Profiler_s_instance: *mut root::AZ::Debug::Profiler;
            }
            extern "C" {
                #[link_name = "\u{1}?s_id@Profiler@Debug@AZ@@0_KA"]
                pub static mut Profiler_s_id: root::AZ::u64;
            }
            extern "C" {
                #[link_name = "\u{1}?s_useCount@Profiler@Debug@AZ@@0HA"]
                pub static mut Profiler_s_useCount: ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?Create@Profiler@Debug@AZ@@SA_NAEBUDescriptor@123@@Z"]
                pub fn Profiler_Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Destroy@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_Destroy();
            }
            extern "C" {
                #[link_name = "\u{1}?IsReady@Profiler@Debug@AZ@@SA_NXZ"]
                pub fn Profiler_IsReady() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Instance@Profiler@Debug@AZ@@SAAEAV123@XZ"]
                pub fn Profiler_Instance() -> *mut root::AZ::Debug::Profiler;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@Profiler@Debug@AZ@@SA_KXZ"]
                pub fn Profiler_GetId() -> root::AZ::u64;
            }
            extern "C" {
                #[link_name = "\u{1}?AddReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_AddReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ReleaseReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_ReleaseReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ActivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_ActivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?DeactivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_DeactivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NPEBD@Z"]
                pub fn Profiler_IsSystemActive(
                    this: *const root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NI@Z"]
                pub fn Profiler_IsSystemActive1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetNumberOfSystems@Profiler@Debug@AZ@@QEBAHXZ"]
                pub fn Profiler_GetNumberOfSystems(
                    this: *const root::AZ::Debug::Profiler,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDH@Z"]
                pub fn Profiler_GetSystemName(
                    this: *const root::AZ::Debug::Profiler,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDI@Z"]
                pub fn Profiler_GetSystemName1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?ReadRegisterValues@Profiler@Debug@AZ@@QEBAXAEBV?$function@$$A6A_NAEBVProfilerRegister@Debug@AZ@@AEBUthread_id@AZStd@@@Z@AZStd@@IPEBUthread_id@5@@Z"]
                pub fn Profiler_ReadRegisterValues(
                    this: *const root::AZ::Debug::Profiler,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ResetRegisters@Profiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_ResetRegisters(this: *mut root::AZ::Debug::Profiler);
            }
            extern "C" {
                #[link_name = "\u{1}?RemoveThreadData@Profiler@Debug@AZ@@QEAAXUthread_id@AZStd@@@Z"]
                pub fn Profiler_RemoveThreadData(
                    this: *mut root::AZ::Debug::Profiler,
                    id: root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??_DProfiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_Profiler_destructor(this: *mut root::AZ::Debug::Profiler);
            }
            impl Profiler {
                #[inline]
                pub unsafe fn Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool {
                    Profiler_Create(desc)
                }
                #[inline]
                pub unsafe fn Destroy() {
                    Profiler_Destroy()
                }
                #[inline]
                pub unsafe fn IsReady() -> bool {
                    Profiler_IsReady()
                }
                #[inline]
                pub unsafe fn Instance() -> *mut root::AZ::Debug::Profiler {
                    Profiler_Instance()
                }
                #[inline]
                pub unsafe fn GetId() -> root::AZ::u64 {
                    Profiler_GetId()
                }
                #[inline]
                pub unsafe fn AddReference() {
                    Profiler_AddReference()
                }
                #[inline]
                pub unsafe fn ReleaseReference() {
                    Profiler_ReleaseReference()
                }
                #[inline]
                pub unsafe fn ActivateSystem(&mut self, systemName: *const ::std::os::raw::c_char) {
                    Profiler_ActivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn DeactivateSystem(
                    &mut self,
                    systemName: *const ::std::os::raw::c_char,
                ) {
                    Profiler_DeactivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive(
                    &self,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool {
                    Profiler_IsSystemActive(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive1(&self, systemId: root::AZ::u32) -> bool {
                    Profiler_IsSystemActive1(self, systemId)
                }
                #[inline]
                pub unsafe fn GetNumberOfSystems(&self) -> ::std::os::raw::c_int {
                    Profiler_GetNumberOfSystems(self)
                }
                #[inline]
                pub unsafe fn GetSystemName(
                    &self,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName(self, index)
                }
                #[inline]
                pub unsafe fn GetSystemName1(
                    &self,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName1(self, systemId)
                }
                #[inline]
                pub unsafe fn ReadRegisterValues(
                    &self,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                ) {
                    Profiler_ReadRegisterValues(self, callback, systemFilter, threadFilter)
                }
                #[inline]
                pub unsafe fn ResetRegisters(&mut self) {
                    Profiler_ResetRegisters(self)
                }
                #[inline]
                pub unsafe fn RemoveThreadData(&mut self, id: root::AZStd::thread_id) {
                    Profiler_RemoveThreadData(self, id)
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    Profiler_Profiler_destructor(self)
                }
            }
            #[repr(C)]
            pub struct ProfilerRegister {
                pub __bindgen_anon_1: root::AZ::Debug::ProfilerRegister__bindgen_ty_1,
                pub m_name: *const ::std::os::raw::c_char,
                pub m_function: *const ::std::os::raw::c_char,
                pub m_line: ::std::os::raw::c_int,
                pub m_systemId: root::AZ::u32,
                pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
                pub m_threadData: *mut root::AZ::Debug::ProfilerThreadData,
            }
            pub const ProfilerRegister_Type_PRT_TIME: root::AZ::Debug::ProfilerRegister_Type = 0;
            pub const ProfilerRegister_Type_PRT_VALUE: root::AZ::Debug::ProfilerRegister_Type = 1;
            pub type ProfilerRegister_Type = i32;
            #[repr(C)]
            pub struct ProfilerRegister_TimeData {
                pub m_time: root::AZ::u64,
                pub m_childrenTime: root::AZ::u64,
                pub m_calls: root::AZ::s64,
                pub m_childrenCalls: root::AZ::s64,
                pub m_lastParent: *mut root::AZ::Debug::ProfilerRegister,
            }
            extern "C" {
                #[link_name = "\u{1}?s_startStopOverheadPer1000Calls@TimeData@ProfilerRegister@Debug@AZ@@2V?$duration@_JV?$ratio@$00$0PECEA@@AZStd@@@chrono@AZStd@@A"]
                pub static mut ProfilerRegister_TimeData_s_startStopOverheadPer1000Calls:
                    root::AZStd::chrono::microseconds;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerRegister_ValuesData {
                pub m_value1: root::AZ::s64,
                pub m_value2: root::AZ::s64,
                pub m_value3: root::AZ::s64,
                pub m_value4: root::AZ::s64,
                pub m_value5: root::AZ::s64,
            }
            #[repr(C)]
            pub struct ProfilerRegister__bindgen_ty_1 {
                pub m_timeData:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_TimeData>,
                pub m_userValues:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_ValuesData>,
                pub bindgen_union_field: [u64; 5usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TimerCreateAndStart@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD0PEAVProfilerSection@23@0H@Z"]
                pub fn ProfilerRegister_TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?ValueCreate@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD00H@Z"]
                pub fn ProfilerRegister_ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?TimerStart@ProfilerRegister@Debug@AZ@@QEAAXPEAVProfilerSection@23@@Z"]
                pub fn ProfilerRegister_TimerStart(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    section: *mut root::AZ::Debug::ProfilerSection,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueSet(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueSet1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueSet2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueSet3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueSet4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueAdd(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueAdd1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueAdd2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueAdd3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueAdd4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0ProfilerRegister@Debug@AZ@@QEAA@XZ"]
                pub fn ProfilerRegister_ProfilerRegister(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                );
            }
            impl ProfilerRegister {
                #[inline]
                pub fn m_type(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
                }
                #[inline]
                pub fn set_m_type(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(0usize, 7u8, val as u64)
                    }
                }
                #[inline]
                pub fn m_isActive(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
                }
                #[inline]
                pub fn set_m_isActive(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(7usize, 1u8, val as u64)
                    }
                }
                #[inline]
                pub fn new_bitfield_1(
                    m_type: ::std::os::raw::c_uchar,
                    m_isActive: ::std::os::raw::c_uchar,
                ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                    let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                        Default::default();
                    __bindgen_bitfield_unit.set(0usize, 7u8, {
                        let m_type: u8 = unsafe { ::std::mem::transmute(m_type) };
                        m_type as u64
                    });
                    __bindgen_bitfield_unit.set(7usize, 1u8, {
                        let m_isActive: u8 = unsafe { ::std::mem::transmute(m_isActive) };
                        m_isActive as u64
                    });
                    __bindgen_bitfield_unit
                }
                #[inline]
                pub unsafe fn TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_TimerCreateAndStart(systemName, name, section, function, line)
                }
                #[inline]
                pub unsafe fn ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_ValueCreate(systemName, name, function, line)
                }
                #[inline]
                pub unsafe fn TimerStart(
                    &mut self,
                    section: *mut root::AZ::Debug::ProfilerSection,
                ) {
                    ProfilerRegister_TimerStart(self, section)
                }
                #[inline]
                pub unsafe fn ValueSet(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueSet(self, v1)
                }
                #[inline]
                pub unsafe fn ValueSet1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueSet2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueSet3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueSet4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet4(self, v1, v2, v3, v4, v5)
                }
                #[inline]
                pub unsafe fn ValueAdd(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueAdd(self, v1)
                }
                #[inline]
                pub unsafe fn ValueAdd1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueAdd2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueAdd3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueAdd4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd4(self, v1, v2, v3, v4, v5)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    ProfilerRegister_ProfilerRegister(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            pub struct ProfilerSection {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
                pub m_start: root::AZStd::chrono::system_clock_time_point,
                pub m_childTime: root::AZStd::chrono::microseconds,
                pub m_childCalls: ::std::os::raw::c_int,
            }
            extern "C" {
                #[link_name = "\u{1}?Stop@ProfilerSection@Debug@AZ@@QEAAXXZ"]
                pub fn ProfilerSection_Stop(this: *mut root::AZ::Debug::ProfilerSection);
            }
            extern "C" {
                #[link_name = "\u{1}??0ProfilerSection@Debug@AZ@@QEAA@XZ"]
                pub fn ProfilerSection_ProfilerSection(this: *mut root::AZ::Debug::ProfilerSection);
            }
            extern "C" {
                #[link_name = "\u{1}??_DProfilerSection@Debug@AZ@@QEAAXXZ"]
                pub fn ProfilerSection_ProfilerSection_destructor(
                    this: *mut root::AZ::Debug::ProfilerSection,
                );
            }
            impl ProfilerSection {
                #[inline]
                pub unsafe fn Stop(&mut self) {
                    ProfilerSection_Stop(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    ProfilerSection_ProfilerSection(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    ProfilerSection_ProfilerSection_destructor(self)
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocationRecords {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MemoryDriller {
                _unused: [u8; 0],
            }
        }
        pub const PlatformID_PLATFORM_WINDOWS_32: root::AZ::PlatformID = 0;
        pub const PlatformID_PLATFORM_WINDOWS_64: root::AZ::PlatformID = 1;
        pub const PlatformID_PLATFORM_LINUX_64: root::AZ::PlatformID = 2;
        pub const PlatformID_PLATFORM_ANDROID: root::AZ::PlatformID = 3;
        pub const PlatformID_PLATFORM_APPLE_IOS: root::AZ::PlatformID = 4;
        pub const PlatformID_PLATFORM_APPLE_OSX: root::AZ::PlatformID = 5;
        pub const PlatformID_PLATFORM_APPLE_TV: root::AZ::PlatformID = 6;
        pub const PlatformID_PLATFORM_ANDROID_64: root::AZ::PlatformID = 7;
        pub const PlatformID_PLATFORM_MAX: root::AZ::PlatformID = 8;
        pub type PlatformID = i32;
        pub type s8 = i8;
        pub type s16 = i16;
        pub type s32 = i32;
        pub type s64 = i64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct s128 {
            pub a: root::AZ::s64,
            pub b: root::AZ::s64,
        }
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct Uuid {
            pub data: [::std::os::raw::c_uchar; 16usize],
        }
        pub const Uuid_Variant_VAR_UNKNOWN: root::AZ::Uuid_Variant = -1;
        pub const Uuid_Variant_VAR_NCS: root::AZ::Uuid_Variant = 0;
        pub const Uuid_Variant_VAR_RFC_4122: root::AZ::Uuid_Variant = 2;
        pub const Uuid_Variant_VAR_MICROSOFT: root::AZ::Uuid_Variant = 6;
        pub const Uuid_Variant_VAR_RESERVED: root::AZ::Uuid_Variant = 7;
        pub type Uuid_Variant = i32;
        pub const Uuid_Version_VER_UNKNOWN: root::AZ::Uuid_Version = -1;
        pub const Uuid_Version_VER_TIME: root::AZ::Uuid_Version = 1;
        pub const Uuid_Version_VER_DCE: root::AZ::Uuid_Version = 2;
        pub const Uuid_Version_VER_NAME_MD5: root::AZ::Uuid_Version = 3;
        pub const Uuid_Version_VER_RANDOM: root::AZ::Uuid_Version = 4;
        pub const Uuid_Version_VER_NAME_SHA1: root::AZ::Uuid_Version = 5;
        pub type Uuid_Version = i32;
        pub type Uuid_iterator = *mut ::std::os::raw::c_uchar;
        pub type Uuid_const_iterator = *const ::std::os::raw::c_uchar;
        pub const Uuid_MaxStringBuffer: usize = 39;
        extern "C" {
            #[link_name = "\u{1}?CreateNull@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateNull() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?Create@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_Create() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateString@Uuid@AZ@@SA?AU12@PEBD_K@Z"]
            pub fn Uuid_CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateRandom@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateRandom() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateName@Uuid@AZ@@SA?AU12@PEBD@Z"]
            pub fn Uuid_CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateData@Uuid@AZ@@SA?AU12@PEBX_K@Z"]
            pub fn Uuid_CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?IsNull@Uuid@AZ@@QEBA_NXZ"]
            pub fn Uuid_IsNull(this: *const root::AZ::Uuid) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVariant@Uuid@AZ@@QEBA?AW4Variant@12@XZ"]
            pub fn Uuid_GetVariant(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Variant;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVersion@Uuid@AZ@@QEBA?AW4Version@12@XZ"]
            pub fn Uuid_GetVersion(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Version;
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@Uuid@AZ@@QEBAHPEADH_N1@Z"]
            pub fn Uuid_ToString(
                this: *const root::AZ::Uuid,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?begin@Uuid@AZ@@QEAAPEAEXZ"]
            pub fn Uuid_begin(this: *mut root::AZ::Uuid) -> root::AZ::Uuid_iterator;
        }
        extern "C" {
            #[link_name = "\u{1}?end@Uuid@AZ@@QEAAPEAEXZ"]
            pub fn Uuid_end(this: *mut root::AZ::Uuid) -> root::AZ::Uuid_iterator;
        }
        extern "C" {
            #[link_name = "\u{1}?begin@Uuid@AZ@@QEBAPEBEXZ"]
            pub fn Uuid_begin1(this: *const root::AZ::Uuid) -> root::AZ::Uuid_const_iterator;
        }
        extern "C" {
            #[link_name = "\u{1}?end@Uuid@AZ@@QEBAPEBEXZ"]
            pub fn Uuid_end1(this: *const root::AZ::Uuid) -> root::AZ::Uuid_const_iterator;
        }
        extern "C" {
            #[link_name = "\u{1}?GetHash@Uuid@AZ@@QEBA_KXZ"]
            pub fn Uuid_GetHash(this: *const root::AZ::Uuid) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}??0Uuid@AZ@@QEAA@XZ"]
            pub fn Uuid_Uuid(this: *mut root::AZ::Uuid);
        }
        extern "C" {
            #[link_name = "\u{1}??0Uuid@AZ@@QEAA@PEBD_K@Z"]
            pub fn Uuid_Uuid1(
                this: *mut root::AZ::Uuid,
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0Uuid@AZ@@QEAA@AEBU_GUID@@@Z"]
            pub fn Uuid_Uuid2(this: *mut root::AZ::Uuid, guid: *const root::GUID);
        }
        impl Uuid {
            #[inline]
            pub unsafe fn CreateNull() -> root::AZ::Uuid {
                Uuid_CreateNull()
            }
            #[inline]
            pub unsafe fn Create() -> root::AZ::Uuid {
                Uuid_Create()
            }
            #[inline]
            pub unsafe fn CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateString(string, stringLength)
            }
            #[inline]
            pub unsafe fn CreateRandom() -> root::AZ::Uuid {
                Uuid_CreateRandom()
            }
            #[inline]
            pub unsafe fn CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid {
                Uuid_CreateName(name)
            }
            #[inline]
            pub unsafe fn CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateData(data, dataSize)
            }
            #[inline]
            pub unsafe fn IsNull(&self) -> bool {
                Uuid_IsNull(self)
            }
            #[inline]
            pub unsafe fn GetVariant(&self) -> root::AZ::Uuid_Variant {
                Uuid_GetVariant(self)
            }
            #[inline]
            pub unsafe fn GetVersion(&self) -> root::AZ::Uuid_Version {
                Uuid_GetVersion(self)
            }
            #[inline]
            pub unsafe fn ToString(
                &self,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int {
                Uuid_ToString(self, output, outputSize, isBrackets, isDashes)
            }
            #[inline]
            pub unsafe fn begin(&mut self) -> root::AZ::Uuid_iterator {
                Uuid_begin(self)
            }
            #[inline]
            pub unsafe fn end(&mut self) -> root::AZ::Uuid_iterator {
                Uuid_end(self)
            }
            #[inline]
            pub unsafe fn begin1(&self) -> root::AZ::Uuid_const_iterator {
                Uuid_begin1(self)
            }
            #[inline]
            pub unsafe fn end1(&self) -> root::AZ::Uuid_const_iterator {
                Uuid_end1(self)
            }
            #[inline]
            pub unsafe fn GetHash(&self) -> usize {
                Uuid_GetHash(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Uuid_Uuid(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(string: *const ::std::os::raw::c_char, stringLength: usize) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Uuid_Uuid1(&mut __bindgen_tmp, string, stringLength);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(guid: *const root::GUID) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Uuid_Uuid2(&mut __bindgen_tmp, guid);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct Crc32 {
            pub m_value: root::AZ::u32,
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBD@Z"]
            pub fn Crc32_Add(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBX_K_N@Z"]
            pub fn Crc32_Add1(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@Crc32@AZ@@SAXAEAVSerializeContext@2@@Z"]
            pub fn Crc32_Reflect(context: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Crc32@AZ@@IEAAXPEBX_K_N@Z"]
            pub fn Crc32_Set(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Combine@Crc32@AZ@@IEAAXI_K@Z"]
            pub fn Crc32_Combine(this: *mut root::AZ::Crc32, crc: root::AZ::u32, len: usize);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@XZ"]
            pub fn Crc32_Crc32(this: *mut root::AZ::Crc32);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@I@Z"]
            pub fn Crc32_Crc321(this: *mut root::AZ::Crc32, value: root::AZ::u32);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBD@Z"]
            pub fn Crc32_Crc322(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
            pub fn Crc32_Crc323(this: *mut root::AZ::Crc32, view: root::AZStd::string_view);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBX_K_N@Z"]
            pub fn Crc32_Crc324(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        impl Crc32 {
            #[inline]
            pub unsafe fn Add(&mut self, str: *const ::std::os::raw::c_char) {
                Crc32_Add(self, str)
            }
            #[inline]
            pub unsafe fn Add1(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Add1(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::SerializeContext) {
                Crc32_Reflect(context)
            }
            #[inline]
            pub unsafe fn Set(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Set(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Combine(&mut self, crc: root::AZ::u32, len: usize) {
                Crc32_Combine(self, crc, len)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Crc32_Crc32(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(value: root::AZ::u32) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Crc32_Crc321(&mut __bindgen_tmp, value);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(str: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Crc32_Crc322(&mut __bindgen_tmp, str);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new3(view: root::AZStd::string_view) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Crc32_Crc323(&mut __bindgen_tmp, view);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new4(
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                Crc32_Crc324(&mut __bindgen_tmp, data, size, forceLowerCase);
                __bindgen_tmp
            }
        }
        pub type TypeId = root::AZ::Uuid;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PointerRemovedTypeIdTag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CanonicalTypeIdTag {
            pub _address: u8,
        }
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type AZTypeInfoIntrusiveResultType_type = root::std::true_type;
            pub type HasAZTypeInfoIntrusive_Yes = ::std::os::raw::c_char;
            pub type HasAZTypeInfoIntrusive_No = ::std::os::raw::c_long;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoIntrusive_Helper {
                pub _address: u8,
            }
            pub type HasAZTypeInfoIntrusive_Helper_mfp =
                ::std::option::Option<unsafe extern "C" fn()>;
            pub type HasAZTypeInfoIntrusive_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoSpecialized {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfo {
                pub _address: u8,
            }
            pub type HasAZTypeInfo_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AggregateTypes {
                pub _address: u8,
            }
            pub type TypeIdHolder = root::AZ::TypeId;
            #[repr(C)]
            pub struct CallstackEntryBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryBase {
                pub vtable_: *const CallstackEntryBase__bindgen_vtable,
                pub m_busId: *const [u8; 0usize],
                pub m_prev: *mut root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryBase_BusType = root::AZ::EBus;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntry {
                pub _base: root::AZ::Internal::CallstackEntryBase,
                pub m_context: root::AZ::Internal::CallstackEntry_BusContextPtr,
                pub m_threadId: root::AZStd::native_thread_id_type,
            }
            pub type CallstackEntry_BusType = root::AZ::EBus;
            pub type CallstackEntry_BusContextPtr = *mut root::AZ::Internal::CallstackEntry_BusType;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryRoot {
                pub _base: root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryRoot_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct RegisterData {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EnvironmentVariableResult {
                pub m_state: root::AZ::Internal::EnvironmentVariableResult_States,
                pub m_variable: *mut ::std::os::raw::c_void,
            }
            pub const EnvironmentVariableResult_States_Added:
                root::AZ::Internal::EnvironmentVariableResult_States = 0;
            pub const EnvironmentVariableResult_States_Removed:
                root::AZ::Internal::EnvironmentVariableResult_States = 1;
            pub const EnvironmentVariableResult_States_Found:
                root::AZ::Internal::EnvironmentVariableResult_States = 2;
            pub const EnvironmentVariableResult_States_NotFound:
                root::AZ::Internal::EnvironmentVariableResult_States = 3;
            pub const EnvironmentVariableResult_States_OutOfMemory:
                root::AZ::Internal::EnvironmentVariableResult_States = 4;
            pub type EnvironmentVariableResult_States = i32;
            #[repr(C)]
            pub struct EnvironmentInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EnvironmentInterface {
                pub vtable_: *const EnvironmentInterface__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?s_environment@EnvironmentInterface@Internal@AZ@@2PEAV123@EA"]
                pub static mut EnvironmentInterface_s_environment:
                    *mut root::AZ::Internal::EnvironmentInterface;
            }
            extern "C" {
                #[link_name = "\u{1}??_DEnvironmentInterface@Internal@AZ@@QEAAXXZ"]
                pub fn EnvironmentInterface_EnvironmentInterface_destructor(
                    this: *mut root::AZ::Internal::EnvironmentInterface,
                );
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolderBase {
                pub m_environmentOwner: *mut root::AZ::Internal::EnvironmentInterface,
                pub m_moduleOwner: *mut ::std::os::raw::c_void,
                pub m_canTransferOwnership: bool,
                pub m_isConstructed: bool,
                pub m_guid: root::AZ::u32,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
                pub m_useCount: ::std::os::raw::c_int,
                pub m_mutex: root::AZStd::spin_mutex,
            }
            extern "C" {
                #[link_name = "\u{1}?IsConstructed@EnvironmentVariableHolderBase@Internal@AZ@@QEBA_NXZ"]
                pub fn EnvironmentVariableHolderBase_IsConstructed(
                    this: *const root::AZ::Internal::EnvironmentVariableHolderBase,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@EnvironmentVariableHolderBase@Internal@AZ@@QEBAIXZ"]
                pub fn EnvironmentVariableHolderBase_GetId(
                    this: *const root::AZ::Internal::EnvironmentVariableHolderBase,
                ) -> root::AZ::u32;
            }
            extern "C" {
                #[link_name = "\u{1}??0EnvironmentVariableHolderBase@Internal@AZ@@QEAA@IPEAVEnvironmentInterface@12@_NPEAVAllocatorInterface@Environment@2@@Z"]
                pub fn EnvironmentVariableHolderBase_EnvironmentVariableHolderBase(
                    this: *mut root::AZ::Internal::EnvironmentVariableHolderBase,
                    guid: root::AZ::u32,
                    environmentOwner: *mut root::AZ::Internal::EnvironmentInterface,
                    canOwnershipTransfer: bool,
                    allocator: *mut root::AZ::Environment::AllocatorInterface,
                );
            }
            impl EnvironmentVariableHolderBase {
                #[inline]
                pub unsafe fn IsConstructed(&self) -> bool {
                    EnvironmentVariableHolderBase_IsConstructed(self)
                }
                #[inline]
                pub unsafe fn GetId(&self) -> root::AZ::u32 {
                    EnvironmentVariableHolderBase_GetId(self)
                }
                #[inline]
                pub unsafe fn new(
                    guid: root::AZ::u32,
                    environmentOwner: *mut root::AZ::Internal::EnvironmentInterface,
                    canOwnershipTransfer: bool,
                    allocator: *mut root::AZ::Environment::AllocatorInterface,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    EnvironmentVariableHolderBase_EnvironmentVariableHolderBase(
                        &mut __bindgen_tmp,
                        guid,
                        environmentOwner,
                        canOwnershipTransfer,
                        allocator,
                    );
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolder {
                pub _base: root::AZ::Internal::EnvironmentVariableHolderBase,
                pub m_value: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorDummy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct RttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            pub type RttiHelper_ValueType<T> = T;
            #[repr(C)]
            #[derive(Debug)]
            pub struct ExternalVariadicRttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsSameCast {
                pub _address: u8,
            }
            pub type AddressTypeHelper_type = *const ::std::os::raw::c_void;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiRemoveQualifiers {
                pub _address: u8,
            }
            pub type RttiRemoveQualifiers_type = root::std::remove_cv;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfIdHelper {
                pub _address: u8,
            }
            pub type EBusEnvironmentGetterType =
                ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::EBusEnvironment>;
            pub type EBusEnvironmentSetterType =
                ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::AZ::EBusEnvironment)>;
            #[repr(C)]
            pub struct ContextBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct ContextBase {
                pub vtable_: *const ContextBase__bindgen_vtable,
                pub m_ebusEnvironmentTLSIndex: ::std::os::raw::c_int,
                pub m_ebusEnvironmentGetter: root::AZ::Internal::EBusEnvironmentGetterType,
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@XZ"]
                pub fn ContextBase_ContextBase(this: *mut root::AZ::Internal::ContextBase);
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@PEAVEBusEnvironment@2@@Z"]
                pub fn ContextBase_ContextBase1(
                    this: *mut root::AZ::Internal::ContextBase,
                    arg1: *mut root::AZ::EBusEnvironment,
                );
            }
            impl ContextBase {
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    ContextBase_ContextBase(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(arg1: *mut root::AZ::EBusEnvironment) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    ContextBase_ContextBase1(&mut __bindgen_tmp, arg1);
                    __bindgen_tmp
                }
            }
            extern "C" {
                #[link_name = "\u{1}??_DContextBase@Internal@AZ@@QEAAXXZ"]
                pub fn ContextBase_ContextBase_destructor(
                    this: *mut root::AZ::Internal::ContextBase,
                );
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentTLSAccessors {
                pub m_getter: root::AZ::Internal::EBusEnvironmentGetterType,
                pub m_setter: root::AZ::Internal::EBusEnvironmentSetterType,
                pub m_numUniqueEBuses: root::AZStd::atomic_int,
            }
            extern "C" {
                #[link_name = "\u{1}?s_tlsCurrentEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@2PEAVEBusEnvironment@3@EA"]
                pub static mut EBusEnvironmentTLSAccessors_s_tlsCurrentEnvironment:
                    *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@EBusEnvironmentTLSAccessors@Internal@AZ@@SAIXZ"]
                pub fn EBusEnvironmentTLSAccessors_GetId() -> root::AZ::u32;
            }
            extern "C" {
                #[link_name = "\u{1}?GetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAPEAVEBusEnvironment@3@XZ"]
                pub fn EBusEnvironmentTLSAccessors_GetTLSEnvironment(
                ) -> *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?SetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAXPEAVEBusEnvironment@3@@Z"]
                pub fn EBusEnvironmentTLSAccessors_SetTLSEnvironment(
                    environment: *mut root::AZ::EBusEnvironment,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentTLSAccessors@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(
                    this: *mut root::AZ::Internal::EBusEnvironmentTLSAccessors,
                );
            }
            impl EBusEnvironmentTLSAccessors {
                #[inline]
                pub unsafe fn GetId() -> root::AZ::u32 {
                    EBusEnvironmentTLSAccessors_GetId()
                }
                #[inline]
                pub unsafe fn GetTLSEnvironment() -> *mut root::AZ::EBusEnvironment {
                    EBusEnvironmentTLSAccessors_GetTLSEnvironment()
                }
                #[inline]
                pub unsafe fn SetTLSEnvironment(environment: *mut root::AZ::EBusEnvironment) {
                    EBusEnvironmentTLSAccessors_SetTLSEnvironment(environment)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentAllocator {
                pub m_name: *const ::std::os::raw::c_char,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
            }
            pub type EBusEnvironmentAllocator_pointer_type = *mut ::std::os::raw::c_void;
            pub type EBusEnvironmentAllocator_size_type = usize;
            pub type EBusEnvironmentAllocator_difference_type = isize;
            pub type EBusEnvironmentAllocator_allow_memory_leaks = root::std::false_type;
            extern "C" {
                #[link_name = "\u{1}?allocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAPEAX_K0H@Z"]
                pub fn EBusEnvironmentAllocator_allocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type;
            }
            extern "C" {
                #[link_name = "\u{1}?resize@EBusEnvironmentAllocator@Internal@AZ@@QEAA_KPEAX_K@Z"]
                pub fn EBusEnvironmentAllocator_resize(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    arg1: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    arg2: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type;
            }
            extern "C" {
                #[link_name = "\u{1}?deallocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAXPEAX_K1@Z"]
                pub fn EBusEnvironmentAllocator_deallocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?get_name@EBusEnvironmentAllocator@Internal@AZ@@QEBAPEBDXZ"]
                pub fn EBusEnvironmentAllocator_get_name(
                    this: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?set_name@EBusEnvironmentAllocator@Internal@AZ@@QEAAXPEBD@Z"]
                pub fn EBusEnvironmentAllocator_set_name(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    name: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?get_max_size@EBusEnvironmentAllocator@Internal@AZ@@QEBA_KXZ"]
                pub fn EBusEnvironmentAllocator_get_max_size(
                    this: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type;
            }
            extern "C" {
                #[link_name = "\u{1}?get_allocated_size@EBusEnvironmentAllocator@Internal@AZ@@QEBA_KXZ"]
                pub fn EBusEnvironmentAllocator_get_allocated_size(
                    this: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type;
            }
            extern "C" {
                #[link_name = "\u{1}?is_lock_free@EBusEnvironmentAllocator@Internal@AZ@@QEAA_NXZ"]
                pub fn EBusEnvironmentAllocator_is_lock_free(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?is_stale_read_allowed@EBusEnvironmentAllocator@Internal@AZ@@QEAA_NXZ"]
                pub fn EBusEnvironmentAllocator_is_stale_read_allowed(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?is_delayed_recycling@EBusEnvironmentAllocator@Internal@AZ@@QEAA_NXZ"]
                pub fn EBusEnvironmentAllocator_is_delayed_recycling(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@AEBV012@@Z"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator1(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            impl EBusEnvironmentAllocator {
                #[inline]
                pub unsafe fn allocate(
                    &mut self,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type {
                    EBusEnvironmentAllocator_allocate(self, byteSize, alignment, flags)
                }
                #[inline]
                pub unsafe fn resize(
                    &mut self,
                    arg1: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    arg2: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type {
                    EBusEnvironmentAllocator_resize(self, arg1, arg2)
                }
                #[inline]
                pub unsafe fn deallocate(
                    &mut self,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                ) {
                    EBusEnvironmentAllocator_deallocate(self, ptr, byteSize, alignment)
                }
                #[inline]
                pub unsafe fn get_name(&self) -> *const ::std::os::raw::c_char {
                    EBusEnvironmentAllocator_get_name(self)
                }
                #[inline]
                pub unsafe fn set_name(&mut self, name: *const ::std::os::raw::c_char) {
                    EBusEnvironmentAllocator_set_name(self, name)
                }
                #[inline]
                pub unsafe fn get_max_size(
                    &self,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type {
                    EBusEnvironmentAllocator_get_max_size(self)
                }
                #[inline]
                pub unsafe fn get_allocated_size(
                    &self,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_size_type {
                    EBusEnvironmentAllocator_get_allocated_size(self)
                }
                #[inline]
                pub unsafe fn is_lock_free(&mut self) -> bool {
                    EBusEnvironmentAllocator_is_lock_free(self)
                }
                #[inline]
                pub unsafe fn is_stale_read_allowed(&mut self) -> bool {
                    EBusEnvironmentAllocator_is_stale_read_allowed(self)
                }
                #[inline]
                pub unsafe fn is_delayed_recycling(&mut self) -> bool {
                    EBusEnvironmentAllocator_is_delayed_recycling(self)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator1(&mut __bindgen_tmp, rhs);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullBusMessageCall {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HandlerCompare<Comparer> {
                pub _base: Comparer,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Comparer>>,
            }
            #[repr(C)]
            pub struct NonIdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct NonIdHandler<Interface> {
                pub vtable_: *const NonIdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type NonIdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct IdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct IdHandler<Interface> {
                pub vtable_: *const IdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type IdHandler_IdType = [u8; 0usize];
            pub type IdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct MultiHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct MultiHandler<Interface> {
                pub vtable_: *const MultiHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_handlerNodes: root::AZStd::unordered_map,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type MultiHandler_IdType = [u8; 0usize];
            pub type MultiHandler_HandlerNode = [u8; 0usize];
            pub type MultiHandler_BusType = root::AZ::EBus;
            pub mod _bindgen_mod_id_100979 {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug)]
                pub struct MidDispatchDisconnectFixer<PreHandler, PostHandler> {
                    pub _base: root::AZ::Internal::CallstackEntry,
                    pub m_onPreDisconnect: PreHandler,
                    pub m_onPostDisconnect: PostHandler,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PreHandler>>,
                    pub _phantom_1:
                        ::std::marker::PhantomData<::std::cell::UnsafeCell<PostHandler>>,
                }
                pub type MidDispatchDisconnectFixer_Base = root::AZ::Internal::CallstackEntry;
            }
            pub type EBusContainer_ContainerType = u8;
            pub type EBusContainer_IdType = [u8; 0usize];
            pub type EBusContainer_CallstackEntry = root::AZ::Internal::CallstackEntry;
            pub type EBusContainer_HandlerNode = u8;
            pub type EBusContainer_AddressStorage = u8;
            pub type EBusContainer_HandlerStorage = u8;
            pub type EBusContainer_Handler<Interface> = root::AZ::Internal::IdHandler<Interface>;
            pub type EBusContainer_MultiHandler<Interface> =
                root::AZ::Internal::MultiHandler<Interface>;
            pub type EBusContainer_BusPtr =
                root::AZStd::intrusive_ptr<root::AZ::Internal::EBusContainer_HandlerHolder>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusContainer_Dispatcher {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusContainer_HandlerHolder {
                pub m_busContainer: *mut root::AZ::Internal::EBusContainer_ContainerType,
                pub m_busId: root::AZ::Internal::EBusContainer_IdType,
                pub m_handlers: root::AZ::Internal::EBusContainer_HandlerStorage,
                pub m_refCount: root::AZStd::atomic_uint,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullLockGuard {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterQueueEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusRouter__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EBusRouter<EBus> {
                pub vtable_: *const EBusRouter__bindgen_vtable,
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub m_isConnected: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNestedVersionRouter<EBus> {
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
        }
        pub type EnvironmentInstance = *mut root::AZ::Internal::EnvironmentInterface;
        pub mod Environment {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct AllocatorInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorInterface {
                pub vtable_: *const AllocatorInterface__bindgen_vtable,
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EnvironmentVariable {
            pub m_data: *mut root::AZ::EnvironmentVariable_HolderType,
        }
        pub type EnvironmentVariable_HolderType = root::AZ::Internal::EnvironmentVariableHolder;
        pub type EnvironmentVariable_unspecified_bool_type =
            *mut *mut root::AZ::EnvironmentVariable_HolderType;
        #[repr(C)]
        pub struct IAllocatorAllocate__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocatorAllocate {
            pub vtable_: *const IAllocatorAllocate__bindgen_vtable,
        }
        pub type IAllocatorAllocate_pointer_type = *mut ::std::os::raw::c_void;
        pub type IAllocatorAllocate_size_type = usize;
        pub type IAllocatorAllocate_difference_type = isize;
        extern "C" {
            #[link_name = "\u{1}??_DIAllocatorAllocate@AZ@@QEAAXXZ"]
            pub fn IAllocatorAllocate_IAllocatorAllocate_destructor(
                this: *mut root::AZ::IAllocatorAllocate,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GarbageCollect@IAllocatorAllocate@AZ@@UEAAXXZ"]
            pub fn IAllocatorAllocate_GarbageCollect(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?GetMaxAllocationSize@IAllocatorAllocate@AZ@@UEBA_KXZ"]
            pub fn IAllocatorAllocate_GetMaxAllocationSize(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetUnAllocatedMemory@IAllocatorAllocate@AZ@@UEBA_K_N@Z"]
            pub fn IAllocatorAllocate_GetUnAllocatedMemory(
                this: *mut ::std::os::raw::c_void,
                isPrint: bool,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocator {
            pub _base: root::AZ::IAllocatorAllocate,
            pub m_records: *mut root::AZ::Debug::AllocationRecords,
            pub m_isReady: bool,
        }
        extern "C" {
            #[link_name = "\u{1}?GetRecords@IAllocator@AZ@@QEAAPEAVAllocationRecords@Debug@2@XZ"]
            pub fn IAllocator_GetRecords(
                this: *mut root::AZ::IAllocator,
            ) -> *mut root::AZ::Debug::AllocationRecords;
        }
        extern "C" {
            #[link_name = "\u{1}?IsReady@IAllocator@AZ@@QEBA_NXZ"]
            pub fn IAllocator_IsReady(this: *const root::AZ::IAllocator) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?OnCreated@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnCreated(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnDestroy@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnDestroy(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnOutOfMemory@IAllocator@AZ@@IEAA_N_K0HPEBD1H@Z"]
            pub fn IAllocator_OnOutOfMemory(
                this: *mut root::AZ::IAllocator,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0IAllocator@AZ@@QEAA@XZ"]
            pub fn IAllocator_IAllocator(this: *mut root::AZ::IAllocator);
        }
        impl IAllocator {
            #[inline]
            pub unsafe fn GetRecords(&mut self) -> *mut root::AZ::Debug::AllocationRecords {
                IAllocator_GetRecords(self)
            }
            #[inline]
            pub unsafe fn IsReady(&self) -> bool {
                IAllocator_IsReady(self)
            }
            #[inline]
            pub unsafe fn OnCreated(&mut self) {
                IAllocator_OnCreated(self)
            }
            #[inline]
            pub unsafe fn OnDestroy(&mut self) {
                IAllocator_OnDestroy(self)
            }
            #[inline]
            pub unsafe fn OnOutOfMemory(
                &mut self,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool {
                IAllocator_OnOutOfMemory(self, byteSize, alignment, flags, name, fileName, lineNum)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                IAllocator_IAllocator(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DIAllocator@AZ@@QEAAXXZ"]
            pub fn IAllocator_IAllocator_destructor(this: *mut root::AZ::IAllocator);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AllocatorBase<SchemaType> {
            pub _base: root::AZ::IAllocator,
            pub m_schema: *mut root::AZ::AllocatorBase_Schema<SchemaType>,
            pub m_name: *const ::std::os::raw::c_char,
            pub m_desc: *const ::std::os::raw::c_char,
            pub m_schemaStorage: u8,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<SchemaType>>,
        }
        pub type AllocatorBase_Descriptor<DescriptorType> = DescriptorType;
        pub type AllocatorBase_Schema<SchemaType> = SchemaType;
        pub mod Memory {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocatorInstance {
            pub _address: u8,
        }
        pub type AllocatorInstance_Descriptor = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct ChildAllocatorSchema {
            pub _base: root::AZ::IAllocatorAllocate,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ChildAllocatorSchema_Descriptor {
            pub _address: u8,
        }
        pub type ChildAllocatorSchema_Parent<ParentAllocator> = ParentAllocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdAlloc {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdAlloc_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdAlloc_size_type = usize;
        pub type AZStdAlloc_difference_type = isize;
        pub type AZStdAlloc_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdIAllocator {
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdIAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdIAllocator_size_type = usize;
        pub type AZStdIAllocator_difference_type = isize;
        pub type AZStdIAllocator_allow_memory_leaks = root::std::false_type;
        extern "C" {
            #[link_name = "\u{1}?allocate@AZStdIAllocator@AZ@@QEAAPEAX_K0H@Z"]
            pub fn AZStdIAllocator_allocate(
                this: *mut root::AZ::AZStdIAllocator,
                byteSize: usize,
                alignment: usize,
                flags: ::std::os::raw::c_int,
            ) -> root::AZ::AZStdIAllocator_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?resize@AZStdIAllocator@AZ@@QEAA_KPEAX_K@Z"]
            pub fn AZStdIAllocator_resize(
                this: *mut root::AZ::AZStdIAllocator,
                ptr: root::AZ::AZStdIAllocator_pointer_type,
                newSize: usize,
            ) -> root::AZ::AZStdIAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@AZStdIAllocator@AZ@@QEAAXPEAX_K1@Z"]
            pub fn AZStdIAllocator_deallocate(
                this: *mut root::AZ::AZStdIAllocator,
                ptr: root::AZ::AZStdIAllocator_pointer_type,
                byteSize: usize,
                alignment: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?get_name@AZStdIAllocator@AZ@@QEBAPEBDXZ"]
            pub fn AZStdIAllocator_get_name(
                this: *const root::AZ::AZStdIAllocator,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?set_name@AZStdIAllocator@AZ@@QEAAXPEBD@Z"]
            pub fn AZStdIAllocator_set_name(
                this: *mut root::AZ::AZStdIAllocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?get_max_size@AZStdIAllocator@AZ@@QEBA_KXZ"]
            pub fn AZStdIAllocator_get_max_size(
                this: *const root::AZ::AZStdIAllocator,
            ) -> root::AZ::AZStdIAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_allocated_size@AZStdIAllocator@AZ@@QEBA_KXZ"]
            pub fn AZStdIAllocator_get_allocated_size(
                this: *const root::AZ::AZStdIAllocator,
            ) -> root::AZ::AZStdIAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdIAllocator@AZ@@QEAA@PEAVIAllocatorAllocate@1@PEBD@Z"]
            pub fn AZStdIAllocator_AZStdIAllocator(
                this: *mut root::AZ::AZStdIAllocator,
                allocator: *mut root::AZ::IAllocatorAllocate,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdIAllocator@AZ@@QEAA@AEBV01@@Z"]
            pub fn AZStdIAllocator_AZStdIAllocator1(
                this: *mut root::AZ::AZStdIAllocator,
                rhs: *const root::AZ::AZStdIAllocator,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdIAllocator@AZ@@QEAA@AEBV01@PEBD@Z"]
            pub fn AZStdIAllocator_AZStdIAllocator2(
                this: *mut root::AZ::AZStdIAllocator,
                rhs: *const root::AZ::AZStdIAllocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        impl AZStdIAllocator {
            #[inline]
            pub unsafe fn allocate(
                &mut self,
                byteSize: usize,
                alignment: usize,
                flags: ::std::os::raw::c_int,
            ) -> root::AZ::AZStdIAllocator_pointer_type {
                AZStdIAllocator_allocate(self, byteSize, alignment, flags)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                ptr: root::AZ::AZStdIAllocator_pointer_type,
                newSize: usize,
            ) -> root::AZ::AZStdIAllocator_size_type {
                AZStdIAllocator_resize(self, ptr, newSize)
            }
            #[inline]
            pub unsafe fn deallocate(
                &mut self,
                ptr: root::AZ::AZStdIAllocator_pointer_type,
                byteSize: usize,
                alignment: usize,
            ) {
                AZStdIAllocator_deallocate(self, ptr, byteSize, alignment)
            }
            #[inline]
            pub unsafe fn get_name(&self) -> *const ::std::os::raw::c_char {
                AZStdIAllocator_get_name(self)
            }
            #[inline]
            pub unsafe fn set_name(&mut self, name: *const ::std::os::raw::c_char) {
                AZStdIAllocator_set_name(self, name)
            }
            #[inline]
            pub unsafe fn get_max_size(&self) -> root::AZ::AZStdIAllocator_size_type {
                AZStdIAllocator_get_max_size(self)
            }
            #[inline]
            pub unsafe fn get_allocated_size(&self) -> root::AZ::AZStdIAllocator_size_type {
                AZStdIAllocator_get_allocated_size(self)
            }
            #[inline]
            pub unsafe fn new(
                allocator: *mut root::AZ::IAllocatorAllocate,
                name: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdIAllocator_AZStdIAllocator(&mut __bindgen_tmp, allocator, name);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(rhs: *const root::AZ::AZStdIAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdIAllocator_AZStdIAllocator1(&mut __bindgen_tmp, rhs);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                rhs: *const root::AZ::AZStdIAllocator,
                name: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdIAllocator_AZStdIAllocator2(&mut __bindgen_tmp, rhs, name);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdFunctorAllocator {
            pub m_allocatorFunctor: root::AZ::AZStdFunctorAllocator_functor_type,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdFunctorAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdFunctorAllocator_size_type = usize;
        pub type AZStdFunctorAllocator_difference_type = isize;
        pub type AZStdFunctorAllocator_allow_memory_leaks = root::std::false_type;
        pub type AZStdFunctorAllocator_functor_type =
            ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::IAllocatorAllocate>;
        extern "C" {
            #[link_name = "\u{1}?allocate@AZStdFunctorAllocator@AZ@@QEAAPEAX_K0H@Z"]
            pub fn AZStdFunctorAllocator_allocate(
                this: *mut root::AZ::AZStdFunctorAllocator,
                byteSize: usize,
                alignment: usize,
                flags: ::std::os::raw::c_int,
            ) -> root::AZ::AZStdFunctorAllocator_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?resize@AZStdFunctorAllocator@AZ@@QEAA_KPEAX_K@Z"]
            pub fn AZStdFunctorAllocator_resize(
                this: *mut root::AZ::AZStdFunctorAllocator,
                ptr: root::AZ::AZStdFunctorAllocator_pointer_type,
                newSize: usize,
            ) -> root::AZ::AZStdFunctorAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@AZStdFunctorAllocator@AZ@@QEAAXPEAX_K1@Z"]
            pub fn AZStdFunctorAllocator_deallocate(
                this: *mut root::AZ::AZStdFunctorAllocator,
                ptr: root::AZ::AZStdFunctorAllocator_pointer_type,
                byteSize: usize,
                alignment: usize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?get_name@AZStdFunctorAllocator@AZ@@QEBAPEBDXZ"]
            pub fn AZStdFunctorAllocator_get_name(
                this: *const root::AZ::AZStdFunctorAllocator,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?set_name@AZStdFunctorAllocator@AZ@@QEAAXPEBD@Z"]
            pub fn AZStdFunctorAllocator_set_name(
                this: *mut root::AZ::AZStdFunctorAllocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?get_max_size@AZStdFunctorAllocator@AZ@@QEBA_KXZ"]
            pub fn AZStdFunctorAllocator_get_max_size(
                this: *const root::AZ::AZStdFunctorAllocator,
            ) -> root::AZ::AZStdFunctorAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_allocated_size@AZStdFunctorAllocator@AZ@@QEBA_KXZ"]
            pub fn AZStdFunctorAllocator_get_allocated_size(
                this: *const root::AZ::AZStdFunctorAllocator,
            ) -> root::AZ::AZStdFunctorAllocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdFunctorAllocator@AZ@@QEAA@P6AAEAVIAllocatorAllocate@1@XZPEBD@Z"]
            pub fn AZStdFunctorAllocator_AZStdFunctorAllocator(
                this: *mut root::AZ::AZStdFunctorAllocator,
                allocatorFunctor: root::AZ::AZStdFunctorAllocator_functor_type,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdFunctorAllocator@AZ@@QEAA@AEBV01@PEBD@Z"]
            pub fn AZStdFunctorAllocator_AZStdFunctorAllocator1(
                this: *mut root::AZ::AZStdFunctorAllocator,
                rhs: *const root::AZ::AZStdFunctorAllocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0AZStdFunctorAllocator@AZ@@QEAA@AEBV01@@Z"]
            pub fn AZStdFunctorAllocator_AZStdFunctorAllocator2(
                this: *mut root::AZ::AZStdFunctorAllocator,
                rhs: *const root::AZ::AZStdFunctorAllocator,
            );
        }
        impl AZStdFunctorAllocator {
            #[inline]
            pub unsafe fn allocate(
                &mut self,
                byteSize: usize,
                alignment: usize,
                flags: ::std::os::raw::c_int,
            ) -> root::AZ::AZStdFunctorAllocator_pointer_type {
                AZStdFunctorAllocator_allocate(self, byteSize, alignment, flags)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                ptr: root::AZ::AZStdFunctorAllocator_pointer_type,
                newSize: usize,
            ) -> root::AZ::AZStdFunctorAllocator_size_type {
                AZStdFunctorAllocator_resize(self, ptr, newSize)
            }
            #[inline]
            pub unsafe fn deallocate(
                &mut self,
                ptr: root::AZ::AZStdFunctorAllocator_pointer_type,
                byteSize: usize,
                alignment: usize,
            ) {
                AZStdFunctorAllocator_deallocate(self, ptr, byteSize, alignment)
            }
            #[inline]
            pub unsafe fn get_name(&self) -> *const ::std::os::raw::c_char {
                AZStdFunctorAllocator_get_name(self)
            }
            #[inline]
            pub unsafe fn set_name(&mut self, name: *const ::std::os::raw::c_char) {
                AZStdFunctorAllocator_set_name(self, name)
            }
            #[inline]
            pub unsafe fn get_max_size(&self) -> root::AZ::AZStdFunctorAllocator_size_type {
                AZStdFunctorAllocator_get_max_size(self)
            }
            #[inline]
            pub unsafe fn get_allocated_size(&self) -> root::AZ::AZStdFunctorAllocator_size_type {
                AZStdFunctorAllocator_get_allocated_size(self)
            }
            #[inline]
            pub unsafe fn new(
                allocatorFunctor: root::AZ::AZStdFunctorAllocator_functor_type,
                name: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdFunctorAllocator_AZStdFunctorAllocator(
                    &mut __bindgen_tmp,
                    allocatorFunctor,
                    name,
                );
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(
                rhs: *const root::AZ::AZStdFunctorAllocator,
                name: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdFunctorAllocator_AZStdFunctorAllocator1(&mut __bindgen_tmp, rhs, name);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(rhs: *const root::AZ::AZStdFunctorAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                AZStdFunctorAllocator_AZStdFunctorAllocator2(&mut __bindgen_tmp, rhs);
                __bindgen_tmp
            }
        }
        pub type AZClassAllocatorResultType_type = root::std::true_type;
        pub type HasAZClassAllocator_Yes = ::std::os::raw::c_char;
        pub type HasAZClassAllocator_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZClassAllocator_Helper {
            pub _address: u8,
        }
        pub type HasAZClassAllocator_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZClassAllocator_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct OSAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_numAllocatedBytes: root::AZ::IAllocatorAllocate_size_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OSAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
        }
        extern "C" {
            #[link_name = "\u{1}??0Descriptor@OSAllocator@AZ@@QEAA@XZ"]
            pub fn OSAllocator_Descriptor_Descriptor(this: *mut root::AZ::OSAllocator_Descriptor);
        }
        impl OSAllocator_Descriptor {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                OSAllocator_Descriptor_Descriptor(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_TYPEINFO_Enable(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Name@OSAllocator@AZ@@SAPEBDXZ"]
            pub fn OSAllocator_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Uuid@OSAllocator@AZ@@SAAEBUUuid@2@XZ"]
            pub fn OSAllocator_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
        }
        extern "C" {
            #[link_name = "\u{1}?Create@OSAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn OSAllocator_Create(
                this: *mut root::AZ::OSAllocator,
                desc: *const root::AZ::OSAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_Destroy(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@QEAA@XZ"]
            pub fn OSAllocator_OSAllocator(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn OSAllocator_OSAllocator1(
                this: *mut root::AZ::OSAllocator,
                arg1: *const root::AZ::OSAllocator,
            );
        }
        impl OSAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                OSAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                OSAllocator_TYPEINFO_Name()
            }
            #[inline]
            pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                OSAllocator_TYPEINFO_Uuid()
            }
            #[inline]
            pub unsafe fn Create(&mut self, desc: *const root::AZ::OSAllocator_Descriptor) -> bool {
                OSAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                OSAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                OSAllocator_OSAllocator(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::OSAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                OSAllocator_OSAllocator1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DOSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_OSAllocator_destructor(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?GetName@OSAllocator@AZ@@UEBAPEBDXZ"]
            pub fn OSAllocator_GetName(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?GetDescription@OSAllocator@AZ@@UEBAPEBDXZ"]
            pub fn OSAllocator_GetDescription(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@OSAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn OSAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@OSAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn OSAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Resize@OSAllocator@AZ@@UEAA_KPEAX_K@Z"]
            pub fn OSAllocator_Resize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?ReAllocate@OSAllocator@AZ@@UEAAPEAXPEAX_K1@Z"]
            pub fn OSAllocator_ReAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
                newAlignment: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?AllocationSize@OSAllocator@AZ@@UEAA_KPEAX@Z"]
            pub fn OSAllocator_AllocationSize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?NumAllocatedBytes@OSAllocator@AZ@@UEBA_KXZ"]
            pub fn OSAllocator_NumAllocatedBytes(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?Capacity@OSAllocator@AZ@@UEBA_KXZ"]
            pub fn OSAllocator_Capacity(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetMaxAllocationSize@OSAllocator@AZ@@UEBA_KXZ"]
            pub fn OSAllocator_GetMaxAllocationSize(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSubAllocator@OSAllocator@AZ@@UEAAPEAVIAllocatorAllocate@2@XZ"]
            pub fn OSAllocator_GetSubAllocator(
                this: *mut ::std::os::raw::c_void,
            ) -> *mut root::AZ::IAllocatorAllocate;
        }
        pub type OSStdAllocator = root::AZ::AZStdAlloc;
        pub type RTTI_EnumCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::AZ::TypeId, arg2: *mut ::std::os::raw::c_void),
        >;
        pub type AZRttiIntrusiveResultType_type = root::std::true_type;
        pub type HasAZRttiIntrusive_Yes = ::std::os::raw::c_char;
        pub type HasAZRttiIntrusive_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiIntrusive_Helper {
            pub _address: u8,
        }
        pub type HasAZRttiIntrusive_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZRttiIntrusive_type = u8;
        pub const RttiKind_None: root::AZ::RttiKind = 0;
        pub const RttiKind_Intrusive: root::AZ::RttiKind = 1;
        pub const RttiKind_External: root::AZ::RttiKind = 2;
        pub type RttiKind = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiExternal {
            pub _address: u8,
        }
        pub type HasAZRttiExternal_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRtti {
            pub _address: u8,
        }
        pub type HasAZRtti_type = u8;
        pub type HasAZRtti_kind_type = u8;
        #[repr(C)]
        pub struct IRttiHelper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRttiHelper {
            pub vtable_: *const IRttiHelper__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}??_DIRttiHelper@AZ@@QEAAXXZ"]
            pub fn IRttiHelper_IRttiHelper_destructor(this: *mut root::AZ::IRttiHelper);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusEnvironment {
            pub m_tlsAccessor: root::AZ::EnvironmentVariable,
            pub m_stackPrevEnvironment: *mut root::AZ::EBusEnvironment,
            pub m_busContexts: root::AZStd::vector<
                root::AZStd::pair<*mut root::AZ::Internal::ContextBase, bool>,
                root::AZ::OSStdAllocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_Allocate@EBusEnvironment@AZ@@SAPEAXXZ"]
            pub fn EBusEnvironment_AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_DeAllocate@EBusEnvironment@AZ@@SAXPEAX@Z"]
            pub fn EBusEnvironment_AZ_CLASS_ALLOCATOR_DeAllocate(
                object: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ActivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_ActivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?DeactivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_DeactivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@EBusEnvironment@AZ@@SAPEAV12@XZ"]
            pub fn EBusEnvironment_Create() -> *mut root::AZ::EBusEnvironment;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@EBusEnvironment@AZ@@SAXPEAV12@@Z"]
            pub fn EBusEnvironment_Destroy(environment: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?FindContext@EBusEnvironment@AZ@@QEAAPEAVContextBase@Internal@2@H@Z"]
            pub fn EBusEnvironment_FindContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase;
        }
        extern "C" {
            #[link_name = "\u{1}?InsertContext@EBusEnvironment@AZ@@QEAA_NHPEAVContextBase@Internal@2@_N@Z"]
            pub fn EBusEnvironment_InsertContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0EBusEnvironment@AZ@@QEAA@XZ"]
            pub fn EBusEnvironment_EBusEnvironment(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}??_DEBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_EBusEnvironment_destructor(this: *mut root::AZ::EBusEnvironment);
        }
        impl EBusEnvironment {
            #[inline]
            pub unsafe fn AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void {
                EBusEnvironment_AZ_CLASS_ALLOCATOR_Allocate()
            }
            #[inline]
            pub unsafe fn AZ_CLASS_ALLOCATOR_DeAllocate(object: *mut ::std::os::raw::c_void) {
                EBusEnvironment_AZ_CLASS_ALLOCATOR_DeAllocate(object)
            }
            #[inline]
            pub unsafe fn ActivateOnCurrentThread(&mut self) {
                EBusEnvironment_ActivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn DeactivateOnCurrentThread(&mut self) {
                EBusEnvironment_DeactivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn Create() -> *mut root::AZ::EBusEnvironment {
                EBusEnvironment_Create()
            }
            #[inline]
            pub unsafe fn Destroy(environment: *mut root::AZ::EBusEnvironment) {
                EBusEnvironment_Destroy(environment)
            }
            #[inline]
            pub unsafe fn FindContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase {
                EBusEnvironment_FindContext(self, tlsKey)
            }
            #[inline]
            pub unsafe fn InsertContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool {
                EBusEnvironment_InsertContext(self, tlsKey, context, isTakeOwnership)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                EBusEnvironment_EBusEnvironment(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                EBusEnvironment_EBusEnvironment_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusEnvironmentStoragePolicy {
            pub _address: u8,
        }
        pub const EBusAddressPolicy_Single: root::AZ::EBusAddressPolicy = 0;
        pub const EBusAddressPolicy_ById: root::AZ::EBusAddressPolicy = 1;
        pub const EBusAddressPolicy_ByIdAndOrdered: root::AZ::EBusAddressPolicy = 2;
        pub type EBusAddressPolicy = i32;
        pub const EBusHandlerPolicy_Single: root::AZ::EBusHandlerPolicy = 0;
        pub const EBusHandlerPolicy_Multiple: root::AZ::EBusHandlerPolicy = 1;
        pub const EBusHandlerPolicy_MultipleAndOrdered: root::AZ::EBusHandlerPolicy = 2;
        pub type EBusHandlerPolicy = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusConnectionPolicy {
            pub _address: u8,
        }
        pub type EBusConnectionPolicy_BusPtr = [u8; 0usize];
        pub type EBusConnectionPolicy_BusIdType = [u8; 0usize];
        pub type EBusConnectionPolicy_HandlerNode = [u8; 0usize];
        pub type EBusConnectionPolicy_Context = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusGlobalStoragePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusThreadLocalStoragePolicy {
            pub _address: u8,
        }
        pub type EBusQueuePolicy_BusMessageCall = root::AZ::Internal::NullBusMessageCall;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BusHandlerCompareDefault {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterNode<Interface> {
            pub _base: root::AZStd::intrusive_multiset_node<root::AZ::EBusRouterNode<Interface>>,
            pub m_handler: *mut Interface,
            pub m_order: ::std::os::raw::c_int,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterPolicy {
            pub _address: u8,
        }
        pub type EBusRouterPolicy_RouterNode = u8;
        pub type EBusRouterPolicy_Container = u8;
        pub const EBusRouterPolicy_EventProcessingState_ContinueProcess:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListeners:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListenersAndRouters:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub type EBusRouterPolicy_EventProcessingState = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HphaSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SystemAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_isCustom: bool,
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_ownsOSAllocator: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_heap: root::AZ::SystemAllocator_Descriptor_Heap,
            pub m_allocationRecords: bool,
            pub m_stackRecordLevels: ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor_Heap {
            pub m_pageSize: ::std::os::raw::c_uint,
            pub m_poolPageSize: ::std::os::raw::c_uint,
            pub m_isPoolAllocations: bool,
            pub m_numFixedMemoryBlocks: ::std::os::raw::c_int,
            pub m_fixedMemoryBlocks: [*mut ::std::os::raw::c_void; 3usize],
            pub m_fixedMemoryBlocksByteSize: [usize; 3usize],
            pub m_subAllocator: *mut root::AZ::IAllocatorAllocate,
            pub m_systemChunkSize: usize,
        }
        pub const SystemAllocator_Descriptor_Heap_m_defaultPageSize: ::std::os::raw::c_int = 65536;
        pub const SystemAllocator_Descriptor_Heap_m_defaultPoolPageSize: ::std::os::raw::c_int =
            4096;
        pub const SystemAllocator_Descriptor_Heap_m_memoryBlockAlignment: ::std::os::raw::c_int =
            65536;
        pub const SystemAllocator_Descriptor_Heap_m_maxNumFixedBlocks: ::std::os::raw::c_int = 3;
        extern "C" {
            #[link_name = "\u{1}??0Heap@Descriptor@SystemAllocator@AZ@@QEAA@XZ"]
            pub fn SystemAllocator_Descriptor_Heap_Heap(
                this: *mut root::AZ::SystemAllocator_Descriptor_Heap,
            );
        }
        impl SystemAllocator_Descriptor_Heap {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SystemAllocator_Descriptor_Heap_Heap(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??0Descriptor@SystemAllocator@AZ@@QEAA@XZ"]
            pub fn SystemAllocator_Descriptor_Descriptor(
                this: *mut root::AZ::SystemAllocator_Descriptor,
            );
        }
        impl SystemAllocator_Descriptor {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SystemAllocator_Descriptor_Descriptor(&mut __bindgen_tmp);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_TYPEINFO_Enable(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Name@SystemAllocator@AZ@@SAPEBDXZ"]
            pub fn SystemAllocator_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Uuid@SystemAllocator@AZ@@SAAEBUUuid@2@XZ"]
            pub fn SystemAllocator_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
        }
        extern "C" {
            #[link_name = "\u{1}?Create@SystemAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn SystemAllocator_Create(
                this: *mut root::AZ::SystemAllocator,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_Destroy(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@QEAA@XZ"]
            pub fn SystemAllocator_SystemAllocator(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn SystemAllocator_SystemAllocator1(
                this: *mut root::AZ::SystemAllocator,
                arg1: *const root::AZ::SystemAllocator,
            );
        }
        impl SystemAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                SystemAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                SystemAllocator_TYPEINFO_Name()
            }
            #[inline]
            pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                SystemAllocator_TYPEINFO_Uuid()
            }
            #[inline]
            pub unsafe fn Create(
                &mut self,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool {
                SystemAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                SystemAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SystemAllocator_SystemAllocator(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::SystemAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                SystemAllocator_SystemAllocator1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DSystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_SystemAllocator_destructor(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?GetName@SystemAllocator@AZ@@UEBAPEBDXZ"]
            pub fn SystemAllocator_GetName(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?GetDescription@SystemAllocator@AZ@@UEBAPEBDXZ"]
            pub fn SystemAllocator_GetDescription(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@SystemAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn SystemAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@SystemAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn SystemAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ReAllocate@SystemAllocator@AZ@@UEAAPEAXPEAX_K1@Z"]
            pub fn SystemAllocator_ReAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
                newAlignment: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?Resize@SystemAllocator@AZ@@UEAA_KPEAX_K@Z"]
            pub fn SystemAllocator_Resize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?AllocationSize@SystemAllocator@AZ@@UEAA_KPEAX@Z"]
            pub fn SystemAllocator_AllocationSize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GarbageCollect@SystemAllocator@AZ@@UEAAXXZ"]
            pub fn SystemAllocator_GarbageCollect(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?NumAllocatedBytes@SystemAllocator@AZ@@UEBA_KXZ"]
            pub fn SystemAllocator_NumAllocatedBytes(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?Capacity@SystemAllocator@AZ@@UEBA_KXZ"]
            pub fn SystemAllocator_Capacity(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetMaxAllocationSize@SystemAllocator@AZ@@UEBA_KXZ"]
            pub fn SystemAllocator_GetMaxAllocationSize(
                this: *mut ::std::os::raw::c_void,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetUnAllocatedMemory@SystemAllocator@AZ@@UEBA_K_N@Z"]
            pub fn SystemAllocator_GetUnAllocatedMemory(
                this: *mut ::std::os::raw::c_void,
                isPrint: bool,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSubAllocator@SystemAllocator@AZ@@UEAAPEAVIAllocatorAllocate@2@XZ"]
            pub fn SystemAllocator_GetSubAllocator(
                this: *mut ::std::os::raw::c_void,
            ) -> *mut root::AZ::IAllocatorAllocate;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullMutex {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?lock@NullMutex@AZ@@QEAAXXZ"]
            pub fn NullMutex_lock(this: *mut root::AZ::NullMutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@NullMutex@AZ@@QEAA_NXZ"]
            pub fn NullMutex_try_lock(this: *mut root::AZ::NullMutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@NullMutex@AZ@@QEAAXXZ"]
            pub fn NullMutex_unlock(this: *mut root::AZ::NullMutex);
        }
        impl NullMutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                NullMutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                NullMutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                NullMutex_unlock(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusId {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}??0NullBusId@AZ@@QEAA@XZ"]
            pub fn NullBusId_NullBusId(this: *mut root::AZ::NullBusId);
        }
        extern "C" {
            #[link_name = "\u{1}??0NullBusId@AZ@@QEAA@H@Z"]
            pub fn NullBusId_NullBusId1(
                this: *mut root::AZ::NullBusId,
                arg1: ::std::os::raw::c_int,
            );
        }
        impl NullBusId {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                NullBusId_NullBusId(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(arg1: ::std::os::raw::c_int) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                NullBusId_NullBusId1(&mut __bindgen_tmp, arg1);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusIdCompare {
            _unused: [u8; 0],
        }
        pub mod BusInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusImplTraits {
                pub _address: u8,
            }
            pub type EBusImplTraits_Traits<BusTraits> = BusTraits;
            pub type EBusImplTraits_AllocatorType = [u8; 0usize];
            pub type EBusImplTraits_InterfaceType<Interface> = Interface;
            pub type EBusImplTraits_Events<Interface> = Interface;
            pub type EBusImplTraits_BusIdType = [u8; 0usize];
            pub type EBusImplTraits_BusIdOrderCompare = [u8; 0usize];
            pub type EBusImplTraits_MutexType = [u8; 0usize];
            pub type EBusImplTraits_BusesContainer = u8;
            pub type EBusImplTraits_EventQueueMutexType = [u8; 0usize];
            pub type EBusImplTraits_BusPtr = root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            pub type EBusImplTraits_HandlerNode =
                root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventer {
                pub _address: u8,
            }
            pub type EBusEventer_BusIdType = [u8; 0usize];
            pub type EBusEventer_BusPtr = [u8; 0usize];
            pub type EBusEventer_MultiHandler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventEnumerator {
                pub _address: u8,
            }
            pub type EBusEventEnumerator_BusIdType = [u8; 0usize];
            pub type EBusEventEnumerator_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcaster {
                pub _address: u8,
            }
            pub type EBusBroadcaster_Handler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNullQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventQueue {
                pub _address: u8,
            }
            pub type EBusEventQueue_BusIdType = [u8; 0usize];
            pub type EBusEventQueue_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastEnumerator {
                pub _address: u8,
            }
            pub type EventDispatcher = [u8; 0usize];
            #[repr(C)]
            pub struct EBusImpl {
                pub _address: u8,
            }
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type ArgumentValidatorHelper_is_non_const_lvalue_reference = u8;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusReduceResult<T, Aggregator> {
            pub value: T,
            pub unary: Aggregator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Aggregator>>,
        }
        pub type EBusArithmericResult<T, Arithmetic> = root::AZ::EBusReduceResult<T, Arithmetic>;
        pub type EBusLogicalResult<T, Operator> = root::AZ::EBusReduceResult<T, Operator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusAggregateResults {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusTraits {
            pub _address: u8,
        }
        pub type EBusTraits_AllocatorType = root::AZStd::allocator;
        pub type EBusTraits_BusIdType = root::AZ::NullBusId;
        pub type EBusTraits_BusIdOrderCompare = root::AZ::NullBusIdCompare;
        pub type EBusTraits_BusHandlerOrderCompare = root::AZ::BusHandlerCompareDefault;
        pub type EBusTraits_MutexType = root::AZ::NullMutex;
        pub type EBusTraits_EventQueueMutexType = root::AZ::NullMutex;
        pub type EBusTraits_ConnectionPolicy = root::AZ::EBusConnectionPolicy;
        pub type EBusTraits_StoragePolicy = root::AZ::EBusEnvironmentStoragePolicy;
        pub type EBusTraits_RouterPolicy = u8;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@EBusTraits@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static EBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@EBusTraits@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static EBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        pub const EBusTraits_EnableEventQueue: bool = false;
        pub const EBusTraits_EventQueueingActiveByDefault: bool = true;
        pub const EBusTraits_EnableQueuedReferences: bool = false;
        pub const EBusTraits_LocklessDispatch: bool = false;
        extern "C" {
            #[link_name = "\u{1}??_DEBusTraits@AZ@@IEAAXXZ"]
            pub fn EBusTraits_EBusTraits_destructor(this: *mut root::AZ::EBusTraits);
        }
        impl EBusTraits {
            #[inline]
            pub unsafe fn destruct(&mut self) {
                EBusTraits_EBusTraits_destructor(self)
            }
        }
        #[repr(C)]
        pub struct EBus {
            pub _address: u8,
        }
        pub type EBus_ImplTraits = root::AZ::BusInternal::EBusImplTraits;
        pub type EBus_BaseImpl = root::AZ::BusInternal::EBusImpl;
        pub type EBus_Traits = root::AZ::EBus_ImplTraits;
        pub type EBus_ThisType = root::AZ::EBus;
        pub type EBus_AllocatorType = root::AZ::EBus_ImplTraits;
        pub type EBus_InterfaceType = root::AZ::EBus_ImplTraits;
        pub type EBus_Events = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdOrderCompare = root::AZ::EBus_ImplTraits;
        pub type EBus_MutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusesContainer = root::AZ::EBus_ImplTraits;
        pub type EBus_EventQueueMutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusPtr = root::AZ::EBus_ImplTraits;
        pub type EBus_HandlerNode = root::AZ::EBus_ImplTraits;
        pub type EBus_QueuePolicy = u8;
        pub type EBus_ConnectionPolicy = root::AZ::EBus_Traits;
        pub type EBus_CallstackEntry = root::AZ::Internal::CallstackEntry;
        pub type EBus_Router = root::AZ::Internal::EBusRouter<root::AZ::EBus_ThisType>;
        pub type EBus_NestedVersionRouter =
            root::AZ::Internal::EBusNestedVersionRouter<root::AZ::EBus_ThisType>;
        pub type EBus_RouterPolicy = root::AZ::EBus_Traits;
        pub type EBus_RouterProcessingState = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_Context {
            pub _base: root::AZ::Internal::ContextBase,
            pub m_buses: root::AZ::EBus_BusesContainer,
            pub m_contextMutex: root::AZ::EBus_Context_ContextMutexType,
            pub m_queue: root::AZ::EBus_QueuePolicy,
            pub m_routing: root::AZ::EBus_RouterPolicy,
            pub m_callstackRoots: root::AZStd::unordered_map,
            pub s_callstack: root::AZ::EBus_Context_CallstackEntryStorageType,
            pub m_dispatches: root::AZStd::atomic_uint,
        }
        pub type EBus_Context_ContextMutexType = root::AZStd::conditional_t;
        pub type EBus_Context_DispatchLockGuard = root::AZStd::conditional_t;
        pub type EBus_Context_CallstackEntryBase = root::AZ::Internal::CallstackEntryBase;
        pub type EBus_Context_CallstackEntryRoot = root::AZ::Internal::CallstackEntryRoot;
        pub type EBus_Context_CallstackEntryStorageType = u8;
        pub type EBus_StoragePolicy = root::AZ::EBus_Traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_RouterCallstackEntry {
            pub _base: root::AZ::EBus_CallstackEntry,
            pub m_iterator: root::AZ::EBus_RouterCallstackEntry_Iterator,
            pub m_processingState: root::AZ::EBus_RouterProcessingState,
            pub m_isQueued: bool,
            pub m_isReverse: bool,
        }
        pub type EBus_RouterCallstackEntry_Iterator = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssetSerializer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssetEventHandler {
            _unused: [u8; 0],
        }
        pub mod Data {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEntry {
                _unused: [u8; 0],
            }
            pub type AssetType = root::AZ::Uuid;
            pub mod AssetInternal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
            }
            pub type AssetPtr = *mut root::AZ::Data::AssetData;
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetId {
                pub m_guid: root::AZ::Uuid,
                pub m_subId: root::AZ::u32,
                pub __bindgen_padding_0: [u32; 3usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Name@AssetId@Data@AZ@@SAPEBDXZ"]
                pub fn AssetId_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Uuid@AssetId@Data@AZ@@SAAEBUUuid@3@XZ"]
                pub fn AssetId_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?IsValid@AssetId@Data@AZ@@QEBA_NXZ"]
                pub fn AssetId_IsValid(this: *const root::AZ::Data::AssetId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?SetInvalid@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_SetInvalid(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?CreateString@AssetId@Data@AZ@@SA?AU123@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
                pub fn AssetId_CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@XZ"]
                pub fn AssetId_AssetId(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@AEBUUuid@2@I@Z"]
                pub fn AssetId_AssetId1(
                    this: *mut root::AZ::Data::AssetId,
                    guid: *const root::AZ::Uuid,
                    sudId: root::AZ::u32,
                );
            }
            impl AssetId {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetId_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                    AssetId_TYPEINFO_Name()
                }
                #[inline]
                pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                    AssetId_TYPEINFO_Uuid()
                }
                #[inline]
                pub unsafe fn IsValid(&self) -> bool {
                    AssetId_IsValid(self)
                }
                #[inline]
                pub unsafe fn SetInvalid(&mut self) {
                    AssetId_SetInvalid(self)
                }
                #[inline]
                pub unsafe fn CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId {
                    AssetId_CreateString(input)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    AssetId_AssetId(&mut __bindgen_tmp);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(guid: *const root::AZ::Uuid, sudId: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    AssetId_AssetId1(&mut __bindgen_tmp, guid, sudId);
                    __bindgen_tmp
                }
            }
            #[repr(C)]
            pub struct AssetData__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetData {
                pub vtable_: *const AssetData__bindgen_vtable,
                pub __bindgen_padding_0: [u32; 2usize],
                pub m_useCount: root::AZStd::atomic_int,
                pub m_status: root::AZStd::atomic_int,
                pub __bindgen_padding_1: u64,
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_creationToken: ::std::os::raw::c_int,
                pub __bindgen_padding_2: [u32; 3usize],
            }
            pub const AssetData_AssetStatus_NotLoaded: root::AZ::Data::AssetData_AssetStatus = 0;
            pub const AssetData_AssetStatus_Loading: root::AZ::Data::AssetData_AssetStatus = 1;
            pub const AssetData_AssetStatus_ReadyPreNotify: root::AZ::Data::AssetData_AssetStatus =
                2;
            pub const AssetData_AssetStatus_Ready: root::AZ::Data::AssetData_AssetStatus = 3;
            pub const AssetData_AssetStatus_Error: root::AZ::Data::AssetData_AssetStatus = 4;
            pub type AssetData_AssetStatus = i32;
            extern "C" {
                #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_Allocate@AssetData@Data@AZ@@SAPEAXXZ"]
                pub fn AssetData_AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_DeAllocate@AssetData@Data@AZ@@SAXPEAX@Z"]
                pub fn AssetData_AZ_CLASS_ALLOCATOR_DeAllocate(object: *mut ::std::os::raw::c_void);
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Name@AssetData@Data@AZ@@SAPEBDXZ"]
                pub fn AssetData_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Uuid@AssetData@Data@AZ@@SAAEBUUuid@3@XZ"]
                pub fn AssetData_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_RTTI_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Type@AssetData@Data@AZ@@SAAEBUUuid@3@XZ"]
                pub fn AssetData_RTTI_Type() -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_TypeName@AssetData@Data@AZ@@SAPEBDXZ"]
                pub fn AssetData_RTTI_TypeName() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_IsContainType@AssetData@Data@AZ@@SA_NAEBUUuid@3@@Z"]
                pub fn AssetData_RTTI_IsContainType(id: *const root::AZ::TypeId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_EnumHierarchy@AssetData@Data@AZ@@SAXP6AXAEBUUuid@3@PEAX@Z1@Z"]
                pub fn AssetData_RTTI_EnumHierarchy(
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Acquire@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Acquire(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?Release@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Release(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?IsReady@AssetData@Data@AZ@@QEBA_NXZ"]
                pub fn AssetData_IsReady(this: *const root::AZ::Data::AssetData) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsError@AssetData@Data@AZ@@QEBA_NXZ"]
                pub fn AssetData_IsError(this: *const root::AZ::Data::AssetData) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsLoading@AssetData@Data@AZ@@QEBA_NXZ"]
                pub fn AssetData_IsLoading(this: *const root::AZ::Data::AssetData) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetStatus@AssetData@Data@AZ@@QEBA?AW4AssetStatus@123@XZ"]
                pub fn AssetData_GetStatus(
                    this: *const root::AZ::Data::AssetData,
                ) -> root::AZ::Data::AssetData_AssetStatus;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@AssetData@Data@AZ@@QEBAAEBUAssetId@23@XZ"]
                pub fn AssetData_GetId(
                    this: *const root::AZ::Data::AssetData,
                ) -> *const root::AZ::Data::AssetId;
            }
            extern "C" {
                #[link_name = "\u{1}?GetType@AssetData@Data@AZ@@QEBAAEBUUuid@3@XZ"]
                pub fn AssetData_GetType(
                    this: *const root::AZ::Data::AssetData,
                ) -> *const root::AZ::Data::AssetType;
            }
            extern "C" {
                #[link_name = "\u{1}?GetUseCount@AssetData@Data@AZ@@QEBAHXZ"]
                pub fn AssetData_GetUseCount(
                    this: *const root::AZ::Data::AssetData,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetData@Data@AZ@@QEAA@AEBUAssetId@12@W4AssetStatus@012@@Z"]
                pub fn AssetData_AssetData(
                    this: *mut root::AZ::Data::AssetData,
                    assetId: *const root::AZ::Data::AssetId,
                    status: root::AZ::Data::AssetData_AssetStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetData@Data@AZ@@IEAA@AEBV012@@Z"]
                pub fn AssetData_AssetData1(
                    this: *mut root::AZ::Data::AssetData,
                    arg1: *const root::AZ::Data::AssetData,
                );
            }
            impl AssetData {
                #[inline]
                pub unsafe fn AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void {
                    AssetData_AZ_CLASS_ALLOCATOR_Allocate()
                }
                #[inline]
                pub unsafe fn AZ_CLASS_ALLOCATOR_DeAllocate(object: *mut ::std::os::raw::c_void) {
                    AssetData_AZ_CLASS_ALLOCATOR_DeAllocate(object)
                }
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetData_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                    AssetData_TYPEINFO_Name()
                }
                #[inline]
                pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                    AssetData_TYPEINFO_Uuid()
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetData_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Type() -> *const root::AZ::TypeId {
                    AssetData_RTTI_Type()
                }
                #[inline]
                pub unsafe fn RTTI_TypeName() -> *const ::std::os::raw::c_char {
                    AssetData_RTTI_TypeName()
                }
                #[inline]
                pub unsafe fn RTTI_IsContainType(id: *const root::AZ::TypeId) -> bool {
                    AssetData_RTTI_IsContainType(id)
                }
                #[inline]
                pub unsafe fn RTTI_EnumHierarchy(
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                ) {
                    AssetData_RTTI_EnumHierarchy(cb, userData)
                }
                #[inline]
                pub unsafe fn Acquire(&mut self) {
                    AssetData_Acquire(self)
                }
                #[inline]
                pub unsafe fn Release(&mut self) {
                    AssetData_Release(self)
                }
                #[inline]
                pub unsafe fn IsReady(&self) -> bool {
                    AssetData_IsReady(self)
                }
                #[inline]
                pub unsafe fn IsError(&self) -> bool {
                    AssetData_IsError(self)
                }
                #[inline]
                pub unsafe fn IsLoading(&self) -> bool {
                    AssetData_IsLoading(self)
                }
                #[inline]
                pub unsafe fn GetStatus(&self) -> root::AZ::Data::AssetData_AssetStatus {
                    AssetData_GetStatus(self)
                }
                #[inline]
                pub unsafe fn GetId(&self) -> *const root::AZ::Data::AssetId {
                    AssetData_GetId(self)
                }
                #[inline]
                pub unsafe fn GetType(&self) -> *const root::AZ::Data::AssetType {
                    AssetData_GetType(self)
                }
                #[inline]
                pub unsafe fn GetUseCount(&self) -> ::std::os::raw::c_int {
                    AssetData_GetUseCount(self)
                }
                #[inline]
                pub unsafe fn new(
                    assetId: *const root::AZ::Data::AssetId,
                    status: root::AZ::Data::AssetData_AssetStatus,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    AssetData_AssetData(&mut __bindgen_tmp, assetId, status);
                    __bindgen_tmp
                }
                #[inline]
                pub unsafe fn new1(arg1: *const root::AZ::Data::AssetData) -> Self {
                    let mut __bindgen_tmp = ::std::mem::uninitialized();
                    AssetData_AssetData1(&mut __bindgen_tmp, arg1);
                    __bindgen_tmp
                }
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_GetType@AssetData@Data@AZ@@UEBAAEBUUuid@3@XZ"]
                pub fn AssetData_RTTI_GetType(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_GetTypeName@AssetData@Data@AZ@@UEBAPEBDXZ"]
                pub fn AssetData_RTTI_GetTypeName(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_IsTypeOf@AssetData@Data@AZ@@UEBA_NAEBUUuid@3@@Z"]
                pub fn AssetData_RTTI_IsTypeOf(
                    this: *mut ::std::os::raw::c_void,
                    typeId: *const root::AZ::TypeId,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_EnumTypes@AssetData@Data@AZ@@UEAAXP6AXAEBUUuid@3@PEAX@Z1@Z"]
                pub fn AssetData_RTTI_EnumTypes(
                    this: *mut ::std::os::raw::c_void,
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_AddressOf@AssetData@Data@AZ@@UEBAPEBXAEBUUuid@3@@Z"]
                pub fn AssetData_RTTI_AddressOf(
                    this: *mut ::std::os::raw::c_void,
                    id: *const root::AZ::TypeId,
                ) -> *const ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_AddressOf@AssetData@Data@AZ@@UEAAPEAXAEBUUuid@3@@Z"]
                pub fn AssetData_RTTI_AddressOf1(
                    this: *mut ::std::os::raw::c_void,
                    id: *const root::AZ::TypeId,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}??_DAssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_AssetData_destructor(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?IsRegisterReadonlyAndShareable@AssetData@Data@AZ@@MEAA_NXZ"]
                pub fn AssetData_IsRegisterReadonlyAndShareable(
                    this: *mut ::std::os::raw::c_void,
                ) -> bool;
            }
            pub const AssetLoadBehavior_Default: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_PreLoad: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_QueueLoad: root::AZ::Data::AssetLoadBehavior = 1;
            pub const AssetLoadBehavior_NoLoad: root::AZ::Data::AssetLoadBehavior = 2;
            pub const AssetLoadBehavior_Count: root::AZ::Data::AssetLoadBehavior = 3;
            pub type AssetLoadBehavior = u8;
            pub type AssetFilterCB = [u64; 5usize];
            #[repr(C)]
            pub struct Asset {
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_assetData: *mut root::AZ::Data::AssetData,
                pub m_loadBehavior: root::AZ::Data::AssetLoadBehavior,
                pub m_assetHint: root::AZStd::string,
            }
            pub type Asset_ThisType = root::AZ::Data::Asset;
            #[repr(C)]
            pub struct AssetEvents__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetEvents {
                pub vtable_: *const AssetEvents__bindgen_vtable,
            }
            pub type AssetEvents_MutexType = root::AZStd::recursive_mutex;
            pub type AssetEvents_BusIdType = root::AZ::Data::AssetId;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEvents_AssetConnectionPolicy {
                pub _address: u8,
            }
            pub type AssetEvents_ConnectionPolicy =
                root::AZ::Data::AssetEvents_AssetConnectionPolicy;
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetEvents@Data@AZ@@2W4EBusAddressPolicy@3@B"]
                pub static AssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
            pub const AssetEvents_EnableEventQueue: bool = true;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Name@AssetEvents@Data@AZ@@SAPEBDXZ"]
                pub fn AssetEvents_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Uuid@AssetEvents@Data@AZ@@SAAEBUUuid@3@XZ"]
                pub fn AssetEvents_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_RTTI_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Type@AssetEvents@Data@AZ@@SAAEBUUuid@3@XZ"]
                pub fn AssetEvents_RTTI_Type() -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_TypeName@AssetEvents@Data@AZ@@SAPEBDXZ"]
                pub fn AssetEvents_RTTI_TypeName() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_IsContainType@AssetEvents@Data@AZ@@SA_NAEBUUuid@3@@Z"]
                pub fn AssetEvents_RTTI_IsContainType(id: *const root::AZ::TypeId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_EnumHierarchy@AssetEvents@Data@AZ@@SAXP6AXAEBUUuid@3@PEAX@Z1@Z"]
                pub fn AssetEvents_RTTI_EnumHierarchy(
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                );
            }
            impl AssetEvents {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetEvents_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                    AssetEvents_TYPEINFO_Name()
                }
                #[inline]
                pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                    AssetEvents_TYPEINFO_Uuid()
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetEvents_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Type() -> *const root::AZ::TypeId {
                    AssetEvents_RTTI_Type()
                }
                #[inline]
                pub unsafe fn RTTI_TypeName() -> *const ::std::os::raw::c_char {
                    AssetEvents_RTTI_TypeName()
                }
                #[inline]
                pub unsafe fn RTTI_IsContainType(id: *const root::AZ::TypeId) -> bool {
                    AssetEvents_RTTI_IsContainType(id)
                }
                #[inline]
                pub unsafe fn RTTI_EnumHierarchy(
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                ) {
                    AssetEvents_RTTI_EnumHierarchy(cb, userData)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_GetType@AssetEvents@Data@AZ@@UEBAAEBUUuid@3@XZ"]
                pub fn AssetEvents_RTTI_GetType(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_GetTypeName@AssetEvents@Data@AZ@@UEBAPEBDXZ"]
                pub fn AssetEvents_RTTI_GetTypeName(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_IsTypeOf@AssetEvents@Data@AZ@@UEBA_NAEBUUuid@3@@Z"]
                pub fn AssetEvents_RTTI_IsTypeOf(
                    this: *mut ::std::os::raw::c_void,
                    typeId: *const root::AZ::TypeId,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_EnumTypes@AssetEvents@Data@AZ@@UEAAXP6AXAEBUUuid@3@PEAX@Z1@Z"]
                pub fn AssetEvents_RTTI_EnumTypes(
                    this: *mut ::std::os::raw::c_void,
                    cb: root::AZ::RTTI_EnumCallback,
                    userData: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_AddressOf@AssetEvents@Data@AZ@@UEBAPEBXAEBUUuid@3@@Z"]
                pub fn AssetEvents_RTTI_AddressOf(
                    this: *mut ::std::os::raw::c_void,
                    id: *const root::AZ::TypeId,
                ) -> *const ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_AddressOf@AssetEvents@Data@AZ@@UEAAPEAXAEBUUuid@3@@Z"]
                pub fn AssetEvents_RTTI_AddressOf1(
                    this: *mut ::std::os::raw::c_void,
                    id: *const root::AZ::TypeId,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}??_DAssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_AssetEvents_destructor(this: *mut root::AZ::Data::AssetEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReady@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetEvents_OnAssetReady(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetMoved@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@PEAX@Z"]
                pub fn AssetEvents_OnAssetMoved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    oldDataPointer: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetPreReload@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetEvents_OnAssetPreReload(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReloaded@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetEvents_OnAssetReloaded(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReloadError@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetEvents_OnAssetReloadError(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetSaved@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@_N@Z"]
                pub fn AssetEvents_OnAssetSaved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    isSuccessful: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetUnloaded@AssetEvents@Data@AZ@@UEAAXUAssetId@23@UUuid@3@@Z"]
                pub fn AssetEvents_OnAssetUnloaded(
                    this: *mut ::std::os::raw::c_void,
                    assetId: root::AZ::Data::AssetId,
                    assetType: root::AZ::Data::AssetType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetError@AssetEvents@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetEvents_OnAssetError(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            pub type AssetBus = root::AZ::EBus;
            #[repr(C)]
            pub struct AssetBusCallbacks__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetBusCallbacks {
                pub vtable_: *const AssetBusCallbacks__bindgen_vtable,
                pub _base: [u64; 5usize],
                pub m_onAssetReadyCB: root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                pub m_onAssetMovedCB: root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                pub m_onAssetReloadedCB: root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                pub m_onAssetSavedCB: root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                pub m_onAssetUnloadedCB: root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                pub m_onAssetErrorCB: root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
            }
            pub type AssetBusCallbacks_AssetReadyCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetMovedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetReloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetSavedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetUnloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetErrorCB = [u64; 5usize];
            extern "C" {
                #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_Allocate@AssetBusCallbacks@Data@AZ@@SAPEAXXZ"]
                pub fn AssetBusCallbacks_AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?AZ_CLASS_ALLOCATOR_DeAllocate@AssetBusCallbacks@Data@AZ@@SAXPEAX@Z"]
                pub fn AssetBusCallbacks_AZ_CLASS_ALLOCATOR_DeAllocate(
                    object: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@5@0AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@5@AEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@5@0@Z"]
                pub fn AssetBusCallbacks_SetCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ClearCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXXZ"]
                pub fn AssetBusCallbacks_ClearCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReadyCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReadyCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetMovedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetMovedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetSavedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetSavedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetUnloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetUnloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetErrorCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetErrorCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            impl AssetBusCallbacks {
                #[inline]
                pub unsafe fn AZ_CLASS_ALLOCATOR_Allocate() -> *mut ::std::os::raw::c_void {
                    AssetBusCallbacks_AZ_CLASS_ALLOCATOR_Allocate()
                }
                #[inline]
                pub unsafe fn AZ_CLASS_ALLOCATOR_DeAllocate(object: *mut ::std::os::raw::c_void) {
                    AssetBusCallbacks_AZ_CLASS_ALLOCATOR_DeAllocate(object)
                }
                #[inline]
                pub unsafe fn SetCallbacks(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetCallbacks(
                        self, readyCB, movedCB, reloadedCB, savedCB, unloadedCB, errorCB,
                    )
                }
                #[inline]
                pub unsafe fn ClearCallbacks(&mut self) {
                    AssetBusCallbacks_ClearCallbacks(self)
                }
                #[inline]
                pub unsafe fn SetOnAssetReadyCallback(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReadyCallback(self, readyCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetMovedCallback(
                    &mut self,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetMovedCallback(self, movedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetReloadedCallback(
                    &mut self,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReloadedCallback(self, reloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetSavedCallback(
                    &mut self,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetSavedCallback(self, savedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetUnloadedCallback(
                    &mut self,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetUnloadedCallback(self, unloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetErrorCallback(
                    &mut self,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetOnAssetErrorCallback(self, errorCB)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReady@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReady(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetMoved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@PEAX@Z"]
                pub fn AssetBusCallbacks_OnAssetMoved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    oldDataPointer: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReloaded@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReloaded(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetSaved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@_N@Z"]
                pub fn AssetBusCallbacks_OnAssetSaved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    isSuccessful: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetUnloaded@AssetBusCallbacks@Data@AZ@@UEAAXUAssetId@23@UUuid@3@@Z"]
                pub fn AssetBusCallbacks_OnAssetUnloaded(
                    this: *mut ::std::os::raw::c_void,
                    assetId: root::AZ::Data::AssetId,
                    assetType: root::AZ::Data::AssetType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetError@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetError(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Ty> = _Ty;
        pub type integral_constant_type = u8;
        pub type bool_constant = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type conditional_type<_Ty2> = _Ty2;
        pub type conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Ty> = _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Ty> = _Ty;
        pub mod tr1 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Change_sign {
            pub _address: u8,
        }
        pub type _Change_sign__Signed = root::std::conditional_t;
        pub type _Change_sign__Unsigned = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = root::std::_Change_sign;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Replace_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_element_type {
            pub _address: u8,
        }
        pub type _Get_element_type_type = root::std::_Get_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_ptr_difference_type {
            pub _address: u8,
        }
        pub type _Get_ptr_difference_type_type = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_rebind_alias {
            pub _address: u8,
        }
        pub type _Get_rebind_alias_type = root::std::_Replace_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits_element_type = root::std::_Get_element_type;
        pub type pointer_traits_pointer<_Ty> = _Ty;
        pub type pointer_traits_difference_type = root::std::_Get_ptr_difference_type;
        pub type pointer_traits_rebind = root::std::_Get_rebind_alias;
        pub type pointer_traits__Reftype = root::std::conditional_t;
        pub const memory_order_memory_order_relaxed: root::std::memory_order = 0;
        pub const memory_order_memory_order_consume: root::std::memory_order = 1;
        pub const memory_order_memory_order_acquire: root::std::memory_order = 2;
        pub const memory_order_memory_order_release: root::std::memory_order = 3;
        pub const memory_order_memory_order_acq_rel: root::std::memory_order = 4;
        pub const memory_order_memory_order_seq_cst: root::std::memory_order = 5;
        pub type memory_order = i32;
        pub type _Uint1_t = ::std::os::raw::c_uchar;
        pub type _Atomic_impl__My_int = root::std::_Uint1_t;
        extern "C" {
            #[link_name = "\u{1}_Is_lock_free"]
            pub fn _Atomic_impl__Is_lock_free(this: *const u8) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_Store"]
            pub fn _Atomic_impl__Store(
                this: *mut u8,
                _Tgt: *mut ::std::os::raw::c_void,
                _Src: *const ::std::os::raw::c_void,
                _Order: root::std::memory_order,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_Load"]
            pub fn _Atomic_impl__Load(
                this: *const u8,
                _Tgt: *mut ::std::os::raw::c_void,
                _Src: *const ::std::os::raw::c_void,
                _Order: root::std::memory_order,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_Exchange"]
            pub fn _Atomic_impl__Exchange(
                this: *mut u8,
                _Left: *mut ::std::os::raw::c_void,
                _Right: *mut ::std::os::raw::c_void,
                _Order: root::std::memory_order,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_Compare_exchange_weak"]
            pub fn _Atomic_impl__Compare_exchange_weak(
                this: *mut u8,
                _Tgt: *mut ::std::os::raw::c_void,
                _Exp: *mut ::std::os::raw::c_void,
                _Value: *const ::std::os::raw::c_void,
                _Order1: root::std::memory_order,
                _Order2: root::std::memory_order,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_Compare_exchange_strong"]
            pub fn _Atomic_impl__Compare_exchange_strong(
                this: *mut u8,
                _Tgt: *mut ::std::os::raw::c_void,
                _Exp: *mut ::std::os::raw::c_void,
                _Value: *const ::std::os::raw::c_void,
                _Order1: root::std::memory_order,
                _Order2: root::std::memory_order,
            ) -> bool;
        }
        pub type _Atomic_base__Mybase = u8;
        pub type _Atomic_base__My_int = root::std::_Atomic_base__Mybase;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic__My_base = u8;
        pub type atomic_value_type<_Ty> = _Ty;
    }
    pub mod AZStd {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type sys_time_t = root::AZ::s64;
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Copy, Clone)]
            pub union aligned_storage__bindgen_ty_1 {
                pub _bindgen_opaque_blob: u64,
            }
            pub type OptionalMoveAssignBase_base = u8;
            pub type OptionalSFINAECtorBase_t = u8;
            pub type OptionalSFINAEAssignBase_t = u8;
        }
        pub type aligned_storage_type = u8;
        pub mod Utils {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type if_c_type<T1> = T1;
        }
        pub type conditional_type<T2> = T2;
        pub type conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<T1, T2> {
            pub first: T1,
            pub second: T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T2>>,
        }
        pub type pair_this_type<T1, T2> = root::AZStd::pair<T1, T2>;
        pub type pair_first_type<T1> = T1;
        pub type pair_second_type<T2> = T2;
        pub type pair_TT1 = root::std::remove_reference;
        pub type pair_TT2 = root::std::remove_reference;
        pub type native_mutex_data_type = [u64; 5usize];
        pub type native_recursive_mutex_data_type = root::AZStd::native_mutex_data_type;
        pub type native_recursive_mutex_handle_type = *mut root::CRITICAL_SECTION;
        pub type native_thread_id_type = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_id {
            pub m_id: root::AZStd::native_thread_id_type,
        }
        extern "C" {
            #[link_name = "\u{1}??0thread_id@AZStd@@QEAA@XZ"]
            pub fn thread_id_thread_id(this: *mut root::AZStd::thread_id);
        }
        extern "C" {
            #[link_name = "\u{1}??0thread_id@AZStd@@QEAA@I@Z"]
            pub fn thread_id_thread_id1(
                this: *mut root::AZStd::thread_id,
                threadId: root::AZStd::native_thread_id_type,
            );
        }
        impl thread_id {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                thread_id_thread_id(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(threadId: root::AZStd::native_thread_id_type) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                thread_id_thread_id1(&mut __bindgen_tmp, threadId);
                __bindgen_tmp
            }
        }
        pub type atomic_int = root::std::atomic;
        pub type atomic_uint = root::std::atomic;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_value_type<T> = T;
        pub type iterator_difference_type<Distance> = Distance;
        pub type iterator_pointer<Pointer> = Pointer;
        pub type iterator_reference<Reference> = Reference;
        pub type iterator_iterator_category<Category> = Category;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        pub type iterator_traits_iterator_category = [u8; 0usize];
        pub type iterator_traits_value_type = [u8; 0usize];
        pub type iterator_traits_difference_type = [u8; 0usize];
        pub type iterator_traits_pointer = [u8; 0usize];
        pub type iterator_traits_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<Iterator> {
            pub m_current: Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub type reverse_iterator_this_type<Iterator> = root::AZStd::reverse_iterator<Iterator>;
        pub type reverse_iterator_iterator_type<Iterator> = Iterator;
        pub type reverse_iterator_reference = root::AZStd::iterator_traits;
        pub type reverse_iterator_pointer = root::AZStd::iterator_traits;
        pub type reverse_iterator_difference_type = root::AZStd::iterator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<Element> {
            pub m_begin: root::AZStd::basic_string_view_const_pointer<Element>,
            pub m_end: root::AZStd::basic_string_view_const_pointer<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type basic_string_view_traits_type<Traits> = Traits;
        pub type basic_string_view_value_type<Element> = Element;
        pub type basic_string_view_pointer<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_pointer<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reference<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_reference<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        pub type basic_string_view_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_iterator<Element>>;
        pub type basic_string_view_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_const_iterator<Element>>;
        pub type string_view = root::AZStd::basic_string_view<::std::os::raw::c_char>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct monostate {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_allow_memory_leaks = root::std::false_type;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@allocator@AZStd@@QEAAXXZ"]
            pub fn allocator_TYPEINFO_Enable(this: *mut root::AZStd::allocator);
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Name@allocator@AZStd@@SAPEBDXZ"]
            pub fn allocator_TYPEINFO_Name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Uuid@allocator@AZStd@@SAAEBUUuid@AZ@@XZ"]
            pub fn allocator_TYPEINFO_Uuid() -> *const root::AZ::TypeId;
        }
        extern "C" {
            #[link_name = "\u{1}?get_name@allocator@AZStd@@QEBAPEBDXZ"]
            pub fn allocator_get_name(
                this: *const root::AZStd::allocator,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}?set_name@allocator@AZStd@@QEAAXPEBD@Z"]
            pub fn allocator_set_name(
                this: *mut root::AZStd::allocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?allocate@allocator@AZStd@@QEAAPEAX_K0H@Z"]
            pub fn allocator_allocate(
                this: *mut root::AZStd::allocator,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@allocator@AZStd@@QEAAXPEAX_K1@Z"]
            pub fn allocator_deallocate(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?resize@allocator@AZStd@@QEAA_KPEAX_K@Z"]
            pub fn allocator_resize(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_max_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_max_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_allocated_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_allocated_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?is_lock_free@allocator@AZStd@@QEAA_NXZ"]
            pub fn allocator_is_lock_free(this: *mut root::AZStd::allocator) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?is_stale_read_allowed@allocator@AZStd@@QEAA_NXZ"]
            pub fn allocator_is_stale_read_allowed(this: *mut root::AZStd::allocator) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?is_delayed_recycling@allocator@AZStd@@QEAA_NXZ"]
            pub fn allocator_is_delayed_recycling(this: *mut root::AZStd::allocator) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0allocator@AZStd@@QEAA@PEBD@Z"]
            pub fn allocator_allocator(
                this: *mut root::AZStd::allocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0allocator@AZStd@@QEAA@AEBV01@@Z"]
            pub fn allocator_allocator1(
                this: *mut root::AZStd::allocator,
                rhs: *const root::AZStd::allocator,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0allocator@AZStd@@QEAA@AEBV01@PEBD@Z"]
            pub fn allocator_allocator2(
                this: *mut root::AZStd::allocator,
                rhs: *const root::AZStd::allocator,
                name: *const ::std::os::raw::c_char,
            );
        }
        impl allocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                allocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn TYPEINFO_Name() -> *const ::std::os::raw::c_char {
                allocator_TYPEINFO_Name()
            }
            #[inline]
            pub unsafe fn TYPEINFO_Uuid() -> *const root::AZ::TypeId {
                allocator_TYPEINFO_Uuid()
            }
            #[inline]
            pub unsafe fn get_name(&self) -> *const ::std::os::raw::c_char {
                allocator_get_name(self)
            }
            #[inline]
            pub unsafe fn set_name(&mut self, name: *const ::std::os::raw::c_char) {
                allocator_set_name(self, name)
            }
            #[inline]
            pub unsafe fn allocate(
                &mut self,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type {
                allocator_allocate(self, byteSize, alignment, flags)
            }
            #[inline]
            pub unsafe fn deallocate(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            ) {
                allocator_deallocate(self, ptr, byteSize, alignment)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type {
                allocator_resize(self, ptr, newSize)
            }
            #[inline]
            pub unsafe fn get_max_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_max_size(self)
            }
            #[inline]
            pub unsafe fn get_allocated_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_allocated_size(self)
            }
            #[inline]
            pub unsafe fn is_lock_free(&mut self) -> bool {
                allocator_is_lock_free(self)
            }
            #[inline]
            pub unsafe fn is_stale_read_allowed(&mut self) -> bool {
                allocator_is_stale_read_allowed(self)
            }
            #[inline]
            pub unsafe fn is_delayed_recycling(&mut self) -> bool {
                allocator_is_delayed_recycling(self)
            }
            #[inline]
            pub unsafe fn new(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                allocator_allocator(&mut __bindgen_tmp, name);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(rhs: *const root::AZStd::allocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                allocator_allocator1(&mut __bindgen_tmp, rhs);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new2(
                rhs: *const root::AZStd::allocator,
                name: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                allocator_allocator2(&mut __bindgen_tmp, rhs, name);
                __bindgen_tmp
            }
        }
        pub type micro = u8;
        extern "C" {
            #[link_name = "\u{1}test1"]
            pub static mut ratio_test1: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}test2"]
            pub static mut ratio_test2: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}m_na"]
            pub static ratio_m_na: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_da"]
            pub static ratio_m_da: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_s"]
            pub static ratio_m_s: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_gcd"]
            pub static ratio_m_gcd: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::AZ::s64;
        }
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct duration<Rep> {
                pub m_rep: root::AZStd::chrono::duration_rep<Rep>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Rep>>,
            }
            pub type duration_rep<Rep> = Rep;
            pub type duration_period<Period> = Period;
            pub type microseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct time_point<Duration> {
                pub m_d: root::AZStd::chrono::time_point_duration<Duration>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Duration>>,
            }
            pub type time_point_clock<Clock> = Clock;
            pub type time_point_duration<Duration> = Duration;
            pub type time_point_rep = [u8; 0usize];
            pub type time_point_period = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct system_clock {
                pub _address: u8,
            }
            pub type system_clock_duration = root::AZStd::chrono::microseconds;
            pub type system_clock_rep = root::rep;
            pub type system_clock_period = u8;
            pub type system_clock_time_point = root::AZStd::chrono::time_point<
                root::AZStd::chrono::duration<::std::os::raw::c_longlong>,
            >;
            pub const system_clock_is_monotonic: bool = true;
            extern "C" {
                #[link_name = "\u{1}?now@system_clock@chrono@AZStd@@SA?AV?$time_point@Vsystem_clock@chrono@AZStd@@V?$duration@_JV?$ratio@$00$0PECEA@@AZStd@@@23@@23@XZ"]
                pub fn system_clock_now() -> root::AZStd::chrono::system_clock_time_point;
            }
            impl system_clock {
                #[inline]
                pub unsafe fn now() -> root::AZStd::chrono::system_clock_time_point {
                    system_clock_now()
                }
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntrusivePtrCountPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct intrusive_ptr<T> {
            pub px: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_ptr_this_type<T> = root::AZStd::intrusive_ptr<T>;
        pub type intrusive_ptr_CountPolicy = root::AZStd::IntrusivePtrCountPolicy;
        pub type intrusive_ptr_element_type<T> = T;
        pub type intrusive_ptr_value_type<T> = T;
        pub type intrusive_ptr_unspecified_bool_type<T> = *mut *mut T;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector<T, Allocator> {
            pub m_start: root::AZStd::vector_pointer<T>,
            pub m_last: root::AZStd::vector_pointer<T>,
            pub m_end: root::AZStd::vector_pointer<T>,
            pub m_allocator: root::AZStd::vector_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub const vector_CONTAINER_VERSION: root::AZStd::vector__bindgen_ty_1 = 0;
        pub type vector__bindgen_ty_1 = i32;
        pub type vector_this_type<T, Allocator> = root::AZStd::vector<T, Allocator>;
        pub type vector_pointer<T> = *mut T;
        pub type vector_const_pointer<T> = *const T;
        pub type vector_reference<T> = *mut T;
        pub type vector_const_reference<T> = *const T;
        pub type vector_difference_type = [u8; 0usize];
        pub type vector_size_type = [u8; 0usize];
        pub type vector_iterator_impl<T> = root::AZStd::vector_pointer<T>;
        pub type vector_const_iterator_impl<T> = root::AZStd::vector_const_pointer<T>;
        pub type vector_iterator<T> = root::AZStd::vector_iterator_impl<T>;
        pub type vector_const_iterator<T> = root::AZStd::vector_const_iterator_impl<T>;
        pub type vector_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_iterator<T>>;
        pub type vector_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_const_iterator<T>>;
        pub type vector_value_type<T> = T;
        pub type vector_allocator_type<Allocator> = Allocator;
        pub type vector_node_type<T> = root::AZStd::vector_value_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_node<T> {
            pub m_children: [*mut T; 2usize],
            pub m_neighbours: [*mut T; 2usize],
            pub m_parentColorSide: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_multiset_node_ColorType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_SideType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_this_type<T> = root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_node_node_ptr_type<T> = *mut T;
        pub const intrusive_multiset_node_Bits_BIT_COLOR:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_PARENT_SIDE:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_MASK: root::AZStd::intrusive_multiset_node_Bits =
            0;
        pub type intrusive_multiset_node_Bits = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct recursive_mutex {
            pub m_mutex: root::AZStd::native_recursive_mutex_data_type,
        }
        pub type recursive_mutex_native_handle_type =
            root::AZStd::native_recursive_mutex_handle_type;
        extern "C" {
            #[link_name = "\u{1}?lock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_lock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@recursive_mutex@AZStd@@QEAA_NXZ"]
            pub fn recursive_mutex_try_lock(this: *mut root::AZStd::recursive_mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_unlock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@recursive_mutex@AZStd@@QEAAPEAU_RTL_CRITICAL_SECTION@@XZ"]
            pub fn recursive_mutex_native_handle(
                this: *mut root::AZStd::recursive_mutex,
            ) -> root::AZStd::recursive_mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@XZ"]
            pub fn recursive_mutex_recursive_mutex(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@PEBD@Z"]
            pub fn recursive_mutex_recursive_mutex1(
                this: *mut root::AZStd::recursive_mutex,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_Drecursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_recursive_mutex_destructor(
                this: *mut root::AZStd::recursive_mutex,
            );
        }
        impl recursive_mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                recursive_mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                recursive_mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                recursive_mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(
                &mut self,
            ) -> root::AZStd::recursive_mutex_native_handle_type {
                recursive_mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                recursive_mutex_recursive_mutex(&mut __bindgen_tmp);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn new1(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                recursive_mutex_recursive_mutex1(&mut __bindgen_tmp, name);
                __bindgen_tmp
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                recursive_mutex_recursive_mutex_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct spin_mutex {
            pub m_flag: root::std::atomic,
        }
        extern "C" {
            #[link_name = "\u{1}?lock@spin_mutex@AZStd@@QEAAXXZ"]
            pub fn spin_mutex_lock(this: *mut root::AZStd::spin_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@spin_mutex@AZStd@@QEAA_NXZ"]
            pub fn spin_mutex_try_lock(this: *mut root::AZStd::spin_mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@spin_mutex@AZStd@@QEAAXXZ"]
            pub fn spin_mutex_unlock(this: *mut root::AZStd::spin_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0spin_mutex@AZStd@@QEAA@_N@Z"]
            pub fn spin_mutex_spin_mutex(this: *mut root::AZStd::spin_mutex, isLocked: bool);
        }
        impl spin_mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                spin_mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                spin_mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                spin_mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn new(isLocked: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::uninitialized();
                spin_mutex_spin_mutex(&mut __bindgen_tmp, isLocked);
                __bindgen_tmp
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional_base = u8;
        pub type optional_value_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_value_type {
            pub _address: u8,
        }
        pub type get_value_type_type = u8;
        pub type get_pointer_type_type<ValueType> = *mut ValueType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_pointer_type {
            pub _address: u8,
        }
        pub type get_const_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_void_pointer_type {
            pub _address: u8,
        }
        pub type get_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_void_pointer_type {
            pub _address: u8,
        }
        pub type get_const_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_difference_type {
            pub _address: u8,
        }
        pub type get_difference_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_size_type {
            pub _address: u8,
        }
        pub type get_size_type_type = root::std::make_unsigned;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_copy_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_copy_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_move_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_move_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_swap_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_swap_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_is_always_equal_type {
            pub _address: u8,
        }
        pub type get_is_always_equal_type_type = root::std::is_empty;
        pub type get_rebind_type_type<Allocator> = Allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<Alloc> = Alloc;
        pub type allocator_traits_value_type = root::AZStd::get_value_type;
        pub type allocator_traits_pointer = u8;
        pub type allocator_traits_const_pointer = root::AZStd::get_const_pointer_type;
        pub type allocator_traits_void_pointer = root::AZStd::get_void_pointer_type;
        pub type allocator_traits_const_void_pointer = root::AZStd::get_const_void_pointer_type;
        pub type allocator_traits_difference_type = root::AZStd::get_difference_type;
        pub type allocator_traits_size_type = root::AZStd::get_size_type;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::AZStd::get_propagate_on_container_move_assignment_type;
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::AZStd::get_propagate_on_container_copy_assignment_type;
        pub type allocator_traits_propagate_on_container_swap =
            root::AZStd::get_propagate_on_container_swap_type;
        pub type allocator_traits_is_always_equal = root::AZStd::get_is_always_equal_type;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_node_traits {
            pub _address: u8,
        }
        pub type map_node_traits_key_type<KeyType> = KeyType;
        pub type map_node_traits_mapped_type<MappedType> = MappedType;
        pub type map_node_traits_allocator_type<AllocatorType> = AllocatorType;
        pub type map_node_traits_node_type<NodeType> = NodeType;
        pub type map_node_traits_node_deleter_type<NodeDeleterType> = NodeDeleterType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct insert_return_type<Iterator, NodeType> {
            pub position: Iterator,
            pub inserted: bool,
            pub node: NodeType,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<NodeType>>,
        }
        #[repr(C)]
        pub struct node_handle {
            pub m_node: root::AZStd::node_handle_node_pointer_type,
            pub m_allocator: root::AZStd::optional,
        }
        pub type node_handle_allocator_type = [u8; 0usize];
        pub type node_handle_allocator_traits = root::AZStd::allocator_traits;
        pub type node_handle_node_pointer_type = *mut [u8; 0usize];
        pub type node_handle_node_allocator_type = [u8; 0usize];
        pub type node_handle_node_deleter_type = [u8; 0usize];
        pub type map_node_handle = root::AZStd::node_handle;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table {
            pub _address: u8,
        }
        pub type hash_table_this_type = u8;
        pub type hash_table_is_dynamic = u8;
        pub type hash_table_storage_type = u8;
        pub type hash_table_traits_type = u8;
        pub type hash_table_key_type = u8;
        pub type hash_table_key_eq = u8;
        pub type hash_table_hasher = u8;
        pub type hash_table_allocator_type = u8;
        pub type hash_table_list_type = u8;
        pub type hash_table_size_type = u8;
        pub type hash_table_difference_type = u8;
        pub type hash_table_pointer = u8;
        pub type hash_table_const_pointer = u8;
        pub type hash_table_reference = u8;
        pub type hash_table_const_reference = u8;
        pub type hash_table_iterator = u8;
        pub type hash_table_const_iterator = u8;
        pub type hash_table_reverse_iterator = u8;
        pub type hash_table_const_reverse_iterator = u8;
        pub type hash_table_value_type = u8;
        pub type hash_table_local_iterator = u8;
        pub type hash_table_const_local_iterator = u8;
        pub type hash_table_vector_value_type = u8;
        pub type hash_table_vector_type = u8;
        pub type hash_table_pair_iter_bool = u8;
        pub type hash_table_pair_iter_iter = u8;
        pub type hash_table_pair_citer_citer = u8;
        pub type hash_table_list_node_type = u8;
        pub type hash_table_vector_node_type = u8;
        pub type hash_table_node_deleter = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table_ConvertFromValue {
            pub _address: u8,
        }
        pub type hash_table_ConvertFromValue_key_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub const unordered_map_CONTAINER_VERSION: root::AZStd::unordered_map__bindgen_ty_1 = 0;
        pub type unordered_map__bindgen_ty_1 = i32;
        pub type unordered_map_this_type = root::AZStd::unordered_map;
        pub type unordered_map_base_type = u8;
        pub type unordered_map_traits_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_eq = root::AZStd::unordered_map_base_type;
        pub type unordered_map_hasher = root::AZStd::unordered_map_base_type;
        pub type unordered_map_mapped_type<MappedType> = MappedType;
        pub type unordered_map_allocator_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_size_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_difference_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_value_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pair_iter_bool = root::AZStd::unordered_map_base_type;
        pub type unordered_map_node_type = root::AZStd::map_node_handle;
        pub type unordered_map_insert_return_type = root::AZStd::insert_return_type<
            root::AZStd::unordered_map_iterator,
            root::AZStd::unordered_map_node_type,
        >;
        #[repr(C)]
        pub struct basic_string<Element, Allocator> {
            pub __bindgen_anon_1: root::AZStd::basic_string__bindgen_ty_3<Element>,
            pub m_size: root::AZStd::basic_string_size_type,
            pub m_capacity: root::AZStd::basic_string_size_type,
            pub m_allocator: root::AZStd::basic_string_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type basic_string_this_type<Element, Allocator> =
            root::AZStd::basic_string<Element, Allocator>;
        pub type basic_string_pointer<Element> = *mut Element;
        pub type basic_string_const_pointer<Element> = *const Element;
        pub type basic_string_reference<Element> = *mut Element;
        pub type basic_string_const_reference<Element> = *const Element;
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_iterator_impl<Element> = root::AZStd::basic_string_pointer<Element>;
        pub type basic_string_const_iterator_impl<Element> =
            root::AZStd::basic_string_const_pointer<Element>;
        pub type basic_string_iterator<Element> = root::AZStd::basic_string_iterator_impl<Element>;
        pub type basic_string_const_iterator<Element> =
            root::AZStd::basic_string_const_iterator_impl<Element>;
        pub type basic_string_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_iterator<Element>>;
        pub type basic_string_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_const_iterator<Element>>;
        pub type basic_string_value_type<Element> = Element;
        pub type basic_string_traits_type<Traits> = Traits;
        pub type basic_string_allocator_type<Allocator> = Allocator;
        pub type basic_string_node_type<Element> = root::AZStd::basic_string_value_type<Element>;
        pub const basic_string_SSO_BUF_SIZE: root::AZStd::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        pub const basic_string__ALLOC_MASK: root::AZStd::basic_string__bindgen_ty_2 = 0;
        pub type basic_string__bindgen_ty_2 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_3<Element> {
            pub m_buffer: *mut Element,
            pub m_data: root::AZStd::basic_string_pointer<Element>,
            _bindgen_union_align: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type string = root::AZStd::basic_string<::std::os::raw::c_char, root::AZStd::allocator>;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _RTL_CRITICAL_SECTION {
        _unused: [u8; 0],
    }
    pub type RTL_CRITICAL_SECTION = root::_RTL_CRITICAL_SECTION;
    pub type CRITICAL_SECTION = root::RTL_CRITICAL_SECTION;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _GUID {
        _unused: [u8; 0],
    }
    pub type GUID = root::_GUID;
    pub mod AzFramework {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct AssetCatalogEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetCatalogEvents {
            pub vtable_: *const AssetCatalogEvents__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetCatalogEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetCatalogEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?OnCatalogLoaded@AssetCatalogEvents@AzFramework@@UEAAXPEBD@Z"]
            pub fn AssetCatalogEvents_OnCatalogLoaded(
                this: *mut ::std::os::raw::c_void,
                arg1: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?OnCatalogAssetChanged@AssetCatalogEvents@AzFramework@@UEAAXAEBUAssetId@Data@AZ@@@Z"]
            pub fn AssetCatalogEvents_OnCatalogAssetChanged(
                this: *mut ::std::os::raw::c_void,
                arg1: *const root::AZ::Data::AssetId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?OnCatalogAssetAdded@AssetCatalogEvents@AzFramework@@UEAAXAEBUAssetId@Data@AZ@@@Z"]
            pub fn AssetCatalogEvents_OnCatalogAssetAdded(
                this: *mut ::std::os::raw::c_void,
                arg1: *const root::AZ::Data::AssetId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?OnCatalogAssetRemoved@AssetCatalogEvents@AzFramework@@UEAAXAEBUAssetId@Data@AZ@@@Z"]
            pub fn AssetCatalogEvents_OnCatalogAssetRemoved(
                this: *mut ::std::os::raw::c_void,
                arg1: *const root::AZ::Data::AssetId,
            );
        }
        pub type AssetCatalogEventBus = root::AZ::EBus;
        #[repr(C)]
        pub struct LegacyAssetEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct LegacyAssetEvents {
            pub vtable_: *const LegacyAssetEvents__bindgen_vtable,
        }
        pub type LegacyAssetEvents_BusIdType = root::AZ::u32;
        pub const LegacyAssetEvents_EnableEventQueue: bool = true;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@LegacyAssetEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static LegacyAssetEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@LegacyAssetEvents@AzFramework@@2W4EBusAddressPolicy@AZ@@B"]
            pub static LegacyAssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?OnFileChanged@LegacyAssetEvents@AzFramework@@UEAAXV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
            pub fn LegacyAssetEvents_OnFileChanged(
                this: *mut ::std::os::raw::c_void,
                arg1: root::AZStd::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?OnFileRemoved@LegacyAssetEvents@AzFramework@@UEAAXV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
            pub fn LegacyAssetEvents_OnFileRemoved(
                this: *mut ::std::os::raw::c_void,
                arg1: root::AZStd::string,
            );
        }
        pub type LegacyAssetEventBus = root::AZ::EBus;
    }
    pub type rep = ::std::os::raw::c_longlong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_22 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_23 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_24 {
        pub _address: u8,
    }
}
