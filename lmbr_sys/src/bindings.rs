/* automatically generated by rust-bindgen */

type F32 = f32;
type F64 = f64;
type U8 = u8;
type U16 = u16;
type U32 = u32;
type U64 = u64;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align> {
        storage: Storage,
        align: [Align; 0],
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub type f32 = crate::F32;
    pub type f64 = crate::F64;
    pub type u8 = crate::U8;
    pub type u16 = crate::U16;
    pub type u32 = crate::U32;
    pub type u64 = crate::U64;
    pub mod AZ {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type f32 = crate::F32;
        pub type f64 = crate::F64;
        pub type u8 = crate::U8;
        pub type u16 = crate::U16;
        pub type u32 = crate::U32;
        pub type u64 = crate::U64;
        pub mod Debug {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Trace {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?GetDefaultSystemWindow@Trace@Debug@AZ@@SAPEBDXZ"]
                pub fn Trace_GetDefaultSystemWindow() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?IsDebuggerPresent@Trace@Debug@AZ@@SA_NXZ"]
                pub fn Trace_IsDebuggerPresent() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?HandleExceptions@Trace@Debug@AZ@@SAX_N@Z"]
                pub fn Trace_HandleExceptions(isEnabled: bool);
            }
            extern "C" {
                #[link_name = "\u{1}?Break@Trace@Debug@AZ@@SAXXZ"]
                pub fn Trace_Break();
            }
            extern "C" {
                #[link_name = "\u{1}?Terminate@Trace@Debug@AZ@@SAXH@Z"]
                pub fn Trace_Terminate(exitCode: ::std::os::raw::c_int);
            }
            extern "C" {
                #[link_name = "\u{1}?Assert@Trace@Debug@AZ@@SAXPEBDH00ZZ"]
                pub fn Trace_Assert(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Error@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Error(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Warning@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Warning(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Printf@Trace@Debug@AZ@@SAXPEBD0ZZ"]
                pub fn Trace_Printf(
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Output@Trace@Debug@AZ@@SAXPEBD0@Z"]
                pub fn Trace_Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?PrintCallstack@Trace@Debug@AZ@@SAXPEBDIPEAX@Z"]
                pub fn Trace_PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?GetNativeExceptionInfo@Trace@Debug@AZ@@SAPEAXXZ"]
                pub fn Trace_GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void;
            }
            impl Trace {
                #[inline]
                pub unsafe fn GetDefaultSystemWindow() -> *const ::std::os::raw::c_char {
                    Trace_GetDefaultSystemWindow()
                }
                #[inline]
                pub unsafe fn IsDebuggerPresent() -> bool {
                    Trace_IsDebuggerPresent()
                }
                #[inline]
                pub unsafe fn HandleExceptions(isEnabled: bool) {
                    Trace_HandleExceptions(isEnabled)
                }
                #[inline]
                pub unsafe fn Break() {
                    Trace_Break()
                }
                #[inline]
                pub unsafe fn Terminate(exitCode: ::std::os::raw::c_int) {
                    Trace_Terminate(exitCode)
                }
                #[inline]
                pub unsafe fn Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                ) {
                    Trace_Output(window, message)
                }
                #[inline]
                pub unsafe fn PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                ) {
                    Trace_PrintCallstack(window, suppressCount, nativeContext)
                }
                #[inline]
                pub unsafe fn GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void {
                    Trace_GetNativeExceptionInfo()
                }
            }
            pub type ProfileCategoryPrimitiveType = root::AZ::u64;
            pub const ProfileCategory_Any: root::AZ::Debug::ProfileCategory = 0;
            pub const ProfileCategory_Renderer: root::AZ::Debug::ProfileCategory = 1;
            pub const ProfileCategory_ThreeDEngine: root::AZ::Debug::ProfileCategory = 2;
            pub const ProfileCategory_Particle: root::AZ::Debug::ProfileCategory = 3;
            pub const ProfileCategory_AI: root::AZ::Debug::ProfileCategory = 4;
            pub const ProfileCategory_Animation: root::AZ::Debug::ProfileCategory = 5;
            pub const ProfileCategory_Movie: root::AZ::Debug::ProfileCategory = 6;
            pub const ProfileCategory_Entity: root::AZ::Debug::ProfileCategory = 7;
            pub const ProfileCategory_Font: root::AZ::Debug::ProfileCategory = 8;
            pub const ProfileCategory_Network: root::AZ::Debug::ProfileCategory = 9;
            pub const ProfileCategory_Physics: root::AZ::Debug::ProfileCategory = 10;
            pub const ProfileCategory_Script: root::AZ::Debug::ProfileCategory = 11;
            pub const ProfileCategory_ScriptCFunc: root::AZ::Debug::ProfileCategory = 12;
            pub const ProfileCategory_Audio: root::AZ::Debug::ProfileCategory = 13;
            pub const ProfileCategory_Editor: root::AZ::Debug::ProfileCategory = 14;
            pub const ProfileCategory_System: root::AZ::Debug::ProfileCategory = 15;
            pub const ProfileCategory_Action: root::AZ::Debug::ProfileCategory = 16;
            pub const ProfileCategory_Game: root::AZ::Debug::ProfileCategory = 17;
            pub const ProfileCategory_Input: root::AZ::Debug::ProfileCategory = 18;
            pub const ProfileCategory_Sync: root::AZ::Debug::ProfileCategory = 19;
            pub const ProfileCategory_LegacyNetworkTrafficReserved:
                root::AZ::Debug::ProfileCategory = 20;
            pub const ProfileCategory_LegacyDeviceReserved: root::AZ::Debug::ProfileCategory = 21;
            pub const ProfileCategory_LegacyLast: root::AZ::Debug::ProfileCategory = 22;
            pub const ProfileCategory_AzCore: root::AZ::Debug::ProfileCategory = 23;
            pub const ProfileCategory_AzRender: root::AZ::Debug::ProfileCategory = 24;
            pub const ProfileCategory_AzFramework: root::AZ::Debug::ProfileCategory = 25;
            pub const ProfileCategory_AzToolsFramework: root::AZ::Debug::ProfileCategory = 26;
            pub const ProfileCategory_ScriptCanvas: root::AZ::Debug::ProfileCategory = 27;
            pub const ProfileCategory_FirstDetailedCategory: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_RendererDetailed: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_ThreeDEngineDetailed: root::AZ::Debug::ProfileCategory = 29;
            pub const ProfileCategory_JobManagerDetailed: root::AZ::Debug::ProfileCategory = 30;
            pub const ProfileCategory_FirstReservedCategory: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_MemoryReserved: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_Global: root::AZ::Debug::ProfileCategory = 32;
            pub const ProfileCategory_Count: root::AZ::Debug::ProfileCategory = 33;
            pub type ProfileCategory = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerThreadData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Profiler {
                pub m_data: *mut root::AZ::Debug::ProfilerData,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Profiler_Descriptor {
                pub _address: u8,
            }
            pub type Profiler_ReadProfileRegisterCB = root::AZStd::function;
            pub const Profiler_m_maxNumberOfThreads: ::std::os::raw::c_int = 32;
            pub const Profiler_m_maxNumberOfSystems: ::std::os::raw::c_int = 64;
            extern "C" {
                #[link_name = "\u{1}?s_instance@Profiler@Debug@AZ@@0PEAV123@EA"]
                pub static mut Profiler_s_instance: *mut root::AZ::Debug::Profiler;
            }
            extern "C" {
                #[link_name = "\u{1}?s_id@Profiler@Debug@AZ@@0_KA"]
                pub static mut Profiler_s_id: root::AZ::u64;
            }
            extern "C" {
                #[link_name = "\u{1}?s_useCount@Profiler@Debug@AZ@@0HA"]
                pub static mut Profiler_s_useCount: ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?Create@Profiler@Debug@AZ@@SA_NAEBUDescriptor@123@@Z"]
                pub fn Profiler_Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Destroy@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_Destroy();
            }
            extern "C" {
                #[link_name = "\u{1}?AddReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_AddReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ReleaseReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_ReleaseReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ActivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_ActivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?DeactivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_DeactivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NPEBD@Z"]
                pub fn Profiler_IsSystemActive(
                    this: *const root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NI@Z"]
                pub fn Profiler_IsSystemActive1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetNumberOfSystems@Profiler@Debug@AZ@@QEBAHXZ"]
                pub fn Profiler_GetNumberOfSystems(
                    this: *const root::AZ::Debug::Profiler,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDH@Z"]
                pub fn Profiler_GetSystemName(
                    this: *const root::AZ::Debug::Profiler,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDI@Z"]
                pub fn Profiler_GetSystemName1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?ReadRegisterValues@Profiler@Debug@AZ@@QEBAXAEBV?$function@$$A6A_NAEBVProfilerRegister@Debug@AZ@@AEBUthread_id@AZStd@@@Z@AZStd@@IPEBUthread_id@5@@Z"]
                pub fn Profiler_ReadRegisterValues(
                    this: *const root::AZ::Debug::Profiler,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ResetRegisters@Profiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_ResetRegisters(this: *mut root::AZ::Debug::Profiler);
            }
            extern "C" {
                #[link_name = "\u{1}?RemoveThreadData@Profiler@Debug@AZ@@QEAAXUthread_id@AZStd@@@Z"]
                pub fn Profiler_RemoveThreadData(
                    this: *mut root::AZ::Debug::Profiler,
                    id: root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??_DProfiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_Profiler_destructor(this: *mut root::AZ::Debug::Profiler);
            }
            impl Profiler {
                #[inline]
                pub unsafe fn Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool {
                    Profiler_Create(desc)
                }
                #[inline]
                pub unsafe fn Destroy() {
                    Profiler_Destroy()
                }
                #[inline]
                pub unsafe fn AddReference() {
                    Profiler_AddReference()
                }
                #[inline]
                pub unsafe fn ReleaseReference() {
                    Profiler_ReleaseReference()
                }
                #[inline]
                pub unsafe fn ActivateSystem(&mut self, systemName: *const ::std::os::raw::c_char) {
                    Profiler_ActivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn DeactivateSystem(
                    &mut self,
                    systemName: *const ::std::os::raw::c_char,
                ) {
                    Profiler_DeactivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive(
                    &self,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool {
                    Profiler_IsSystemActive(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive1(&self, systemId: root::AZ::u32) -> bool {
                    Profiler_IsSystemActive1(self, systemId)
                }
                #[inline]
                pub unsafe fn GetNumberOfSystems(&self) -> ::std::os::raw::c_int {
                    Profiler_GetNumberOfSystems(self)
                }
                #[inline]
                pub unsafe fn GetSystemName(
                    &self,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName(self, index)
                }
                #[inline]
                pub unsafe fn GetSystemName1(
                    &self,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName1(self, systemId)
                }
                #[inline]
                pub unsafe fn ReadRegisterValues(
                    &self,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                ) {
                    Profiler_ReadRegisterValues(self, callback, systemFilter, threadFilter)
                }
                #[inline]
                pub unsafe fn ResetRegisters(&mut self) {
                    Profiler_ResetRegisters(self)
                }
                #[inline]
                pub unsafe fn RemoveThreadData(&mut self, id: root::AZStd::thread_id) {
                    Profiler_RemoveThreadData(self, id)
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    Profiler_Profiler_destructor(self)
                }
            }
            #[repr(C)]
            pub struct ProfilerRegister {
                pub __bindgen_anon_1: root::AZ::Debug::ProfilerRegister__bindgen_ty_1,
                pub m_name: *const ::std::os::raw::c_char,
                pub m_function: *const ::std::os::raw::c_char,
                pub m_line: ::std::os::raw::c_int,
                pub m_systemId: root::AZ::u32,
                pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
                pub m_threadData: *mut root::AZ::Debug::ProfilerThreadData,
            }
            pub const ProfilerRegister_Type_PRT_TIME: root::AZ::Debug::ProfilerRegister_Type = 0;
            pub const ProfilerRegister_Type_PRT_VALUE: root::AZ::Debug::ProfilerRegister_Type = 1;
            pub type ProfilerRegister_Type = i32;
            #[repr(C)]
            pub struct ProfilerRegister_TimeData {
                pub m_time: root::AZ::u64,
                pub m_childrenTime: root::AZ::u64,
                pub m_calls: root::AZ::s64,
                pub m_childrenCalls: root::AZ::s64,
                pub m_lastParent: *mut root::AZ::Debug::ProfilerRegister,
            }
            extern "C" {
                #[link_name = "\u{1}?s_startStopOverheadPer1000Calls@TimeData@ProfilerRegister@Debug@AZ@@2V?$duration@_JV?$ratio@$00$0PECEA@@AZStd@@@chrono@AZStd@@A"]
                pub static mut ProfilerRegister_TimeData_s_startStopOverheadPer1000Calls:
                    root::AZStd::chrono::microseconds;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerRegister_ValuesData {
                pub m_value1: root::AZ::s64,
                pub m_value2: root::AZ::s64,
                pub m_value3: root::AZ::s64,
                pub m_value4: root::AZ::s64,
                pub m_value5: root::AZ::s64,
            }
            #[repr(C)]
            pub struct ProfilerRegister__bindgen_ty_1 {
                pub m_timeData:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_TimeData>,
                pub m_userValues:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_ValuesData>,
                pub bindgen_union_field: [u64; 5usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TimerCreateAndStart@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD0PEAVProfilerSection@23@0H@Z"]
                pub fn ProfilerRegister_TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?ValueCreate@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD00H@Z"]
                pub fn ProfilerRegister_ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?TimerStart@ProfilerRegister@Debug@AZ@@QEAAXPEAVProfilerSection@23@@Z"]
                pub fn ProfilerRegister_TimerStart(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    section: *mut root::AZ::Debug::ProfilerSection,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueSet(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueSet1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueSet2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueSet3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueSet4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueAdd(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueAdd1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueAdd2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueAdd3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueAdd4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            impl ProfilerRegister {
                #[inline]
                pub fn m_type(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
                }
                #[inline]
                pub fn set_m_type(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(0usize, 7u8, val as u64)
                    }
                }
                #[inline]
                pub fn m_isActive(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
                }
                #[inline]
                pub fn set_m_isActive(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(7usize, 1u8, val as u64)
                    }
                }
                #[inline]
                pub fn new_bitfield_1(
                    m_type: ::std::os::raw::c_uchar,
                    m_isActive: ::std::os::raw::c_uchar,
                ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                    let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                        Default::default();
                    __bindgen_bitfield_unit.set(0usize, 7u8, {
                        let m_type: u8 = unsafe { ::std::mem::transmute(m_type) };
                        m_type as u64
                    });
                    __bindgen_bitfield_unit.set(7usize, 1u8, {
                        let m_isActive: u8 = unsafe { ::std::mem::transmute(m_isActive) };
                        m_isActive as u64
                    });
                    __bindgen_bitfield_unit
                }
                #[inline]
                pub unsafe fn TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_TimerCreateAndStart(systemName, name, section, function, line)
                }
                #[inline]
                pub unsafe fn ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_ValueCreate(systemName, name, function, line)
                }
                #[inline]
                pub unsafe fn TimerStart(
                    &mut self,
                    section: *mut root::AZ::Debug::ProfilerSection,
                ) {
                    ProfilerRegister_TimerStart(self, section)
                }
                #[inline]
                pub unsafe fn ValueSet(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueSet(self, v1)
                }
                #[inline]
                pub unsafe fn ValueSet1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueSet2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueSet3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueSet4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet4(self, v1, v2, v3, v4, v5)
                }
                #[inline]
                pub unsafe fn ValueAdd(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueAdd(self, v1)
                }
                #[inline]
                pub unsafe fn ValueAdd1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueAdd2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueAdd3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueAdd4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd4(self, v1, v2, v3, v4, v5)
                }
            }
            #[repr(C)]
            pub struct ProfilerSection {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
                pub m_start: root::AZStd::chrono::system_clock_time_point,
                pub m_childTime: root::AZStd::chrono::microseconds,
                pub m_childCalls: ::std::os::raw::c_int,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocationRecords {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MemoryDriller {
                _unused: [u8; 0],
            }
        }
        pub const PlatformID_PLATFORM_WINDOWS_32: root::AZ::PlatformID = 0;
        pub const PlatformID_PLATFORM_WINDOWS_64: root::AZ::PlatformID = 1;
        pub const PlatformID_PLATFORM_LINUX_64: root::AZ::PlatformID = 2;
        pub const PlatformID_PLATFORM_ANDROID: root::AZ::PlatformID = 3;
        pub const PlatformID_PLATFORM_APPLE_IOS: root::AZ::PlatformID = 4;
        pub const PlatformID_PLATFORM_APPLE_OSX: root::AZ::PlatformID = 5;
        pub const PlatformID_PLATFORM_APPLE_TV: root::AZ::PlatformID = 6;
        pub const PlatformID_PLATFORM_ANDROID_64: root::AZ::PlatformID = 7;
        pub const PlatformID_PLATFORM_MAX: root::AZ::PlatformID = 8;
        pub type PlatformID = i32;
        extern "C" {
            #[link_name = "\u{1}?GetPlatformName@AZ@@YAPEBDW4PlatformID@1@@Z"]
            pub fn GetPlatformName(platform: root::AZ::PlatformID)
                -> *const ::std::os::raw::c_char;
        }
        pub type s8 = i8;
        pub type s16 = i16;
        pub type s32 = i32;
        pub type s64 = i64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct s128 {
            pub a: root::AZ::s64,
            pub b: root::AZ::s64,
        }
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct Uuid {
            pub data: [::std::os::raw::c_uchar; 16usize],
        }
        pub const Uuid_Variant_VAR_UNKNOWN: root::AZ::Uuid_Variant = -1;
        pub const Uuid_Variant_VAR_NCS: root::AZ::Uuid_Variant = 0;
        pub const Uuid_Variant_VAR_RFC_4122: root::AZ::Uuid_Variant = 2;
        pub const Uuid_Variant_VAR_MICROSOFT: root::AZ::Uuid_Variant = 6;
        pub const Uuid_Variant_VAR_RESERVED: root::AZ::Uuid_Variant = 7;
        pub type Uuid_Variant = i32;
        pub const Uuid_Version_VER_UNKNOWN: root::AZ::Uuid_Version = -1;
        pub const Uuid_Version_VER_TIME: root::AZ::Uuid_Version = 1;
        pub const Uuid_Version_VER_DCE: root::AZ::Uuid_Version = 2;
        pub const Uuid_Version_VER_NAME_MD5: root::AZ::Uuid_Version = 3;
        pub const Uuid_Version_VER_RANDOM: root::AZ::Uuid_Version = 4;
        pub const Uuid_Version_VER_NAME_SHA1: root::AZ::Uuid_Version = 5;
        pub type Uuid_Version = i32;
        pub type Uuid_iterator = *mut ::std::os::raw::c_uchar;
        pub type Uuid_const_iterator = *const ::std::os::raw::c_uchar;
        pub const Uuid_MaxStringBuffer: usize = 39;
        extern "C" {
            #[link_name = "\u{1}?CreateNull@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateNull() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateString@Uuid@AZ@@SA?AU12@PEBD_K@Z"]
            pub fn Uuid_CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateRandom@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateRandom() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateName@Uuid@AZ@@SA?AU12@PEBD@Z"]
            pub fn Uuid_CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateData@Uuid@AZ@@SA?AU12@PEBX_K@Z"]
            pub fn Uuid_CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?IsNull@Uuid@AZ@@QEBA_NXZ"]
            pub fn Uuid_IsNull(this: *const root::AZ::Uuid) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVariant@Uuid@AZ@@QEBA?AW4Variant@12@XZ"]
            pub fn Uuid_GetVariant(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Variant;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVersion@Uuid@AZ@@QEBA?AW4Version@12@XZ"]
            pub fn Uuid_GetVersion(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Version;
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@Uuid@AZ@@QEBAHPEADH_N1@Z"]
            pub fn Uuid_ToString(
                this: *const root::AZ::Uuid,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}??0Uuid@AZ@@QEAA@AEBU_GUID@@@Z"]
            pub fn Uuid_Uuid(this: *mut root::AZ::Uuid, guid: *const root::GUID);
        }
        impl Uuid {
            #[inline]
            pub unsafe fn CreateNull() -> root::AZ::Uuid {
                Uuid_CreateNull()
            }
            #[inline]
            pub unsafe fn CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateString(string, stringLength)
            }
            #[inline]
            pub unsafe fn CreateRandom() -> root::AZ::Uuid {
                Uuid_CreateRandom()
            }
            #[inline]
            pub unsafe fn CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid {
                Uuid_CreateName(name)
            }
            #[inline]
            pub unsafe fn CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateData(data, dataSize)
            }
            #[inline]
            pub unsafe fn IsNull(&self) -> bool {
                Uuid_IsNull(self)
            }
            #[inline]
            pub unsafe fn GetVariant(&self) -> root::AZ::Uuid_Variant {
                Uuid_GetVariant(self)
            }
            #[inline]
            pub unsafe fn GetVersion(&self) -> root::AZ::Uuid_Version {
                Uuid_GetVersion(self)
            }
            #[inline]
            pub unsafe fn ToString(
                &self,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int {
                Uuid_ToString(self, output, outputSize, isBrackets, isDashes)
            }
            #[inline]
            pub unsafe fn new(guid: *const root::GUID) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Uuid_Uuid(__bindgen_tmp.as_mut_ptr(), guid);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext {
            _unused: [u8; 0],
        }
        #[repr(C)]
        pub struct Crc32 {
            pub m_value: root::AZ::u32,
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBD@Z"]
            pub fn Crc32_Add(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBX_K_N@Z"]
            pub fn Crc32_Add1(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@Crc32@AZ@@SAXAEAVSerializeContext@2@@Z"]
            pub fn Crc32_Reflect(context: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Crc32@AZ@@IEAAXPEBX_K_N@Z"]
            pub fn Crc32_Set(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Combine@Crc32@AZ@@IEAAXI_K@Z"]
            pub fn Crc32_Combine(this: *mut root::AZ::Crc32, crc: root::AZ::u32, len: usize);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBD@Z"]
            pub fn Crc32_Crc32(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
            pub fn Crc32_Crc321(this: *mut root::AZ::Crc32, view: root::AZStd::string_view);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBX_K_N@Z"]
            pub fn Crc32_Crc322(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        impl Crc32 {
            #[inline]
            pub unsafe fn Add(&mut self, str: *const ::std::os::raw::c_char) {
                Crc32_Add(self, str)
            }
            #[inline]
            pub unsafe fn Add1(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Add1(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::SerializeContext) {
                Crc32_Reflect(context)
            }
            #[inline]
            pub unsafe fn Set(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Set(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Combine(&mut self, crc: root::AZ::u32, len: usize) {
                Crc32_Combine(self, crc, len)
            }
            #[inline]
            pub unsafe fn new(str: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc32(__bindgen_tmp.as_mut_ptr(), str);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(view: root::AZStd::string_view) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc321(__bindgen_tmp.as_mut_ptr(), view);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc322(__bindgen_tmp.as_mut_ptr(), data, size, forceLowerCase);
                __bindgen_tmp.assume_init()
            }
        }
        pub type TypeId = root::AZ::Uuid;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PointerRemovedTypeIdTag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CanonicalTypeIdTag {
            pub _address: u8,
        }
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type AZTypeInfoIntrusiveResultType_type = root::std::true_type;
            pub type HasAZTypeInfoIntrusive_Yes = ::std::os::raw::c_char;
            pub type HasAZTypeInfoIntrusive_No = ::std::os::raw::c_long;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoIntrusive_Helper {
                pub _address: u8,
            }
            pub type HasAZTypeInfoIntrusive_Helper_mfp =
                ::std::option::Option<unsafe extern "C" fn()>;
            pub type HasAZTypeInfoIntrusive_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoSpecialized {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfo {
                pub _address: u8,
            }
            pub type HasAZTypeInfo_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AggregateTypes {
                pub _address: u8,
            }
            pub type TypeIdHolder = root::AZ::TypeId;
            #[repr(C)]
            pub struct CallstackEntryBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryBase {
                pub vtable_: *const CallstackEntryBase__bindgen_vtable,
                pub m_busId: *const [u8; 0usize],
                pub m_prev: *mut root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryBase_BusType = root::AZ::EBus;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntry {
                pub _base: root::AZ::Internal::CallstackEntryBase,
                pub m_context: root::AZ::Internal::CallstackEntry_BusContextPtr,
                pub m_threadId: root::AZStd::native_thread_id_type,
            }
            pub type CallstackEntry_BusType = root::AZ::EBus;
            pub type CallstackEntry_BusContextPtr = *mut root::AZ::Internal::CallstackEntry_BusType;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryRoot {
                pub _base: root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryRoot_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct RegisterData {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EnvironmentVariableResult {
                pub m_state: root::AZ::Internal::EnvironmentVariableResult_States,
                pub m_variable: *mut ::std::os::raw::c_void,
            }
            pub const EnvironmentVariableResult_States_Added:
                root::AZ::Internal::EnvironmentVariableResult_States = 0;
            pub const EnvironmentVariableResult_States_Removed:
                root::AZ::Internal::EnvironmentVariableResult_States = 1;
            pub const EnvironmentVariableResult_States_Found:
                root::AZ::Internal::EnvironmentVariableResult_States = 2;
            pub const EnvironmentVariableResult_States_NotFound:
                root::AZ::Internal::EnvironmentVariableResult_States = 3;
            pub const EnvironmentVariableResult_States_OutOfMemory:
                root::AZ::Internal::EnvironmentVariableResult_States = 4;
            pub type EnvironmentVariableResult_States = i32;
            #[repr(C)]
            pub struct EnvironmentInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EnvironmentInterface {
                pub vtable_: *const EnvironmentInterface__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?s_environment@EnvironmentInterface@Internal@AZ@@2PEAV123@EA"]
                pub static mut EnvironmentInterface_s_environment:
                    *mut root::AZ::Internal::EnvironmentInterface;
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolderBase {
                pub m_environmentOwner: *mut root::AZ::Internal::EnvironmentInterface,
                pub m_moduleOwner: *mut ::std::os::raw::c_void,
                pub m_canTransferOwnership: bool,
                pub m_isConstructed: bool,
                pub m_guid: root::AZ::u32,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
                pub m_useCount: ::std::os::raw::c_int,
                pub m_mutex: root::AZStd::spin_mutex,
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolder {
                pub _base: root::AZ::Internal::EnvironmentVariableHolderBase,
                pub m_value: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?AddAndAllocateVariable@Internal@AZ@@YA?AUEnvironmentVariableResult@12@I_K0PEAPEAVrecursive_mutex@AZStd@@@Z"]
                pub fn AddAndAllocateVariable(
                    guid: root::AZ::u32,
                    byteSize: usize,
                    alignment: usize,
                    addedVariableLock: *mut *mut root::AZStd::recursive_mutex,
                ) -> root::AZ::Internal::EnvironmentVariableResult;
            }
            extern "C" {
                #[link_name = "\u{1}?GetVariable@Internal@AZ@@YA?AUEnvironmentVariableResult@12@I@Z"]
                pub fn GetVariable(
                    guid: root::AZ::u32,
                ) -> root::AZ::Internal::EnvironmentVariableResult;
            }
            extern "C" {
                #[link_name = "\u{1}?GetAllocator@Internal@AZ@@YAPEAVAllocatorInterface@Environment@2@XZ"]
                pub fn GetAllocator() -> *mut root::AZ::Environment::AllocatorInterface;
            }
            extern "C" {
                #[link_name = "\u{1}?EnvironmentVariableNameToId@Internal@AZ@@YAIPEBD@Z"]
                pub fn EnvironmentVariableNameToId(
                    uniqueName: *const ::std::os::raw::c_char,
                ) -> root::AZ::u32;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorDummy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct RttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            pub type RttiHelper_ValueType<T> = T;
            #[repr(C)]
            #[derive(Debug)]
            pub struct ExternalVariadicRttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsSameCast {
                pub _address: u8,
            }
            pub type AddressTypeHelper_type = *const ::std::os::raw::c_void;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiRemoveQualifiers {
                pub _address: u8,
            }
            pub type RttiRemoveQualifiers_type = root::std::remove_cv;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfIdHelper {
                pub _address: u8,
            }
            pub type EBusEnvironmentGetterType =
                ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::EBusEnvironment>;
            pub type EBusEnvironmentSetterType =
                ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::AZ::EBusEnvironment)>;
            #[repr(C)]
            pub struct ContextBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct ContextBase {
                pub vtable_: *const ContextBase__bindgen_vtable,
                pub m_ebusEnvironmentTLSIndex: ::std::os::raw::c_int,
                pub m_ebusEnvironmentGetter: root::AZ::Internal::EBusEnvironmentGetterType,
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@XZ"]
                pub fn ContextBase_ContextBase(this: *mut root::AZ::Internal::ContextBase);
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@PEAVEBusEnvironment@2@@Z"]
                pub fn ContextBase_ContextBase1(
                    this: *mut root::AZ::Internal::ContextBase,
                    arg1: *mut root::AZ::EBusEnvironment,
                );
            }
            impl ContextBase {
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ContextBase_ContextBase(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(arg1: *mut root::AZ::EBusEnvironment) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ContextBase_ContextBase1(__bindgen_tmp.as_mut_ptr(), arg1);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentTLSAccessors {
                pub m_getter: root::AZ::Internal::EBusEnvironmentGetterType,
                pub m_setter: root::AZ::Internal::EBusEnvironmentSetterType,
                pub m_numUniqueEBuses: root::AZStd::atomic_int,
            }
            extern "C" {
                #[link_name = "\u{1}?s_tlsCurrentEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@2PEAVEBusEnvironment@3@EA"]
                pub static mut EBusEnvironmentTLSAccessors_s_tlsCurrentEnvironment:
                    *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@EBusEnvironmentTLSAccessors@Internal@AZ@@SAIXZ"]
                pub fn EBusEnvironmentTLSAccessors_GetId() -> root::AZ::u32;
            }
            extern "C" {
                #[link_name = "\u{1}?GetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAPEAVEBusEnvironment@3@XZ"]
                pub fn EBusEnvironmentTLSAccessors_GetTLSEnvironment(
                ) -> *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?SetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAXPEAVEBusEnvironment@3@@Z"]
                pub fn EBusEnvironmentTLSAccessors_SetTLSEnvironment(
                    environment: *mut root::AZ::EBusEnvironment,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentTLSAccessors@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(
                    this: *mut root::AZ::Internal::EBusEnvironmentTLSAccessors,
                );
            }
            impl EBusEnvironmentTLSAccessors {
                #[inline]
                pub unsafe fn GetId() -> root::AZ::u32 {
                    EBusEnvironmentTLSAccessors_GetId()
                }
                #[inline]
                pub unsafe fn GetTLSEnvironment() -> *mut root::AZ::EBusEnvironment {
                    EBusEnvironmentTLSAccessors_GetTLSEnvironment()
                }
                #[inline]
                pub unsafe fn SetTLSEnvironment(environment: *mut root::AZ::EBusEnvironment) {
                    EBusEnvironmentTLSAccessors_SetTLSEnvironment(environment)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(
                        __bindgen_tmp.as_mut_ptr(),
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentAllocator {
                pub m_name: *const ::std::os::raw::c_char,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
            }
            pub type EBusEnvironmentAllocator_pointer_type = *mut ::std::os::raw::c_void;
            pub type EBusEnvironmentAllocator_size_type = usize;
            pub type EBusEnvironmentAllocator_difference_type = isize;
            pub type EBusEnvironmentAllocator_allow_memory_leaks = root::std::false_type;
            extern "C" {
                #[link_name = "\u{1}?allocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAPEAX_K0H@Z"]
                pub fn EBusEnvironmentAllocator_allocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type;
            }
            extern "C" {
                #[link_name = "\u{1}?deallocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAXPEAX_K1@Z"]
                pub fn EBusEnvironmentAllocator_deallocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@AEBV012@@Z"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator1(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            impl EBusEnvironmentAllocator {
                #[inline]
                pub unsafe fn allocate(
                    &mut self,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type {
                    EBusEnvironmentAllocator_allocate(self, byteSize, alignment, flags)
                }
                #[inline]
                pub unsafe fn deallocate(
                    &mut self,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                ) {
                    EBusEnvironmentAllocator_deallocate(self, ptr, byteSize, alignment)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator1(
                        __bindgen_tmp.as_mut_ptr(),
                        rhs,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullBusMessageCall {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HandlerCompare<Comparer> {
                pub _base: Comparer,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Comparer>>,
            }
            #[repr(C)]
            pub struct NonIdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct NonIdHandler<Interface> {
                pub vtable_: *const NonIdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type NonIdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct IdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct IdHandler<Interface> {
                pub vtable_: *const IdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type IdHandler_IdType = [u8; 0usize];
            pub type IdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct MultiHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct MultiHandler<Interface> {
                pub vtable_: *const MultiHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_handlerNodes: root::AZStd::unordered_map,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type MultiHandler_IdType = [u8; 0usize];
            pub type MultiHandler_HandlerNode = [u8; 0usize];
            pub type MultiHandler_BusType = root::AZ::EBus;
            pub mod _bindgen_mod_id_96599 {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug)]
                pub struct MidDispatchDisconnectFixer<PreHandler, PostHandler> {
                    pub _base: root::AZ::Internal::CallstackEntry,
                    pub m_onPreDisconnect: PreHandler,
                    pub m_onPostDisconnect: PostHandler,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PreHandler>>,
                    pub _phantom_1:
                        ::std::marker::PhantomData<::std::cell::UnsafeCell<PostHandler>>,
                }
                pub type MidDispatchDisconnectFixer_Base = root::AZ::Internal::CallstackEntry;
            }
            pub type EBusContainer_ContainerType = u8;
            pub type EBusContainer_IdType = [u8; 0usize];
            pub type EBusContainer_CallstackEntry = root::AZ::Internal::CallstackEntry;
            pub type EBusContainer_HandlerNode = u8;
            pub type EBusContainer_AddressStorage = u8;
            pub type EBusContainer_HandlerStorage = u8;
            pub type EBusContainer_Handler<Interface> = root::AZ::Internal::IdHandler<Interface>;
            pub type EBusContainer_MultiHandler<Interface> =
                root::AZ::Internal::MultiHandler<Interface>;
            pub type EBusContainer_BusPtr =
                root::AZStd::intrusive_ptr<root::AZ::Internal::EBusContainer_HandlerHolder>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusContainer_Dispatcher {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusContainer_HandlerHolder {
                pub m_busContainer: *mut root::AZ::Internal::EBusContainer_ContainerType,
                pub m_busId: root::AZ::Internal::EBusContainer_IdType,
                pub m_handlers: root::AZ::Internal::EBusContainer_HandlerStorage,
                pub m_refCount: root::AZStd::atomic_uint,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullLockGuard {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterQueueEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusRouter__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EBusRouter<EBus> {
                pub vtable_: *const EBusRouter__bindgen_vtable,
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub m_isConnected: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNestedVersionRouter<EBus> {
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
        }
        pub type EnvironmentInstance = *mut root::AZ::Internal::EnvironmentInterface;
        pub mod Environment {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct AllocatorInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorInterface {
                pub vtable_: *const AllocatorInterface__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?GetInstance@Environment@AZ@@YAPEAVEnvironmentInterface@Internal@2@XZ"]
                pub fn GetInstance() -> root::AZ::EnvironmentInstance;
            }
            extern "C" {
                #[link_name = "\u{1}?GetModuleId@Environment@AZ@@YAPEAXXZ"]
                pub fn GetModuleId() -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?Create@Environment@AZ@@YA_NPEAVAllocatorInterface@12@@Z"]
                pub fn Create(allocator: *mut root::AZ::Environment::AllocatorInterface) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Destroy@Environment@AZ@@YAXXZ"]
                pub fn Destroy();
            }
            extern "C" {
                #[link_name = "\u{1}?Attach@Environment@AZ@@YAXPEAVEnvironmentInterface@Internal@2@_N@Z"]
                pub fn Attach(
                    sourceEnvironment: root::AZ::EnvironmentInstance,
                    useAsGetFallback: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Detach@Environment@AZ@@YAXXZ"]
                pub fn Detach();
            }
            extern "C" {
                #[link_name = "\u{1}?IsReady@Environment@AZ@@YA_NXZ"]
                pub fn IsReady() -> bool;
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EnvironmentVariable {
            pub m_data: *mut root::AZ::EnvironmentVariable_HolderType,
        }
        pub type EnvironmentVariable_HolderType = root::AZ::Internal::EnvironmentVariableHolder;
        pub type EnvironmentVariable_unspecified_bool_type =
            *mut *mut root::AZ::EnvironmentVariable_HolderType;
        #[repr(C)]
        pub struct IAllocatorAllocate__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocatorAllocate {
            pub vtable_: *const IAllocatorAllocate__bindgen_vtable,
        }
        pub type IAllocatorAllocate_pointer_type = *mut ::std::os::raw::c_void;
        pub type IAllocatorAllocate_size_type = usize;
        pub type IAllocatorAllocate_difference_type = isize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocator {
            pub _base: root::AZ::IAllocatorAllocate,
            pub m_records: *mut root::AZ::Debug::AllocationRecords,
            pub m_isReady: bool,
        }
        extern "C" {
            #[link_name = "\u{1}?OnCreated@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnCreated(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnDestroy@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnDestroy(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnOutOfMemory@IAllocator@AZ@@IEAA_N_K0HPEBD1H@Z"]
            pub fn IAllocator_OnOutOfMemory(
                this: *mut root::AZ::IAllocator,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0IAllocator@AZ@@QEAA@XZ"]
            pub fn IAllocator_IAllocator(this: *mut root::AZ::IAllocator);
        }
        impl IAllocator {
            #[inline]
            pub unsafe fn OnCreated(&mut self) {
                IAllocator_OnCreated(self)
            }
            #[inline]
            pub unsafe fn OnDestroy(&mut self) {
                IAllocator_OnDestroy(self)
            }
            #[inline]
            pub unsafe fn OnOutOfMemory(
                &mut self,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool {
                IAllocator_OnOutOfMemory(self, byteSize, alignment, flags, name, fileName, lineNum)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                IAllocator_IAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DIAllocator@AZ@@QEAAXXZ"]
            pub fn IAllocator_IAllocator_destructor(this: *mut root::AZ::IAllocator);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AllocatorBase<SchemaType> {
            pub _base: root::AZ::IAllocator,
            pub m_schema: *mut root::AZ::AllocatorBase_Schema<SchemaType>,
            pub m_name: *const ::std::os::raw::c_char,
            pub m_desc: *const ::std::os::raw::c_char,
            pub m_schemaStorage: u8,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<SchemaType>>,
        }
        pub type AllocatorBase_Descriptor<DescriptorType> = DescriptorType;
        pub type AllocatorBase_Schema<SchemaType> = SchemaType;
        pub mod Memory {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocatorInstance {
            pub _address: u8,
        }
        pub type AllocatorInstance_Descriptor = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct ChildAllocatorSchema {
            pub _base: root::AZ::IAllocatorAllocate,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ChildAllocatorSchema_Descriptor {
            pub _address: u8,
        }
        pub type ChildAllocatorSchema_Parent<ParentAllocator> = ParentAllocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdAlloc {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdAlloc_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdAlloc_size_type = usize;
        pub type AZStdAlloc_difference_type = isize;
        pub type AZStdAlloc_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdIAllocator {
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdIAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdIAllocator_size_type = usize;
        pub type AZStdIAllocator_difference_type = isize;
        pub type AZStdIAllocator_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdFunctorAllocator {
            pub m_allocatorFunctor: root::AZ::AZStdFunctorAllocator_functor_type,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdFunctorAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdFunctorAllocator_size_type = usize;
        pub type AZStdFunctorAllocator_difference_type = isize;
        pub type AZStdFunctorAllocator_allow_memory_leaks = root::std::false_type;
        pub type AZStdFunctorAllocator_functor_type =
            ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::IAllocatorAllocate>;
        pub type AZClassAllocatorResultType_type = root::std::true_type;
        pub type HasAZClassAllocator_Yes = ::std::os::raw::c_char;
        pub type HasAZClassAllocator_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZClassAllocator_Helper {
            pub _address: u8,
        }
        pub type HasAZClassAllocator_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZClassAllocator_type = u8;
        extern "C" {
            #[link_name = "\u{1}?OperatorNew@AZ@@YAPEAX_KPEBDH1@Z"]
            pub fn OperatorNew(
                size: usize,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNew@AZ@@YAPEAX_K@Z"]
            pub fn OperatorNew1(byteSize: usize) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorDelete@AZ@@YAXPEAX@Z"]
            pub fn OperatorDelete(ptr: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNewArray@AZ@@YAPEAX_KPEBDH1@Z"]
            pub fn OperatorNewArray(
                size: usize,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNewArray@AZ@@YAPEAX_K@Z"]
            pub fn OperatorNewArray1(byteSize: usize) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorDeleteArray@AZ@@YAXPEAX@Z"]
            pub fn OperatorDeleteArray(ptr: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OSAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_numAllocatedBytes: root::AZ::IAllocatorAllocate_size_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OSAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_TYPEINFO_Enable(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@OSAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn OSAllocator_Create(
                this: *mut root::AZ::OSAllocator,
                desc: *const root::AZ::OSAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_Destroy(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@QEAA@XZ"]
            pub fn OSAllocator_OSAllocator(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn OSAllocator_OSAllocator1(
                this: *mut root::AZ::OSAllocator,
                arg1: *const root::AZ::OSAllocator,
            );
        }
        impl OSAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                OSAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Create(&mut self, desc: *const root::AZ::OSAllocator_Descriptor) -> bool {
                OSAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                OSAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OSAllocator_OSAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::OSAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OSAllocator_OSAllocator1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DOSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_OSAllocator_destructor(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@OSAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn OSAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@OSAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn OSAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        pub type OSStdAllocator = root::AZ::AZStdAlloc;
        pub type RTTI_EnumCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::AZ::TypeId, arg2: *mut ::std::os::raw::c_void),
        >;
        pub type AZRttiIntrusiveResultType_type = root::std::true_type;
        pub type HasAZRttiIntrusive_Yes = ::std::os::raw::c_char;
        pub type HasAZRttiIntrusive_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiIntrusive_Helper {
            pub _address: u8,
        }
        pub type HasAZRttiIntrusive_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZRttiIntrusive_type = u8;
        pub const RttiKind_None: root::AZ::RttiKind = 0;
        pub const RttiKind_Intrusive: root::AZ::RttiKind = 1;
        pub const RttiKind_External: root::AZ::RttiKind = 2;
        pub type RttiKind = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiExternal {
            pub _address: u8,
        }
        pub type HasAZRttiExternal_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRtti {
            pub _address: u8,
        }
        pub type HasAZRtti_type = u8;
        pub type HasAZRtti_kind_type = u8;
        #[repr(C)]
        pub struct IRttiHelper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRttiHelper {
            pub vtable_: *const IRttiHelper__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusEnvironment {
            pub m_tlsAccessor: root::AZ::EnvironmentVariable,
            pub m_stackPrevEnvironment: *mut root::AZ::EBusEnvironment,
            pub m_busContexts: root::AZStd::vector<
                root::AZStd::pair<*mut root::AZ::Internal::ContextBase, bool>,
                root::AZ::OSStdAllocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?ActivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_ActivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?DeactivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_DeactivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@EBusEnvironment@AZ@@SAPEAV12@XZ"]
            pub fn EBusEnvironment_Create() -> *mut root::AZ::EBusEnvironment;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@EBusEnvironment@AZ@@SAXPEAV12@@Z"]
            pub fn EBusEnvironment_Destroy(environment: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?FindContext@EBusEnvironment@AZ@@QEAAPEAVContextBase@Internal@2@H@Z"]
            pub fn EBusEnvironment_FindContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase;
        }
        extern "C" {
            #[link_name = "\u{1}?InsertContext@EBusEnvironment@AZ@@QEAA_NHPEAVContextBase@Internal@2@_N@Z"]
            pub fn EBusEnvironment_InsertContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0EBusEnvironment@AZ@@QEAA@XZ"]
            pub fn EBusEnvironment_EBusEnvironment(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}??_DEBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_EBusEnvironment_destructor(this: *mut root::AZ::EBusEnvironment);
        }
        impl EBusEnvironment {
            #[inline]
            pub unsafe fn ActivateOnCurrentThread(&mut self) {
                EBusEnvironment_ActivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn DeactivateOnCurrentThread(&mut self) {
                EBusEnvironment_DeactivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn Create() -> *mut root::AZ::EBusEnvironment {
                EBusEnvironment_Create()
            }
            #[inline]
            pub unsafe fn Destroy(environment: *mut root::AZ::EBusEnvironment) {
                EBusEnvironment_Destroy(environment)
            }
            #[inline]
            pub unsafe fn FindContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase {
                EBusEnvironment_FindContext(self, tlsKey)
            }
            #[inline]
            pub unsafe fn InsertContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool {
                EBusEnvironment_InsertContext(self, tlsKey, context, isTakeOwnership)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                EBusEnvironment_EBusEnvironment(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                EBusEnvironment_EBusEnvironment_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusEnvironmentStoragePolicy {
            pub _address: u8,
        }
        pub const EBusAddressPolicy_Single: root::AZ::EBusAddressPolicy = 0;
        pub const EBusAddressPolicy_ById: root::AZ::EBusAddressPolicy = 1;
        pub const EBusAddressPolicy_ByIdAndOrdered: root::AZ::EBusAddressPolicy = 2;
        pub type EBusAddressPolicy = i32;
        pub const EBusHandlerPolicy_Single: root::AZ::EBusHandlerPolicy = 0;
        pub const EBusHandlerPolicy_Multiple: root::AZ::EBusHandlerPolicy = 1;
        pub const EBusHandlerPolicy_MultipleAndOrdered: root::AZ::EBusHandlerPolicy = 2;
        pub type EBusHandlerPolicy = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusConnectionPolicy {
            pub _address: u8,
        }
        pub type EBusConnectionPolicy_BusPtr = [u8; 0usize];
        pub type EBusConnectionPolicy_BusIdType = [u8; 0usize];
        pub type EBusConnectionPolicy_HandlerNode = [u8; 0usize];
        pub type EBusConnectionPolicy_Context = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusGlobalStoragePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusThreadLocalStoragePolicy {
            pub _address: u8,
        }
        pub type EBusQueuePolicy_BusMessageCall = root::AZ::Internal::NullBusMessageCall;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BusHandlerCompareDefault {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterNode<Interface> {
            pub _base: root::AZStd::intrusive_multiset_node<root::AZ::EBusRouterNode<Interface>>,
            pub m_handler: *mut Interface,
            pub m_order: ::std::os::raw::c_int,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterPolicy {
            pub _address: u8,
        }
        pub type EBusRouterPolicy_RouterNode = u8;
        pub type EBusRouterPolicy_Container = u8;
        pub const EBusRouterPolicy_EventProcessingState_ContinueProcess:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListeners:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListenersAndRouters:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub type EBusRouterPolicy_EventProcessingState = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HphaSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SystemAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_isCustom: bool,
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_ownsOSAllocator: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_heap: root::AZ::SystemAllocator_Descriptor_Heap,
            pub m_allocationRecords: bool,
            pub m_stackRecordLevels: ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor_Heap {
            pub m_pageSize: ::std::os::raw::c_uint,
            pub m_poolPageSize: ::std::os::raw::c_uint,
            pub m_isPoolAllocations: bool,
            pub m_numFixedMemoryBlocks: ::std::os::raw::c_int,
            pub m_fixedMemoryBlocks: [*mut ::std::os::raw::c_void; 3usize],
            pub m_fixedMemoryBlocksByteSize: [usize; 3usize],
            pub m_subAllocator: *mut root::AZ::IAllocatorAllocate,
            pub m_systemChunkSize: usize,
        }
        pub const SystemAllocator_Descriptor_Heap_m_defaultPageSize: ::std::os::raw::c_int = 65536;
        pub const SystemAllocator_Descriptor_Heap_m_defaultPoolPageSize: ::std::os::raw::c_int =
            4096;
        pub const SystemAllocator_Descriptor_Heap_m_memoryBlockAlignment: ::std::os::raw::c_int =
            65536;
        pub const SystemAllocator_Descriptor_Heap_m_maxNumFixedBlocks: ::std::os::raw::c_int = 3;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_TYPEINFO_Enable(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@SystemAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn SystemAllocator_Create(
                this: *mut root::AZ::SystemAllocator,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_Destroy(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@QEAA@XZ"]
            pub fn SystemAllocator_SystemAllocator(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn SystemAllocator_SystemAllocator1(
                this: *mut root::AZ::SystemAllocator,
                arg1: *const root::AZ::SystemAllocator,
            );
        }
        impl SystemAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                SystemAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Create(
                &mut self,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool {
                SystemAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                SystemAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SystemAllocator_SystemAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::SystemAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SystemAllocator_SystemAllocator1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DSystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_SystemAllocator_destructor(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@SystemAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn SystemAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@SystemAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn SystemAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ReAllocate@SystemAllocator@AZ@@UEAAPEAXPEAX_K1@Z"]
            pub fn SystemAllocator_ReAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
                newAlignment: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?Resize@SystemAllocator@AZ@@UEAA_KPEAX_K@Z"]
            pub fn SystemAllocator_Resize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?AllocationSize@SystemAllocator@AZ@@UEAA_KPEAX@Z"]
            pub fn SystemAllocator_AllocationSize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullMutex {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusId {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusIdCompare {
            _unused: [u8; 0],
        }
        pub mod BusInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusImplTraits {
                pub _address: u8,
            }
            pub type EBusImplTraits_Traits<BusTraits> = BusTraits;
            pub type EBusImplTraits_AllocatorType = [u8; 0usize];
            pub type EBusImplTraits_InterfaceType<Interface> = Interface;
            pub type EBusImplTraits_Events<Interface> = Interface;
            pub type EBusImplTraits_BusIdType = [u8; 0usize];
            pub type EBusImplTraits_BusIdOrderCompare = [u8; 0usize];
            pub type EBusImplTraits_MutexType = [u8; 0usize];
            pub type EBusImplTraits_BusesContainer = u8;
            pub type EBusImplTraits_EventQueueMutexType = [u8; 0usize];
            pub type EBusImplTraits_BusPtr = root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            pub type EBusImplTraits_HandlerNode =
                root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventer {
                pub _address: u8,
            }
            pub type EBusEventer_BusIdType = [u8; 0usize];
            pub type EBusEventer_BusPtr = [u8; 0usize];
            pub type EBusEventer_MultiHandler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventEnumerator {
                pub _address: u8,
            }
            pub type EBusEventEnumerator_BusIdType = [u8; 0usize];
            pub type EBusEventEnumerator_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcaster {
                pub _address: u8,
            }
            pub type EBusBroadcaster_Handler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNullQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventQueue {
                pub _address: u8,
            }
            pub type EBusEventQueue_BusIdType = [u8; 0usize];
            pub type EBusEventQueue_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastEnumerator {
                pub _address: u8,
            }
            pub type EventDispatcher = [u8; 0usize];
            #[repr(C)]
            pub struct EBusImpl {
                pub _address: u8,
            }
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type ArgumentValidatorHelper_is_non_const_lvalue_reference = u8;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusReduceResult<T, Aggregator> {
            pub value: T,
            pub unary: Aggregator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Aggregator>>,
        }
        pub type EBusArithmericResult<T, Arithmetic> = root::AZ::EBusReduceResult<T, Arithmetic>;
        pub type EBusLogicalResult<T, Operator> = root::AZ::EBusReduceResult<T, Operator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusAggregateResults {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusTraits {
            pub _address: u8,
        }
        pub type EBusTraits_AllocatorType = root::AZStd::allocator;
        pub type EBusTraits_BusIdType = root::AZ::NullBusId;
        pub type EBusTraits_BusIdOrderCompare = root::AZ::NullBusIdCompare;
        pub type EBusTraits_BusHandlerOrderCompare = root::AZ::BusHandlerCompareDefault;
        pub type EBusTraits_MutexType = root::AZ::NullMutex;
        pub type EBusTraits_EventQueueMutexType = root::AZ::NullMutex;
        pub type EBusTraits_ConnectionPolicy = root::AZ::EBusConnectionPolicy;
        pub type EBusTraits_StoragePolicy = root::AZ::EBusEnvironmentStoragePolicy;
        pub type EBusTraits_RouterPolicy = u8;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@EBusTraits@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static EBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@EBusTraits@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static EBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        pub const EBusTraits_EnableEventQueue: bool = false;
        pub const EBusTraits_EventQueueingActiveByDefault: bool = true;
        pub const EBusTraits_EnableQueuedReferences: bool = false;
        pub const EBusTraits_LocklessDispatch: bool = false;
        #[repr(C)]
        pub struct EBus {
            pub _address: u8,
        }
        pub type EBus_ImplTraits = root::AZ::BusInternal::EBusImplTraits;
        pub type EBus_BaseImpl = root::AZ::BusInternal::EBusImpl;
        pub type EBus_Traits = root::AZ::EBus_ImplTraits;
        pub type EBus_ThisType = root::AZ::EBus;
        pub type EBus_AllocatorType = root::AZ::EBus_ImplTraits;
        pub type EBus_InterfaceType = root::AZ::EBus_ImplTraits;
        pub type EBus_Events = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdOrderCompare = root::AZ::EBus_ImplTraits;
        pub type EBus_MutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusesContainer = root::AZ::EBus_ImplTraits;
        pub type EBus_EventQueueMutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusPtr = root::AZ::EBus_ImplTraits;
        pub type EBus_HandlerNode = root::AZ::EBus_ImplTraits;
        pub type EBus_QueuePolicy = u8;
        pub type EBus_ConnectionPolicy = root::AZ::EBus_Traits;
        pub type EBus_CallstackEntry = root::AZ::Internal::CallstackEntry;
        pub type EBus_Router = root::AZ::Internal::EBusRouter<root::AZ::EBus_ThisType>;
        pub type EBus_NestedVersionRouter =
            root::AZ::Internal::EBusNestedVersionRouter<root::AZ::EBus_ThisType>;
        pub type EBus_RouterPolicy = root::AZ::EBus_Traits;
        pub type EBus_RouterProcessingState = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_Context {
            pub _base: root::AZ::Internal::ContextBase,
            pub m_buses: root::AZ::EBus_BusesContainer,
            pub m_contextMutex: root::AZ::EBus_Context_ContextMutexType,
            pub m_queue: root::AZ::EBus_QueuePolicy,
            pub m_routing: root::AZ::EBus_RouterPolicy,
            pub m_callstackRoots: root::AZStd::unordered_map,
            pub s_callstack: root::AZ::EBus_Context_CallstackEntryStorageType,
            pub m_dispatches: root::AZStd::atomic_uint,
        }
        pub type EBus_Context_ContextMutexType = root::AZStd::conditional_t;
        pub type EBus_Context_DispatchLockGuard = root::AZStd::conditional_t;
        pub type EBus_Context_CallstackEntryBase = root::AZ::Internal::CallstackEntryBase;
        pub type EBus_Context_CallstackEntryRoot = root::AZ::Internal::CallstackEntryRoot;
        pub type EBus_Context_CallstackEntryStorageType = u8;
        pub type EBus_StoragePolicy = root::AZ::EBus_Traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_RouterCallstackEntry {
            pub _base: root::AZ::EBus_CallstackEntry,
            pub m_iterator: root::AZ::EBus_RouterCallstackEntry_Iterator,
            pub m_processingState: root::AZ::EBus_RouterProcessingState,
            pub m_isQueued: bool,
            pub m_isReverse: bool,
        }
        pub type EBus_RouterCallstackEntry_Iterator = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        pub struct EntityId {
            pub m_id: root::AZ::u64,
        }
        pub const EntityId_InvalidEntityId: root::AZ::u64 = 4294967295;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@EntityId@AZ@@QEAAXXZ"]
            pub fn EntityId_TYPEINFO_Enable(this: *mut root::AZ::EntityId);
        }
        impl EntityId {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                EntityId_TYPEINFO_Enable(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ReflectContext {
            _unused: [u8; 0],
        }
        pub type ComponentId = root::AZ::u64;
        #[repr(C)]
        pub struct ComponentBus__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentBus {
            pub vtable_: *const ComponentBus__bindgen_vtable,
        }
        pub type ComponentBus_BusIdType = root::AZ::EntityId;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@ComponentBus@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static ComponentBus_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        #[repr(C)]
        pub struct ComponentConfig__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentConfig {
            pub vtable_: *const ComponentConfig__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ComponentConfig@AZ@@QEAAXXZ"]
            pub fn ComponentConfig_TYPEINFO_Enable(this: *mut root::AZ::ComponentConfig);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@ComponentConfig@AZ@@QEAAXXZ"]
            pub fn ComponentConfig_RTTI_Enable(this: *mut root::AZ::ComponentConfig);
        }
        impl ComponentConfig {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ComponentConfig_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                ComponentConfig_RTTI_Enable(self)
            }
        }
        #[repr(C)]
        pub struct EntityComponentIdPair__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct EntityComponentIdPair {
            pub vtable_: *const EntityComponentIdPair__bindgen_vtable,
            pub m_entityId: root::AZ::EntityId,
            pub m_componentId: root::AZ::ComponentId,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@EntityComponentIdPair@AZ@@QEAAXXZ"]
            pub fn EntityComponentIdPair_TYPEINFO_Enable(
                this: *mut root::AZ::EntityComponentIdPair,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@EntityComponentIdPair@AZ@@QEAAXXZ"]
            pub fn EntityComponentIdPair_RTTI_Enable(this: *mut root::AZ::EntityComponentIdPair);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@EntityComponentIdPair@AZ@@SAXPEAVReflectContext@2@@Z"]
            pub fn EntityComponentIdPair_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl EntityComponentIdPair {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                EntityComponentIdPair_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                EntityComponentIdPair_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                EntityComponentIdPair_Reflect(context)
            }
        }
        #[repr(C)]
        pub struct EntityComponentBus__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct EntityComponentBus {
            pub vtable_: *const EntityComponentBus__bindgen_vtable,
        }
        pub type EntityComponentBus_BusIdType = root::AZ::EntityComponentIdPair;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@EntityComponentBus@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static EntityComponentBus_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptTimePoint {
            pub m_timePoint: root::AZStd::chrono::system_clock_time_point,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ScriptTimePoint@AZ@@QEAAXXZ"]
            pub fn ScriptTimePoint_TYPEINFO_Enable(this: *mut root::AZ::ScriptTimePoint);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ScriptTimePoint@AZ@@SAXPEAVReflectContext@2@@Z"]
            pub fn ScriptTimePoint_Reflect(reflection: *mut root::AZ::ReflectContext);
        }
        impl ScriptTimePoint {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ScriptTimePoint_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(reflection: *mut root::AZ::ReflectContext) {
                ScriptTimePoint_Reflect(reflection)
            }
        }
        pub const ComponentTickBus_TICK_FIRST: root::AZ::ComponentTickBus = 0;
        pub const ComponentTickBus_TICK_PLACEMENT: root::AZ::ComponentTickBus = 50;
        pub const ComponentTickBus_TICK_INPUT: root::AZ::ComponentTickBus = 75;
        pub const ComponentTickBus_TICK_GAME: root::AZ::ComponentTickBus = 80;
        pub const ComponentTickBus_TICK_ANIMATION: root::AZ::ComponentTickBus = 100;
        pub const ComponentTickBus_TICK_PHYSICS: root::AZ::ComponentTickBus = 200;
        pub const ComponentTickBus_TICK_ATTACHMENT: root::AZ::ComponentTickBus = 500;
        pub const ComponentTickBus_TICK_PRE_RENDER: root::AZ::ComponentTickBus = 750;
        pub const ComponentTickBus_TICK_DEFAULT: root::AZ::ComponentTickBus = 1000;
        pub const ComponentTickBus_TICK_UI: root::AZ::ComponentTickBus = 2000;
        pub const ComponentTickBus_TICK_LAST: root::AZ::ComponentTickBus = 100000;
        pub type ComponentTickBus = i32;
        #[repr(C)]
        pub struct TickEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct TickEvents {
            pub vtable_: *const TickEvents__bindgen_vtable,
            pub m_tickOrder: ::std::os::raw::c_int,
        }
        pub type TickEvents_EventQueueMutexType = root::AZStd::recursive_mutex;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TickEvents_BusHandlerOrderCompare {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@TickEvents@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static TickEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub const TickEvents_EnableEventQueue: bool = true;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@TickEvents@AZ@@QEAAXXZ"]
            pub fn TickEvents_TYPEINFO_Enable(this: *mut root::AZ::TickEvents);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@TickEvents@AZ@@QEAAXXZ"]
            pub fn TickEvents_RTTI_Enable(this: *mut root::AZ::TickEvents);
        }
        impl TickEvents {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                TickEvents_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                TickEvents_RTTI_Enable(self)
            }
        }
        pub type TickBus = root::AZ::EBus;
        #[repr(C)]
        pub struct TickRequests__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct TickRequests {
            pub vtable_: *const TickRequests__bindgen_vtable,
        }
        pub type TickRequestBus = root::AZ::EBus;
        #[repr(C)]
        pub struct SystemTickEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SystemTickEvents {
            pub vtable_: *const SystemTickEvents__bindgen_vtable,
        }
        pub type SystemTickEvents_EventQueueMutexType = root::AZStd::mutex;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@SystemTickEvents@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static SystemTickEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub const SystemTickEvents_EnableEventQueue: bool = true;
        pub type SystemTickBus = root::AZ::EBus;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssetSerializer {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssetEventHandler {
            _unused: [u8; 0],
        }
        pub mod Data {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEntry {
                _unused: [u8; 0],
            }
            pub type AssetType = root::AZ::Uuid;
            pub mod AssetInternal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}?IsValidAssetType@AssetInternal@Data@AZ@@YA_NAEBUUuid@3@PEAVSerializeContext@3@@Z"]
                    pub fn IsValidAssetType(
                        type_: *const root::AZ::Data::AssetType,
                        serializeContext: *mut root::AZ::SerializeContext,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?QueueAssetLoad@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@PEAVAssetData@23@AEBV?$function@$$A6A_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@@Z@AZStd@@@Z"]
                    pub fn QueueAssetLoad(
                        assetData: *mut root::AZ::Data::AssetData,
                        assetLoadFilterCB: *const root::AZ::Data::AssetFilterCB,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?GetAsset@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@AEBUAssetId@23@AEBUUuid@3@_N2@Z"]
                    pub fn GetAsset(
                        id: *const root::AZ::Data::AssetId,
                        type_: *const root::AZ::Data::AssetType,
                        queueLoad: bool,
                        isCreate: bool,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?UpdateAssetInfo@AssetInternal@Data@AZ@@YAXAEAUAssetId@23@AEAV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
                    pub fn UpdateAssetInfo(
                        id: *mut root::AZ::Data::AssetId,
                        assetHint: *mut root::AZStd::string,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?ReloadAsset@AssetInternal@Data@AZ@@YA_NPEAVAssetData@23@@Z"]
                    pub fn ReloadAsset(assetData: *mut root::AZ::Data::AssetData) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?SaveAsset@AssetInternal@Data@AZ@@YA_NPEAVAssetData@23@@Z"]
                    pub fn SaveAsset(assetData: *mut root::AZ::Data::AssetData) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?GetAssetData@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@AEBUAssetId@23@@Z"]
                    pub fn GetAssetData(
                        id: *const root::AZ::Data::AssetId,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?ResolveAssetId@AssetInternal@Data@AZ@@YA?AUAssetId@23@AEBU423@@Z"]
                    pub fn ResolveAssetId(
                        id: *const root::AZ::Data::AssetId,
                    ) -> root::AZ::Data::AssetId;
                }
            }
            pub type AssetPtr = *mut root::AZ::Data::AssetData;
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetId {
                pub m_guid: root::AZ::Uuid,
                pub m_subId: root::AZ::u32,
                pub __bindgen_padding_0: [u32; 3usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?IsValid@AssetId@Data@AZ@@QEBA_NXZ"]
                pub fn AssetId_IsValid(this: *const root::AZ::Data::AssetId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?SetInvalid@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_SetInvalid(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?CreateString@AssetId@Data@AZ@@SA?AU123@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
                pub fn AssetId_CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@XZ"]
                pub fn AssetId_AssetId(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@AEBUUuid@2@I@Z"]
                pub fn AssetId_AssetId1(
                    this: *mut root::AZ::Data::AssetId,
                    guid: *const root::AZ::Uuid,
                    sudId: root::AZ::u32,
                );
            }
            impl AssetId {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetId_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn IsValid(&self) -> bool {
                    AssetId_IsValid(self)
                }
                #[inline]
                pub unsafe fn SetInvalid(&mut self) {
                    AssetId_SetInvalid(self)
                }
                #[inline]
                pub unsafe fn CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId {
                    AssetId_CreateString(input)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetId_AssetId(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(guid: *const root::AZ::Uuid, sudId: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetId_AssetId1(__bindgen_tmp.as_mut_ptr(), guid, sudId);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct AssetData__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetData {
                pub vtable_: *const AssetData__bindgen_vtable,
                pub __bindgen_padding_0: [u32; 2usize],
                pub m_useCount: root::AZStd::atomic_int,
                pub m_status: root::AZStd::atomic_int,
                pub __bindgen_padding_1: u64,
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_creationToken: ::std::os::raw::c_int,
                pub __bindgen_padding_2: [u32; 3usize],
            }
            pub const AssetData_AssetStatus_NotLoaded: root::AZ::Data::AssetData_AssetStatus = 0;
            pub const AssetData_AssetStatus_Loading: root::AZ::Data::AssetData_AssetStatus = 1;
            pub const AssetData_AssetStatus_ReadyPreNotify: root::AZ::Data::AssetData_AssetStatus =
                2;
            pub const AssetData_AssetStatus_Ready: root::AZ::Data::AssetData_AssetStatus = 3;
            pub const AssetData_AssetStatus_Error: root::AZ::Data::AssetData_AssetStatus = 4;
            pub type AssetData_AssetStatus = i32;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_RTTI_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?Acquire@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Acquire(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?Release@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Release(this: *mut root::AZ::Data::AssetData);
            }
            impl AssetData {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetData_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetData_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Acquire(&mut self) {
                    AssetData_Acquire(self)
                }
                #[inline]
                pub unsafe fn Release(&mut self) {
                    AssetData_Release(self)
                }
            }
            pub const AssetLoadBehavior_Default: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_PreLoad: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_QueueLoad: root::AZ::Data::AssetLoadBehavior = 1;
            pub const AssetLoadBehavior_NoLoad: root::AZ::Data::AssetLoadBehavior = 2;
            pub const AssetLoadBehavior_Count: root::AZ::Data::AssetLoadBehavior = 3;
            pub type AssetLoadBehavior = u8;
            pub type AssetFilterCB = [u64; 5usize];
            #[repr(C)]
            pub struct Asset {
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_assetData: *mut root::AZ::Data::AssetData,
                pub m_loadBehavior: root::AZ::Data::AssetLoadBehavior,
                pub m_assetHint: root::AZStd::string,
            }
            pub type Asset_ThisType = root::AZ::Data::Asset;
            #[repr(C)]
            pub struct AssetEvents__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetEvents {
                pub vtable_: *const AssetEvents__bindgen_vtable,
            }
            pub type AssetEvents_MutexType = root::AZStd::recursive_mutex;
            pub type AssetEvents_BusIdType = root::AZ::Data::AssetId;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEvents_AssetConnectionPolicy {
                pub _address: u8,
            }
            pub type AssetEvents_ConnectionPolicy =
                root::AZ::Data::AssetEvents_AssetConnectionPolicy;
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetEvents@Data@AZ@@2W4EBusAddressPolicy@3@B"]
                pub static AssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
            pub const AssetEvents_EnableEventQueue: bool = true;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_RTTI_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            impl AssetEvents {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetEvents_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetEvents_RTTI_Enable(self)
                }
            }
            pub type AssetBus = root::AZ::EBus;
            #[repr(C)]
            pub struct AssetBusCallbacks__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetBusCallbacks {
                pub vtable_: *const AssetBusCallbacks__bindgen_vtable,
                pub _base: [u64; 5usize],
                pub m_onAssetReadyCB: root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                pub m_onAssetMovedCB: root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                pub m_onAssetReloadedCB: root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                pub m_onAssetSavedCB: root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                pub m_onAssetUnloadedCB: root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                pub m_onAssetErrorCB: root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
            }
            pub type AssetBusCallbacks_AssetReadyCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetMovedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetReloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetSavedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetUnloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetErrorCB = [u64; 5usize];
            extern "C" {
                #[link_name = "\u{1}?SetCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@5@0AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@5@AEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@5@0@Z"]
                pub fn AssetBusCallbacks_SetCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ClearCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXXZ"]
                pub fn AssetBusCallbacks_ClearCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReadyCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReadyCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetMovedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetMovedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetSavedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetSavedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetUnloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetUnloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetErrorCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetErrorCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            impl AssetBusCallbacks {
                #[inline]
                pub unsafe fn SetCallbacks(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetCallbacks(
                        self, readyCB, movedCB, reloadedCB, savedCB, unloadedCB, errorCB,
                    )
                }
                #[inline]
                pub unsafe fn ClearCallbacks(&mut self) {
                    AssetBusCallbacks_ClearCallbacks(self)
                }
                #[inline]
                pub unsafe fn SetOnAssetReadyCallback(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReadyCallback(self, readyCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetMovedCallback(
                    &mut self,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetMovedCallback(self, movedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetReloadedCallback(
                    &mut self,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReloadedCallback(self, reloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetSavedCallback(
                    &mut self,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetSavedCallback(self, savedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetUnloadedCallback(
                    &mut self,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetUnloadedCallback(self, unloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetErrorCallback(
                    &mut self,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetOnAssetErrorCallback(self, errorCB)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReady@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReady(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetMoved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@PEAX@Z"]
                pub fn AssetBusCallbacks_OnAssetMoved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    oldDataPointer: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReloaded@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReloaded(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetSaved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@_N@Z"]
                pub fn AssetBusCallbacks_OnAssetSaved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    isSuccessful: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetUnloaded@AssetBusCallbacks@Data@AZ@@UEAAXUAssetId@23@UUuid@3@@Z"]
                pub fn AssetBusCallbacks_OnAssetUnloaded(
                    this: *mut ::std::os::raw::c_void,
                    assetId: root::AZ::Data::AssetId,
                    assetType: root::AZ::Data::AssetType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetError@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetError(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?AssetFilterNoAssetLoading@Data@AZ@@YA_NAEBV?$Asset@VAssetData@Data@AZ@@@12@@Z"]
                pub fn AssetFilterNoAssetLoading(arg1: *const root::AZ::Data::Asset) -> bool;
            }
        }
    }
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Ty> = _Ty;
        pub type integral_constant_type = u8;
        pub type bool_constant = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type conditional_type<_Ty2> = _Ty2;
        pub type conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_const {
            pub _address: u8,
        }
        pub type remove_const_type<_Ty> = _Ty;
        pub type remove_const_t = root::std::remove_const;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Ty> = _Ty;
        pub type remove_cv_t = root::std::remove_cv;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Ty> = _Ty;
        pub type remove_reference_t = root::std::remove_reference;
        pub mod tr1 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Add_reference {
            pub _address: u8,
        }
        pub type _Add_reference__Lvalue<_Ty> = _Ty;
        pub type _Add_reference__Rvalue<_Ty> = _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_lvalue_reference {
            pub _address: u8,
        }
        pub type add_lvalue_reference_type = root::std::_Add_reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_rvalue_reference {
            pub _address: u8,
        }
        pub type add_rvalue_reference_type = root::std::_Add_reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_pointer {
            pub _address: u8,
        }
        pub type remove_pointer_type<_Ty> = _Ty;
        pub type remove_pointer_t = root::std::remove_pointer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Change_sign {
            pub _address: u8,
        }
        pub type _Change_sign__Signed = root::std::conditional_t;
        pub type _Change_sign__Unsigned = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = root::std::_Change_sign;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct underlying_type {
            pub _address: u8,
        }
        pub type underlying_type_type<_Ty> = _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct decay {
            pub _address: u8,
        }
        pub type decay__Ty1 = root::std::remove_reference_t;
        pub type decay_type = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple_size {
            pub _address: u8,
        }
        pub type _Compressed_pair__Mybase<_Ty1> = _Ty1;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Ignore {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Replace_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_element_type {
            pub _address: u8,
        }
        pub type _Get_element_type_type = root::std::_Get_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_ptr_difference_type {
            pub _address: u8,
        }
        pub type _Get_ptr_difference_type_type = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_rebind_alias {
            pub _address: u8,
        }
        pub type _Get_rebind_alias_type = root::std::_Replace_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits_element_type = root::std::_Get_element_type;
        pub type pointer_traits_pointer<_Ty> = _Ty;
        pub type pointer_traits_difference_type = root::std::_Get_ptr_difference_type;
        pub type pointer_traits_rebind = root::std::_Get_rebind_alias;
        pub type pointer_traits__Reftype = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_deleter_pointer_type {
            pub _address: u8,
        }
        pub type _Get_deleter_pointer_type_type<_Ty> = *mut _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Unique_ptr_base {
            pub _Mypair: u8,
        }
        pub type _Unique_ptr_base__Dx_noref = root::std::remove_reference_t;
        pub type _Unique_ptr_base_pointer = root::std::_Get_deleter_pointer_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub _base: root::std::_Unique_ptr_base,
        }
        pub type unique_ptr__Mybase = root::std::_Unique_ptr_base;
        pub type unique_ptr_pointer = root::std::unique_ptr__Mybase;
        pub type unique_ptr_element_type<_Ty> = _Ty;
        pub type unique_ptr_deleter_type<_Dx> = _Dx;
        pub type _Uint1_t = ::std::os::raw::c_uchar;
        pub type _Atomic_impl__My_int = root::std::_Uint1_t;
        pub type _Atomic_base__Mybase = u8;
        pub type _Atomic_base__My_int = root::std::_Atomic_base__Mybase;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic__My_base = u8;
        pub type atomic_value_type<_Ty> = _Ty;
    }
    pub mod AZStd {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type sys_time_t = root::AZ::s64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<Arg> = Arg;
        pub type unary_function_result_type<Result> = Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<Arg1> = Arg1;
        pub type binary_function_second_argument_type<Arg2> = Arg2;
        pub type binary_function_result_type<Result> = Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct plus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct minus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct multiplies {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct divides {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct modulus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct negate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct not_equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_not {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_negate<Functor> {
            pub m_functor: Functor,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Functor>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_negate<Functor> {
            pub m_functor: Functor,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Functor>>,
        }
        pub type bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_void {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_integral {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_floating_point {
            pub _base: u8,
        }
        pub mod type_traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const ice_or_value: bool = true;
            pub const ice_and_value: bool = false;
            pub const ice_not_value: bool = true;
            pub type yes_type = ::std::os::raw::c_char;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct no_type {
                pub padding: [::std::os::raw::c_char; 8usize],
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ice_eq_value: bool;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ice_ne_value: bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct wrap {
                pub _address: u8,
            }
        }
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_arithmetic_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_member_pointer_helper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_scalar_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_pod_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct alignment_of_hack {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static alignment_logic_value: usize;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct alignment_of_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Copy, Clone)]
            pub union aligned_storage__bindgen_ty_1 {
                pub _bindgen_opaque_blob: u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_abstract_imp {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_basic_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl {
                pub _address: u8,
            }
            pub type is_convertible_impl_ref_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_select_rebind {
                pub _address: u8,
            }
            pub type is_convertible_impl_select_rebind_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_dispatch_base {
                pub _address: u8,
            }
            pub type is_convertible_impl_dispatch_base_selector = u8;
            pub type is_convertible_impl_dispatch_base_isc_binder = u8;
            pub type is_convertible_impl_dispatch_base_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_dispatch {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?is_lvalue_reference_helper1@Internal@AZStd@@YADZZ"]
                pub fn is_lvalue_reference_helper1() -> ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?is_lvalue_reference_helper2@Internal@AZStd@@YADZZ"]
                pub fn is_lvalue_reference_helper2() -> root::AZStd::type_traits::yes_type;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_lvalue_reference_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct are_pair_args_comparable {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct addr_impl_ref {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct addressof_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_in_place_index {
                pub _address: u8,
            }
            pub type is_in_place_index_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_base_and_derived_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_class_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_function_pointer_tester {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_member_function_pointer_tester {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct nat {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct param_any {
                pub _bindgen_opaque_blob: u8,
            }
            extern "C" {
                #[link_name = "\u{1}??0param_any@Internal@AZStd@@QEAA@ZZ"]
                pub fn param_any_param_any(this: *mut root::AZStd::Internal::param_any, ...);
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct check_complete_type {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct member_pointer_class_type {
                pub _address: u8,
            }
            pub type member_pointer_class_type_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct invocable_r {
                pub _address: u8,
            }
            pub type invocable_r_result_type = u8;
            pub type invocable_r_type = u8;
            pub type invocable = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_dtor_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_ctor_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_assign_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_copy_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct destroy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct construct {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_copy_helper {
                pub _address: u8,
            }
            pub type is_fast_copy_helper_value_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_copy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_fill_helper {
                pub _address: u8,
            }
            pub type is_fast_fill_helper_value_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_fill {
                pub _address: u8,
            }
            pub mod function_util {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct X {
                    _unused: [u8; 0],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Copy, Clone)]
                pub union function_buffer {
                    pub _bindgen_opaque_blob: [u64; 4usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_type_t {
                    pub _bindgen_opaque_blob: [u64; 2usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_bound_memfunc_ptr_t {
                    pub _bindgen_opaque_blob: [u64; 4usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_obj_ref_t {
                    pub _bindgen_opaque_blob: [u64; 2usize],
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct unusable {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct function_return_type {
                    pub _address: u8,
                }
                pub type function_return_type_type = u8;
                pub const functor_manager_operation_type_clone_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 0;
                pub const functor_manager_operation_type_move_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 1;
                pub const functor_manager_operation_type_destroy_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 2;
                pub const functor_manager_operation_type_check_functor_type_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 3;
                pub const functor_manager_operation_type_get_functor_type_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 4;
                pub type functor_manager_operation_type = i32;
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_ptr_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_obj_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct member_ptr_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_obj_ref_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct get_function_tag {
                    pub _address: u8,
                }
                pub type get_function_tag_ptr_or_obj_tag = u8;
                pub type get_function_tag_ptr_or_obj_or_mem_tag = u8;
                pub type get_function_tag_or_ref_tag = u8;
                pub type get_function_tag_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct reference_manager {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct function_allows_small_object_optimization {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_wrapper {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager_common {
                    pub _address: u8,
                }
                pub type functor_manager_common_functor_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager {
                    pub _address: u8,
                }
                pub type functor_manager_functor_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager_a {
                    pub _address: u8,
                }
                pub type functor_manager_a_functor_type = u8;
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct useless_clear_type {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct vtable_base {
                    pub _bindgen_opaque_blob: u64,
                }
                pub type vtable_base_type = [u32; 0usize];
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct invoke_void_return_wrapper {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct get_invoker {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct basic_vtable {
                    pub _address: u8,
                }
                pub type basic_vtable_invoker_type = u8;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_gcd_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_lcm_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_abs_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_sign_value: root::AZ::s64;
            }
            pub const ll_mul_nan: root::AZ::s64 = -9223372036854775808;
            extern "C" {
                #[link_name = "\u{1}min"]
                pub static ll_mul_min: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}max"]
                pub static ll_mul_max: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}a_x"]
                pub static ll_mul_a_x: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}a_y"]
                pub static ll_mul_a_y: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}test1"]
                pub static mut ll_mul_test1: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test2"]
                pub static mut ll_mul_test2: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test"]
                pub static mut ll_mul_test: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ll_mul_value: root::AZ::s64;
            }
            pub const ll_div_nan: root::AZ::s64 = -9223372036854775808;
            extern "C" {
                #[link_name = "\u{1}min"]
                pub static ll_div_min: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}max"]
                pub static ll_div_max: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}test1"]
                pub static mut ll_div_test1: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test2"]
                pub static mut ll_div_test2: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test3"]
                pub static mut ll_div_test3: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ll_div_value: root::AZ::s64;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ratio_gcd {
                pub _address: u8,
            }
            pub type ratio_gcd_type = u8;
            pub type common_ternary_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_2_default {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_2_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_multi_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_move_t {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_info {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_info_impl {}
            extern "C" {
                #[link_name = "\u{1}?create_thread@Internal@AZStd@@YAPEAXPEBUthread_desc@2@PEAVthread_info@12@PEAI@Z"]
                pub fn create_thread(
                    desc: *const root::AZStd::thread_desc,
                    ti: *mut root::AZStd::Internal::thread_info,
                    id: *mut ::std::os::raw::c_uint,
                ) -> root::HANDLE;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_convertible {
                pub _address: u8,
            }
            pub type sp_convertible_yes = u8;
            pub type sp_convertible_no = [u8; 2usize];
            pub const sp_convertible__vt_value: root::AZStd::Internal::sp_convertible__vt = 0;
            pub type sp_convertible__vt = i32;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_empty {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_enable_if_convertible {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Copy, Clone)]
            pub union OptionalDestructBase__bindgen_ty_1 {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct OptionalImplBase {
                pub _address: u8,
            }
            pub type OptionalImplBase_base = u8;
            pub type OptionalCopyBase_base = u8;
            pub type OptionalMoveBase_base = u8;
            pub type OptionalCopyAssignBase_base = u8;
            pub type OptionalMoveAssignBase_base = u8;
            pub type OptionalSFINAECtorBase_t = u8;
            pub type OptionalSFINAEAssignBase_t = u8;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct list_node_base {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct list_node {
                pub _address: u8,
            }
            pub type hash_table_storage_this_type = u8;
            pub type hash_table_storage_allocator_type = u8;
            pub type hash_table_storage_list_type = u8;
            pub type hash_table_storage_size_type = u8;
            pub type hash_table_storage_vector_value_type = u8;
            pub type hash_table_storage_vector_type = u8;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct rbtree_node_base {
                pub _bindgen_opaque_blob: [u64; 3usize],
            }
            pub type rbtree_node_base_color_type = u32;
            pub type rbtree_node_base_BaseNodePtr = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct rbtree_node {
                pub _address: u8,
            }
            pub type UnorderedMapTableTraits_key_type = u8;
            pub type UnorderedMapTableTraits_key_eq = u8;
            pub type UnorderedMapTableTraits_hasher = u8;
            pub type UnorderedMapTableTraits_value_type = u8;
            pub type UnorderedMapTableTraits_allocator_type = u8;
            pub const UnorderedMapTableTraits_max_load_factor:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_min_buckets:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_has_multi_elements:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_is_dynamic:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_fixed_num_buckets:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_fixed_num_elements:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub type UnorderedMapTableTraits__bindgen_ty_1 = i32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertKeyType {
                pub _address: u8,
            }
            pub type ConvertKeyType_key_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pack_traits_arg_sequence {
                pub _address: u8,
            }
            pub type pack_traits_get_arg_t = u8;
            pub const qualifier_flags_default_: root::AZStd::Internal::qualifier_flags = 0;
            pub const qualifier_flags_const_: root::AZStd::Internal::qualifier_flags = 1;
            pub const qualifier_flags_volatile_: root::AZStd::Internal::qualifier_flags = 2;
            pub const qualifier_flags_lvalue_ref: root::AZStd::Internal::qualifier_flags = 4;
            pub const qualifier_flags_rvalue_ref: root::AZStd::Internal::qualifier_flags = 8;
            pub const qualifier_flags_const_volatile: root::AZStd::Internal::qualifier_flags = 3;
            pub const qualifier_flags_const_lvalue_ref: root::AZStd::Internal::qualifier_flags = 5;
            pub const qualifier_flags_const_rvalue_ref: root::AZStd::Internal::qualifier_flags = 9;
            pub const qualifier_flags_volatile_lvalue_ref: root::AZStd::Internal::qualifier_flags =
                6;
            pub const qualifier_flags_volatile_rvalue_ref: root::AZStd::Internal::qualifier_flags =
                10;
            pub const qualifier_flags_const_volatile_lvalue_ref:
                root::AZStd::Internal::qualifier_flags = 7;
            pub const qualifier_flags_const_volatile_rvalue_ref:
                root::AZStd::Internal::qualifier_flags = 11;
            pub type qualifier_flags = u32;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct error_type {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_call_operator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct default_traits {
                pub _address: u8,
            }
            pub type default_traits_type = u8;
            pub type default_traits_class_type = u8;
            pub type default_traits_invoke_type = u8;
            pub type default_traits_return_type = u8;
            pub type default_traits_arg_types = u8;
            pub type default_traits_non_invoke_arg_types = u8;
            pub type default_traits_function_object_signature = u8;
            pub type default_traits_function_type = u8;
            pub type default_traits_expand_args = u8;
            pub type default_traits_class_fp_type = u8;
            pub type default_traits_raw_fp_type = u8;
            pub type default_traits_result_type = u8;
            pub type default_traits_get_arg_t = u8;
            pub type default_traits_arg_sequence = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pointer_to_member_function {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pointer_to_member_data {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct raw_function {
                pub _address: u8,
            }
            pub type callable_traits = u8;
            pub type UnorderedSetTableTraits_key_type = u8;
            pub type UnorderedSetTableTraits_key_eq = u8;
            pub type UnorderedSetTableTraits_hasher = u8;
            pub type UnorderedSetTableTraits_value_type = u8;
            pub type UnorderedSetTableTraits_allocator_type = u8;
            pub const UnorderedSetTableTraits_max_load_factor:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_min_buckets:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_has_multi_elements:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_is_dynamic:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_fixed_num_buckets:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_fixed_num_elements:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub type UnorderedSetTableTraits__bindgen_ty_1 = i32;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_arithmetic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_same {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_reference {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_enum {
            pub _address: u8,
        }
        pub type remove_cv_t = root::std::remove_cv_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_scalar {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_pod {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct alignment_of {
            pub _address: u8,
        }
        pub type aligned_storage_type = u8;
        pub type aligned_storage_t = u8;
        pub type aligned_storage_for_t = root::AZStd::aligned_storage_t;
        pub mod Utils {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type if_c_type<T1> = T1;
        }
        pub type conditional_type<T2> = T2;
        pub type conditional_t = u8;
        pub type enable_if_t = u8;
        pub type remove_reference_t = root::std::remove_reference;
        pub type remove_const_t = root::std::remove_const_t;
        pub type add_lvalue_reference_t = root::std::add_lvalue_reference;
        pub type add_rvalue_reference_t = root::std::add_rvalue_reference;
        pub type decay_t = root::std::decay;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_reference_wrapper {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unwrap_reference {
            pub _address: u8,
        }
        pub type unwrap_reference_type = root::std::decay;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_array {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_abstract {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_convertible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_lvalue_reference {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_delete {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}size"]
            pub static index_sequence_size: usize;
        }
        pub type make_index_sequence = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct piecewise_construct_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<T1, T2> {
            pub first: T1,
            pub second: T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T2>>,
        }
        pub type pair_this_type<T1, T2> = root::AZStd::pair<T1, T2>;
        pub type pair_first_type<T1> = T1;
        pub type pair_second_type<T2> = T2;
        pub type pair_TT1 = root::std::remove_reference;
        pub type pair_TT2 = root::std::remove_reference;
        pub type RemoveEnum_type = root::std::underlying_type;
        pub type RemoveEnumT = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleLambdaPointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveFunctionConst {
            pub _address: u8,
        }
        pub type RemoveFunctionConst_type = root::AZStd::HandleLambdaPointer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sequence_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sequence_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_type_t {
            pub _address: u8,
        }
        pub type native_mutex_data_type = [u64; 5usize];
        pub type native_mutex_handle_type = *mut root::CRITICAL_SECTION;
        pub type native_recursive_mutex_data_type = root::AZStd::native_mutex_data_type;
        pub type native_recursive_mutex_handle_type = *mut root::CRITICAL_SECTION;
        pub type native_cond_var_data_type = u8;
        pub type native_cond_var_handle_type = *mut root::CONDITION_VARIABLE;
        pub type native_semaphore_data_type = root::HANDLE;
        pub type native_semaphore_handle_type = root::HANDLE;
        pub type native_thread_id_type = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct native_thread_data_type {
            pub m_handle: root::HANDLE,
            pub m_id: root::AZStd::native_thread_id_type,
        }
        pub type native_thread_handle_type = root::HANDLE;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_id {
            pub m_id: root::AZStd::native_thread_id_type,
        }
        pub type atomic_char = root::std::atomic;
        pub type atomic_uchar = root::std::atomic;
        pub type atomic_wchar_t = root::std::atomic;
        pub type atomic_short = root::std::atomic;
        pub type atomic_ushort = root::std::atomic;
        pub type atomic_int = root::std::atomic;
        pub type atomic_uint = root::std::atomic;
        pub type atomic_long = root::std::atomic;
        pub type atomic_ulong = root::std::atomic;
        pub type atomic_llong = root::std::atomic;
        pub type atomic_ullong = root::std::atomic;
        pub type atomic_size_t = root::std::atomic;
        pub type atomic_ptrdiff_t = root::std::atomic;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_destruct {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_destruct {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct static_storage {
            pub m_storage: u8,
            pub m_object: root::std::atomic,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_base_and_derived {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_base_of {
            pub _address: u8,
        }
        pub type remove_pointer_t = root::std::remove_pointer_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_class {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_function_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_object_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable_r {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct invoke_result {
            pub _address: u8,
        }
        pub type invoke_result_t = root::AZStd::invoke_result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        pub type hash_argument_type<T> = T;
        pub type hash_result_type = usize;
        pub type DefaultHashResultType_type = root::std::true_type;
        pub type HasDefaultHash_Yes = ::std::os::raw::c_char;
        pub type HasDefaultHash_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasDefaultHash_Helper {
            pub _address: u8,
        }
        pub type HasDefaultHash_Helper_mfp = ::std::option::Option<unsafe extern "C" fn() -> bool>;
        pub type HasDefaultHash_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasSpecializedHasher {
            pub _address: u8,
        }
        pub type HasSpecializedHasher_type = u8;
        extern "C" {
            #[link_name = "\u{1}?hash_next_bucket_size@AZStd@@YA_K_K@Z"]
            pub fn hash_next_bucket_size(n: usize) -> usize;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct continuous_random_access_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_value_type<T> = T;
        pub type iterator_difference_type<Distance> = Distance;
        pub type iterator_pointer<Pointer> = Pointer;
        pub type iterator_reference<Reference> = Reference;
        pub type iterator_iterator_category<Category> = Category;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        pub type iterator_traits_iterator_category = [u8; 0usize];
        pub type iterator_traits_value_type = [u8; 0usize];
        pub type iterator_traits_difference_type = [u8; 0usize];
        pub type iterator_traits_pointer = [u8; 0usize];
        pub type iterator_traits_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<Iterator> {
            pub m_current: Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub type reverse_iterator_this_type<Iterator> = root::AZStd::reverse_iterator<Iterator>;
        pub type reverse_iterator_iterator_type<Iterator> = Iterator;
        pub type reverse_iterator_reference = root::AZStd::iterator_traits;
        pub type reverse_iterator_pointer = root::AZStd::iterator_traits;
        pub type reverse_iterator_difference_type = root::AZStd::iterator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct move_iterator<Iterator> {
            pub m_current: root::AZStd::move_iterator_iterator_type<Iterator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub type move_iterator_iterator_base = root::AZStd::iterator;
        pub type move_iterator_reference = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_pointer = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_difference_type = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_this_type<Iterator> = root::AZStd::move_iterator<Iterator>;
        pub type move_iterator_iterator_type<Iterator> = Iterator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct back_insert_iterator<Container> {
            pub m_container: *mut Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type back_insert_iterator_this_type<Container> =
            root::AZStd::back_insert_iterator<Container>;
        pub type back_insert_iterator_container_type<Container> = Container;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct front_insert_iterator<Container> {
            pub m_container: *mut Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type front_insert_iterator_this_type<Container> =
            root::AZStd::front_insert_iterator<Container>;
        pub type front_insert_iterator_container_type<Container> = Container;
        #[repr(C)]
        pub struct insert_iterator<Container> {
            pub m_container: *mut Container,
            pub m_iterator: root::AZStd::insert_iterator_container_iterator_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type insert_iterator_this_type<Container> = root::AZStd::insert_iterator<Container>;
        pub type insert_iterator_container_type<Container> = Container;
        pub type insert_iterator_container_iterator_type = [u8; 0usize];
        pub const iterator_status_flag_isf_none: root::AZStd::iterator_status_flag = 0;
        pub const iterator_status_flag_isf_valid: root::AZStd::iterator_status_flag = 1;
        pub const iterator_status_flag_isf_can_dereference: root::AZStd::iterator_status_flag = 2;
        pub const iterator_status_flag_isf_current: root::AZStd::iterator_status_flag = 4;
        pub type iterator_status_flag = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_continuous_random_access_iterator_cat {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<Element> {
            pub m_begin: root::AZStd::basic_string_view_const_pointer<Element>,
            pub m_end: root::AZStd::basic_string_view_const_pointer<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type basic_string_view_traits_type<Traits> = Traits;
        pub type basic_string_view_value_type<Element> = Element;
        pub type basic_string_view_pointer<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_pointer<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reference<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_reference<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        pub type basic_string_view_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_iterator<Element>>;
        pub type basic_string_view_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_const_iterator<Element>>;
        pub type string_view = root::AZStd::basic_string_view<::std::os::raw::c_char>;
        pub type wstring_view = root::AZStd::basic_string_view<u16>;
        pub type basic_const_string<Element> = root::AZStd::basic_string_view<Element>;
        pub type const_string = root::AZStd::string_view;
        pub type const_wstring = root::AZStd::wstring_view;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_list {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct shared_ptr {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct monostate {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct variant {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_allow_memory_leaks = root::std::false_type;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@allocator@AZStd@@QEAAXXZ"]
            pub fn allocator_TYPEINFO_Enable(this: *mut root::AZStd::allocator);
        }
        extern "C" {
            #[link_name = "\u{1}?allocate@allocator@AZStd@@QEAAPEAX_K0H@Z"]
            pub fn allocator_allocate(
                this: *mut root::AZStd::allocator,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@allocator@AZStd@@QEAAXPEAX_K1@Z"]
            pub fn allocator_deallocate(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?resize@allocator@AZStd@@QEAA_KPEAX_K@Z"]
            pub fn allocator_resize(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_max_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_max_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_allocated_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_allocated_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        impl allocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                allocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn allocate(
                &mut self,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type {
                allocator_allocate(self, byteSize, alignment, flags)
            }
            #[inline]
            pub unsafe fn deallocate(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            ) {
                allocator_deallocate(self, ptr, byteSize, alignment)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type {
                allocator_resize(self, ptr, newSize)
            }
            #[inline]
            pub unsafe fn get_max_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_max_size(self)
            }
            #[inline]
            pub unsafe fn get_allocated_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_allocated_size(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_default_allocator {
            pub _address: u8,
        }
        pub type no_default_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type no_default_allocator_size_type = usize;
        pub type no_default_allocator_difference_type = isize;
        pub type no_default_allocator_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bad_function_call {
            _unused: [u8; 0],
        }
        pub type type_id = *mut ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct type_id_holder {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cvref {
            pub _address: u8,
        }
        pub type remove_cvref_type = root::AZStd::remove_cv_t;
        pub type remove_cvref_t = root::AZStd::remove_cvref;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_destructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_constructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_default_constructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_assign {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_copy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function_base {
            pub vtable: *mut root::AZStd::Internal::function_util::vtable_base,
            pub functor: root::AZStd::Internal::function_util::function_buffer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct function_intermediate {
            pub _base: root::AZStd::function_base,
        }
        pub type function_intermediate_result_type<R> = R;
        pub type function_intermediate_vtable_type = u8;
        pub type function_intermediate_self_type = root::AZStd::function_intermediate;
        pub type atto = u8;
        pub type femto = u8;
        pub type pico = u8;
        pub type nano = u8;
        pub type micro = u8;
        pub type milli = u8;
        pub type centi = u8;
        pub type deci = u8;
        pub type deca = u8;
        pub type hecto = u8;
        pub type kilo = u8;
        pub type mega = u8;
        pub type giga = u8;
        pub type tera = u8;
        pub type peta = u8;
        pub type exa = u8;
        extern "C" {
            #[link_name = "\u{1}test1"]
            pub static mut ratio_test1: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}test2"]
            pub static mut ratio_test2: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}m_na"]
            pub static ratio_m_na: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_da"]
            pub static ratio_m_da: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_s"]
            pub static ratio_m_s: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_gcd"]
            pub static ratio_m_gcd: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::AZ::s64;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_add {
            pub _address: u8,
        }
        pub type ratio_add_type = root::AZStd::ratio_multiply;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_subtract {
            pub _address: u8,
        }
        pub type ratio_subtract_type = root::AZStd::ratio_multiply;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_multiply {
            pub _address: u8,
        }
        pub type ratio_multiply_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_divide {
            pub _address: u8,
        }
        pub type ratio_divide_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_not_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_less_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_greater_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_void {
            pub _address: u8,
        }
        pub type make_void_type = ::std::os::raw::c_void;
        pub type void_t = root::AZStd::make_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct common_type {
            pub _address: u8,
        }
        pub type common_type_t = root::AZStd::common_type;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_value {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct is_duration {
                    pub _base: root::std::false_type,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_eq {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_lt {
                    pub _address: u8,
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct treat_as_floating_point {
                pub _base: root::AZStd::is_floating_point,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct duration<Rep> {
                pub m_rep: root::AZStd::chrono::duration_rep<Rep>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Rep>>,
            }
            pub type duration_rep<Rep> = Rep;
            pub type duration_period<Period> = Period;
            pub type nanoseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type microseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type milliseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type seconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type minutes = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type hours = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct time_point<Duration> {
                pub m_d: root::AZStd::chrono::time_point_duration<Duration>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Duration>>,
            }
            pub type time_point_clock<Clock> = Clock;
            pub type time_point_duration<Duration> = Duration;
            pub type time_point_rep = [u8; 0usize];
            pub type time_point_period = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct system_clock {
                pub _address: u8,
            }
            pub type system_clock_duration = root::AZStd::chrono::microseconds;
            pub type system_clock_rep = root::rep;
            pub type system_clock_period = u8;
            pub type system_clock_time_point = root::AZStd::chrono::time_point<
                root::AZStd::chrono::duration<::std::os::raw::c_longlong>,
            >;
            pub const system_clock_is_monotonic: bool = true;
            pub type monotonic_clock = root::AZStd::chrono::system_clock;
            pub type high_resolution_clock = root::AZStd::chrono::monotonic_clock;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_desc {
            pub m_stack: *mut ::std::os::raw::c_void,
            pub m_stackSize: ::std::os::raw::c_int,
            pub m_priority: ::std::os::raw::c_int,
            pub m_cpuId: ::std::os::raw::c_int,
            pub m_isJoinable: bool,
            pub m_name: *const ::std::os::raw::c_char,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct thread {
            pub m_thread: root::AZStd::native_thread_data_type,
        }
        pub type thread_native_handle_type = root::AZStd::native_thread_handle_type;
        extern "C" {
            #[link_name = "\u{1}?joinable@thread@AZStd@@QEBA_NXZ"]
            pub fn thread_joinable(this: *const root::AZStd::thread) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?join@thread@AZStd@@QEAAXXZ"]
            pub fn thread_join(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}?detach@thread@AZStd@@QEAAXXZ"]
            pub fn thread_detach(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}?get_id@thread@AZStd@@QEBA?AUthread_id@2@XZ"]
            pub fn thread_get_id(this: *const root::AZStd::thread) -> root::AZStd::thread_id;
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@thread@AZStd@@QEAAPEAXXZ"]
            pub fn thread_native_handle(
                this: *mut root::AZStd::thread,
            ) -> root::AZStd::thread_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}?hardware_concurrency@thread@AZStd@@SAIXZ"]
            pub fn thread_hardware_concurrency() -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[link_name = "\u{1}??0thread@AZStd@@QEAA@XZ"]
            pub fn thread_thread(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}??0thread@AZStd@@QEAA@U?$thread_move_t@Vthread@AZStd@@@Internal@1@@Z"]
            pub fn thread_thread1(this: *mut root::AZStd::thread, rhs: u64);
        }
        extern "C" {
            #[link_name = "\u{1}??_Dthread@AZStd@@QEAAXXZ"]
            pub fn thread_thread_destructor(this: *mut root::AZStd::thread);
        }
        impl thread {
            #[inline]
            pub unsafe fn joinable(&self) -> bool {
                thread_joinable(self)
            }
            #[inline]
            pub unsafe fn join(&mut self) {
                thread_join(self)
            }
            #[inline]
            pub unsafe fn detach(&mut self) {
                thread_detach(self)
            }
            #[inline]
            pub unsafe fn get_id(&self) -> root::AZStd::thread_id {
                thread_get_id(self)
            }
            #[inline]
            pub unsafe fn native_handle(&mut self) -> root::AZStd::thread_native_handle_type {
                thread_native_handle(self)
            }
            #[inline]
            pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
                thread_hardware_concurrency()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(rhs: u64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread1(__bindgen_tmp.as_mut_ptr(), rhs);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                thread_thread_destructor(self)
            }
        }
        pub mod this_thread {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}?get_id@this_thread@AZStd@@YA?AUthread_id@2@XZ"]
                pub fn get_id() -> root::AZStd::thread_id;
            }
            extern "C" {
                #[link_name = "\u{1}?yield@this_thread@AZStd@@YAXXZ"]
                pub fn yield_();
            }
            extern "C" {
                #[link_name = "\u{1}?pause@this_thread@AZStd@@YAXH@Z"]
                pub fn pause(numLoops: ::std::os::raw::c_int);
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntrusivePtrCountPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct intrusive_ptr<T> {
            pub px: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_ptr_this_type<T> = root::AZStd::intrusive_ptr<T>;
        pub type intrusive_ptr_CountPolicy = root::AZStd::IntrusivePtrCountPolicy;
        pub type intrusive_ptr_element_type<T> = T;
        pub type intrusive_ptr_value_type<T> = T;
        pub type intrusive_ptr_unspecified_bool_type<T> = *mut *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct upgrade_lock {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct defer_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct try_to_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct adopt_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct lock_guard<Mutex> {
            pub m_mutex: *mut root::AZStd::lock_guard_mutex_type<Mutex>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type lock_guard_mutex_type<Mutex> = Mutex;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_lock<Mutex> {
            pub m_mutex: *mut root::AZStd::unique_lock_mutex_type<Mutex>,
            pub m_owns: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type unique_lock_mutex_type<Mutex> = Mutex;
        #[repr(C)]
        #[derive(Debug)]
        pub struct shared_lock<Mutex> {
            pub m_mutex: *mut root::AZStd::shared_lock_mutex_type<Mutex>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type shared_lock_mutex_type<Mutex> = Mutex;
        pub const deque_block_num_elements: root::AZStd::deque_block__bindgen_ty_1 = 0;
        pub type deque_block__bindgen_ty_1 = i32;
        pub const deque_CONTAINER_VERSION: root::AZStd::deque__bindgen_ty_1 = 0;
        pub type deque__bindgen_ty_1 = i32;
        pub type deque_this_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque_block_node {
            pub m_data: u8,
        }
        pub type deque_pointer<T> = *mut T;
        pub type deque_const_pointer<T> = *const T;
        pub type deque_reference<T> = *mut T;
        pub type deque_const_reference<T> = *const T;
        pub type deque_difference_type = [u8; 0usize];
        pub type deque_size_type = [u8; 0usize];
        pub type deque_allocator_type<Allocator> = Allocator;
        pub type deque_value_type<T> = T;
        pub type deque_block_node_type = root::AZStd::deque_block_node;
        pub type deque_map_node_type<T> = root::AZStd::deque_pointer<T>;
        pub type deque_map_node_ptr_type<T> = *mut root::AZStd::deque_map_node_type<T>;
        #[repr(C)]
        pub struct deque_const_iterator_impl {
            pub m_offset: root::AZStd::deque_size_type,
            pub m_container: *const root::AZStd::deque_const_iterator_impl_container_type,
        }
        pub const deque_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::deque_const_iterator_impl__bindgen_ty_1 = 0;
        pub type deque_const_iterator_impl__bindgen_ty_1 = i32;
        pub type deque_const_iterator_impl_this_type = root::AZStd::deque_const_iterator_impl;
        pub type deque_const_iterator_impl_container_type = u8;
        pub type deque_const_iterator_impl_value_type<T> = T;
        pub type deque_const_iterator_impl_difference_type = isize;
        pub type deque_const_iterator_impl_pointer<T> = *const T;
        pub type deque_const_iterator_impl_reference<T> = *const T;
        pub type deque_const_iterator_impl_iterator_category =
            root::AZStd::random_access_iterator_tag;
        #[repr(C)]
        pub struct deque_iterator_impl {
            pub _base: root::AZStd::deque_const_iterator_impl,
        }
        pub type deque_iterator_impl_this_type = root::AZStd::deque_iterator_impl;
        pub type deque_iterator_impl_base_type = root::AZStd::deque_const_iterator_impl;
        pub type deque_iterator_impl_container_type = u8;
        pub type deque_iterator_impl_pointer<T> = *mut T;
        pub type deque_iterator_impl_reference<T> = *mut T;
        pub type deque_iterator_impl_difference_type = isize;
        pub type deque_iterator = root::AZStd::deque_iterator_impl;
        pub type deque_const_iterator = root::AZStd::deque_const_iterator_impl;
        pub type deque_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::deque_iterator>;
        pub type deque_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::deque_const_iterator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector<T, Allocator> {
            pub m_start: root::AZStd::vector_pointer<T>,
            pub m_last: root::AZStd::vector_pointer<T>,
            pub m_end: root::AZStd::vector_pointer<T>,
            pub m_allocator: root::AZStd::vector_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub const vector_CONTAINER_VERSION: root::AZStd::vector__bindgen_ty_1 = 0;
        pub type vector__bindgen_ty_1 = i32;
        pub type vector_this_type<T, Allocator> = root::AZStd::vector<T, Allocator>;
        pub type vector_pointer<T> = *mut T;
        pub type vector_const_pointer<T> = *const T;
        pub type vector_reference<T> = *mut T;
        pub type vector_const_reference<T> = *const T;
        pub type vector_difference_type = [u8; 0usize];
        pub type vector_size_type = [u8; 0usize];
        pub type vector_iterator_impl<T> = root::AZStd::vector_pointer<T>;
        pub type vector_const_iterator_impl<T> = root::AZStd::vector_const_pointer<T>;
        pub type vector_iterator<T> = root::AZStd::vector_iterator_impl<T>;
        pub type vector_const_iterator<T> = root::AZStd::vector_const_iterator_impl<T>;
        pub type vector_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_iterator<T>>;
        pub type vector_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_const_iterator<T>>;
        pub type vector_value_type<T> = T;
        pub type vector_allocator_type<Allocator> = Allocator;
        pub type vector_node_type<T> = root::AZStd::vector_value_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct queue<Container> {
            pub m_container: Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub const queue_CONTAINER_VERSION: root::AZStd::queue__bindgen_ty_1 = 0;
        pub type queue__bindgen_ty_1 = i32;
        pub type queue_this_type<Container> = root::AZStd::queue<Container>;
        pub type queue_container_type<Container> = Container;
        pub type queue_value_type = [u8; 0usize];
        pub type queue_size_type = [u8; 0usize];
        pub type queue_reference = [u8; 0usize];
        pub type queue_const_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct priority_queue<Container, Predicate> {
            pub m_container: Container,
            pub m_comp: Predicate,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Predicate>>,
        }
        pub const priority_queue_CONTAINER_VERSION: root::AZStd::priority_queue__bindgen_ty_1 = 0;
        pub type priority_queue__bindgen_ty_1 = i32;
        pub type priority_queue_this_type<Container, Predicate> =
            root::AZStd::priority_queue<Container, Predicate>;
        pub type priority_queue_container_type<Container> = Container;
        pub type priority_queue_value_type = [u8; 0usize];
        pub type priority_queue_size_type = [u8; 0usize];
        pub type priority_queue_reference = [u8; 0usize];
        pub type priority_queue_const_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_node<T> {
            pub m_children: [*mut T; 2usize],
            pub m_neighbours: [*mut T; 2usize],
            pub m_parentColorSide: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_multiset_node_ColorType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_SideType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_this_type<T> = root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_node_node_ptr_type<T> = *mut T;
        pub const intrusive_multiset_node_Bits_BIT_COLOR:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_PARENT_SIDE:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_MASK: root::AZStd::intrusive_multiset_node_Bits =
            0;
        pub type intrusive_multiset_node_Bits = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_base_hook {
            pub _address: u8,
        }
        pub type intrusive_multiset_base_hook_pointer<T> = *mut T;
        pub type intrusive_multiset_base_hook_const_pointer<T> = *const T;
        pub type intrusive_multiset_base_hook_node_type<T> =
            root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_base_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_base_hook_node_type<T>;
        pub type intrusive_multiset_base_hook_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_base_hook_node_type<T>;
        pub type intrusive_multiset_member_hook_pointer<T> = *mut T;
        pub type intrusive_multiset_member_hook_const_pointer<T> = *const T;
        pub type intrusive_multiset_member_hook_node_type<T> =
            root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_member_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_member_hook_node_type<T>;
        pub type intrusive_multiset_member_hook_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_member_hook_node_type<T>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct intrusive_multiset<Compare> {
            pub m_head: u8,
            pub m_numElements: usize,
            pub m_keyCompare: root::AZStd::intrusive_multiset_KeyCompare<Compare>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Compare>>,
        }
        pub const intrusive_multiset_CONTAINER_VERSION:
            root::AZStd::intrusive_multiset__bindgen_ty_1 = 0;
        pub type intrusive_multiset__bindgen_ty_1 = i32;
        pub type intrusive_multiset_this_type<Compare> = root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_SideType = ::std::os::raw::c_int;
        pub type intrusive_multiset_pointer<T> = *mut T;
        pub type intrusive_multiset_const_pointer<T> = *const T;
        pub type intrusive_multiset_reference<T> = *mut T;
        pub type intrusive_multiset_const_reference<T> = *const T;
        pub type intrusive_multiset_difference_type = usize;
        pub type intrusive_multiset_size_type = usize;
        pub type intrusive_multiset_KeyType = [u8; 0usize];
        pub type intrusive_multiset_KeyCompare<Compare> = Compare;
        pub type intrusive_multiset_value_type<T> = T;
        pub type intrusive_multiset_node_type<T> = T;
        pub type intrusive_multiset_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_node_type<T>;
        pub type intrusive_multiset_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_node_type<T>;
        pub type intrusive_multiset_hook_node_type<T> = root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_hook_node_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_const_iterator_impl<T> {
            pub m_node: root::AZStd::intrusive_multiset_node_ptr_type<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub const intrusive_multiset_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::intrusive_multiset_const_iterator_impl__bindgen_ty_1 = 0;
        pub type intrusive_multiset_const_iterator_impl__bindgen_ty_1 = i32;
        pub type intrusive_multiset_const_iterator_impl_this_type<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_const_iterator_impl_tree_type<Compare> =
            root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_const_iterator_impl_value_type<T> = T;
        pub type intrusive_multiset_const_iterator_impl_difference_type = isize;
        pub type intrusive_multiset_const_iterator_impl_pointer<T> = *const T;
        pub type intrusive_multiset_const_iterator_impl_reference<T> = *const T;
        pub type intrusive_multiset_const_iterator_impl_iterator_category =
            root::AZStd::bidirectional_iterator_tag;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_iterator_impl<T> {
            pub _base: root::AZStd::intrusive_multiset_const_iterator_impl<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_multiset_iterator_impl_this_type<T> =
            root::AZStd::intrusive_multiset_iterator_impl<T>;
        pub type intrusive_multiset_iterator_impl_base_type<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_iterator_impl_value_type<T> = T;
        pub type intrusive_multiset_iterator_impl_pointer<T> = *mut T;
        pub type intrusive_multiset_iterator_impl_reference<T> = *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_reverse_iterator_impl {
            pub m_node: root::AZStd::intrusive_multiset_reverse_iterator_impl_pointer,
            pub m_headNode: *const root::AZStd::intrusive_multiset_reverse_iterator_impl_value_type,
        }
        pub type intrusive_multiset_reverse_iterator_impl_this_type =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        pub type intrusive_multiset_reverse_iterator_impl_tree_type<Compare> =
            root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_reverse_iterator_impl_value_type = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_difference_type =
            root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_pointer = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_reference = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_iterator_category =
            root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_iterator_type<Iter> = Iter;
        pub type intrusive_multiset_iterator<T> = root::AZStd::intrusive_multiset_iterator_impl<T>;
        pub type intrusive_multiset_const_iterator<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_reverse_iterator =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        pub type intrusive_multiset_const_reverse_iterator =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        #[repr(C)]
        #[derive(Debug)]
        pub struct mutex {
            pub m_mutex: root::AZStd::native_mutex_data_type,
        }
        pub type mutex_native_handle_type = root::AZStd::native_mutex_handle_type;
        extern "C" {
            #[link_name = "\u{1}?lock@mutex@AZStd@@QEAAXXZ"]
            pub fn mutex_lock(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@mutex@AZStd@@QEAA_NXZ"]
            pub fn mutex_try_lock(this: *mut root::AZStd::mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@mutex@AZStd@@QEAAXXZ"]
            pub fn mutex_unlock(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@mutex@AZStd@@QEAAPEAU_RTL_CRITICAL_SECTION@@XZ"]
            pub fn mutex_native_handle(
                this: *mut root::AZStd::mutex,
            ) -> root::AZStd::mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0mutex@AZStd@@QEAA@XZ"]
            pub fn mutex_mutex(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0mutex@AZStd@@QEAA@PEBD@Z"]
            pub fn mutex_mutex1(this: *mut root::AZStd::mutex, name: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}??_Dmutex@AZStd@@QEAAXXZ"]
            pub fn mutex_mutex_destructor(this: *mut root::AZStd::mutex);
        }
        impl mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(&mut self) -> root::AZStd::mutex_native_handle_type {
                mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                mutex_mutex(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                mutex_mutex1(__bindgen_tmp.as_mut_ptr(), name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                mutex_mutex_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct recursive_mutex {
            pub m_mutex: root::AZStd::native_recursive_mutex_data_type,
        }
        pub type recursive_mutex_native_handle_type =
            root::AZStd::native_recursive_mutex_handle_type;
        extern "C" {
            #[link_name = "\u{1}?lock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_lock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@recursive_mutex@AZStd@@QEAA_NXZ"]
            pub fn recursive_mutex_try_lock(this: *mut root::AZStd::recursive_mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_unlock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@recursive_mutex@AZStd@@QEAAPEAU_RTL_CRITICAL_SECTION@@XZ"]
            pub fn recursive_mutex_native_handle(
                this: *mut root::AZStd::recursive_mutex,
            ) -> root::AZStd::recursive_mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@XZ"]
            pub fn recursive_mutex_recursive_mutex(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@PEBD@Z"]
            pub fn recursive_mutex_recursive_mutex1(
                this: *mut root::AZStd::recursive_mutex,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_Drecursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_recursive_mutex_destructor(
                this: *mut root::AZStd::recursive_mutex,
            );
        }
        impl recursive_mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                recursive_mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                recursive_mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                recursive_mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(
                &mut self,
            ) -> root::AZStd::recursive_mutex_native_handle_type {
                recursive_mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                recursive_mutex_recursive_mutex(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                recursive_mutex_recursive_mutex1(__bindgen_tmp.as_mut_ptr(), name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                recursive_mutex_recursive_mutex_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeTicksPerSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeTicksPerSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowTicks@AZStd@@YA_JXZ"]
            pub fn GetTimeNowTicks() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowMicroSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeNowMicroSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeNowSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeUTCMilliSecond@AZStd@@YA_KXZ"]
            pub fn GetTimeUTCMilliSecond() -> root::AZ::u64;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct exponential_backoff {
            pub m_count: ::std::os::raw::c_int,
        }
        pub const exponential_backoff_MAX_PAUSE_LOOPS: ::std::os::raw::c_int = 32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct spin_mutex {
            pub m_flag: root::std::atomic,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_virtual_destructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct nullopt_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct nullopt_t_UniqueTag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional_base = u8;
        pub type optional_value_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_value_type {
            pub _address: u8,
        }
        pub type get_value_type_type = u8;
        pub type get_pointer_type_type<ValueType> = *mut ValueType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_pointer_type {
            pub _address: u8,
        }
        pub type get_const_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_void_pointer_type {
            pub _address: u8,
        }
        pub type get_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_void_pointer_type {
            pub _address: u8,
        }
        pub type get_const_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_difference_type {
            pub _address: u8,
        }
        pub type get_difference_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_size_type {
            pub _address: u8,
        }
        pub type get_size_type_type = root::std::make_unsigned;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_copy_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_copy_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_move_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_move_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_swap_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_swap_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_is_always_equal_type {
            pub _address: u8,
        }
        pub type get_is_always_equal_type_type = root::std::is_empty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_rebind {
            pub _base: root::std::false_type,
        }
        pub type get_rebind_type_type<Allocator> = Allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<Alloc> = Alloc;
        pub type allocator_traits_value_type = root::AZStd::get_value_type;
        pub type allocator_traits_pointer = u8;
        pub type allocator_traits_const_pointer = root::AZStd::get_const_pointer_type;
        pub type allocator_traits_void_pointer = root::AZStd::get_void_pointer_type;
        pub type allocator_traits_const_void_pointer = root::AZStd::get_const_void_pointer_type;
        pub type allocator_traits_difference_type = root::AZStd::get_difference_type;
        pub type allocator_traits_size_type = root::AZStd::get_size_type;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::AZStd::get_propagate_on_container_move_assignment_type;
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::AZStd::get_propagate_on_container_copy_assignment_type;
        pub type allocator_traits_propagate_on_container_swap =
            root::AZStd::get_propagate_on_container_swap_type;
        pub type allocator_traits_is_always_equal = root::AZStd::get_is_always_equal_type;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set_node_traits {
            pub _address: u8,
        }
        pub type set_node_traits_value_type<ValueType> = ValueType;
        pub type set_node_traits_allocator_type<AllocatorType> = AllocatorType;
        pub type set_node_traits_node_type<NodeType> = NodeType;
        pub type set_node_traits_node_deleter_type<NodeDeleterType> = NodeDeleterType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_node_traits {
            pub _address: u8,
        }
        pub type map_node_traits_key_type<KeyType> = KeyType;
        pub type map_node_traits_mapped_type<MappedType> = MappedType;
        pub type map_node_traits_allocator_type<AllocatorType> = AllocatorType;
        pub type map_node_traits_node_type<NodeType> = NodeType;
        pub type map_node_traits_node_deleter_type<NodeDeleterType> = NodeDeleterType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct insert_return_type<Iterator, NodeType> {
            pub position: Iterator,
            pub inserted: bool,
            pub node: NodeType,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<NodeType>>,
        }
        #[repr(C)]
        pub struct node_handle {
            pub m_node: root::AZStd::node_handle_node_pointer_type,
            pub m_allocator: root::AZStd::optional,
        }
        pub type node_handle_allocator_type = [u8; 0usize];
        pub type node_handle_allocator_traits = root::AZStd::allocator_traits;
        pub type node_handle_node_pointer_type = *mut [u8; 0usize];
        pub type node_handle_node_allocator_type = [u8; 0usize];
        pub type node_handle_node_deleter_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set_node_base {
            pub _address: u8,
        }
        pub type set_node_base_value_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_node_base {
            pub _address: u8,
        }
        pub type map_node_base_key_type = [u8; 0usize];
        pub type map_node_base_mapped_type = [u8; 0usize];
        pub type set_node_handle = root::AZStd::node_handle;
        pub type map_node_handle = root::AZStd::node_handle;
        pub const fixed_vector_CONTAINER_VERSION: root::AZStd::fixed_vector__bindgen_ty_1 = 0;
        pub type fixed_vector__bindgen_ty_1 = i32;
        pub type fixed_vector_this_type = u8;
        pub type fixed_vector_pointer<T> = *mut T;
        pub type fixed_vector_const_pointer<T> = *const T;
        pub type fixed_vector_reference<T> = *mut T;
        pub type fixed_vector_const_reference<T> = *const T;
        pub type fixed_vector_difference_type = isize;
        pub type fixed_vector_size_type = usize;
        pub type fixed_vector_iterator<T> = root::AZStd::fixed_vector_pointer<T>;
        pub type fixed_vector_const_iterator<T> = root::AZStd::fixed_vector_const_pointer<T>;
        pub type fixed_vector_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::fixed_vector_iterator<T>>;
        pub type fixed_vector_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::fixed_vector_const_iterator<T>>;
        pub type fixed_vector_value_type<T> = T;
        pub type fixed_vector_node_type<T> = root::AZStd::fixed_vector_value_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_const_iterator {
            pub m_node: root::AZStd::list_const_iterator_base_node_ptr_type,
        }
        pub const list_const_iterator_ITERATOR_VERSION:
            root::AZStd::list_const_iterator__bindgen_ty_1 = 0;
        pub type list_const_iterator__bindgen_ty_1 = i32;
        pub type list_const_iterator_this_type = root::AZStd::list_const_iterator;
        pub type list_const_iterator_value_type<T> = T;
        pub type list_const_iterator_difference_type = isize;
        pub type list_const_iterator_pointer<T> = *const T;
        pub type list_const_iterator_reference<T> = *const T;
        pub type list_const_iterator_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type list_const_iterator_node_type = u8;
        pub type list_const_iterator_node_ptr_type =
            *mut root::AZStd::list_const_iterator_node_type;
        pub type list_const_iterator_base_node_type = root::AZStd::Internal::list_node_base;
        pub type list_const_iterator_base_node_ptr_type =
            *mut root::AZStd::list_const_iterator_base_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_iterator {
            pub _base: root::AZStd::list_const_iterator,
        }
        pub type list_iterator_this_type = root::AZStd::list_iterator;
        pub type list_iterator_base_type = root::AZStd::list_const_iterator;
        pub type list_iterator_pointer<T> = *mut T;
        pub type list_iterator_reference<T> = *mut T;
        pub type list_iterator_node_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_node_ptr_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_base_node_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_base_node_ptr_type = root::AZStd::list_iterator_base_type;
        #[repr(C)]
        pub struct list<Allocator> {
            pub m_head: root::AZStd::list_base_node_type,
            pub m_numElements: root::AZStd::list_size_type,
            pub m_allocator: root::AZStd::list_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub const list_CONTAINER_VERSION: root::AZStd::list__bindgen_ty_1 = 0;
        pub type list__bindgen_ty_1 = i32;
        pub type list_this_type<Allocator> = root::AZStd::list<Allocator>;
        pub type list_pointer<T> = *mut T;
        pub type list_const_pointer<T> = *const T;
        pub type list_reference<T> = *mut T;
        pub type list_const_reference<T> = *const T;
        pub type list_difference_type = [u8; 0usize];
        pub type list_size_type = [u8; 0usize];
        pub type list_allocator_type<Allocator> = Allocator;
        pub type list_value_type<T> = T;
        pub type list_node_type = u8;
        pub type list_node_ptr_type = *mut root::AZStd::list_node_type;
        pub type list_base_node_type = root::AZStd::Internal::list_node_base;
        pub type list_base_node_ptr_type = *mut root::AZStd::list_base_node_type;
        pub type list_const_iterator_impl = root::AZStd::list_const_iterator;
        pub type list_iterator_impl = root::AZStd::list_iterator;
        pub type list_reverse_iterator = root::AZStd::reverse_iterator<root::AZStd::list_iterator>;
        pub type list_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::list_const_iterator>;
        pub type static_buffer_allocator_this_type = u8;
        pub type static_buffer_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type static_buffer_allocator_size_type = usize;
        pub type static_buffer_allocator_difference_type = isize;
        pub type static_buffer_allocator_allow_memory_leaks = root::std::true_type;
        pub type static_pool_allocator_this_type = u8;
        pub type static_pool_allocator_index_type = i32;
        #[repr(C)]
        pub union static_pool_allocator_pool_node {
            pub m_node: u8,
            pub m_index: root::AZStd::static_pool_allocator_index_type,
            _bindgen_union_align: u32,
        }
        pub type static_pool_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type static_pool_allocator_size_type = usize;
        pub type static_pool_allocator_difference_type = isize;
        pub type static_pool_allocator_allow_memory_leaks = root::std::false_type;
        pub const fixed_list_CONTAINER_VERSION: root::AZStd::fixed_list__bindgen_ty_1 = 0;
        pub type fixed_list__bindgen_ty_1 = i32;
        pub type fixed_list_this_type = u8;
        pub type fixed_list_base_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_ref<Allocator> {
            pub m_name: *const ::std::os::raw::c_char,
            pub m_allocator: root::AZStd::allocator_ref_allocator_pointer<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type allocator_ref_this_type<Allocator> = root::AZStd::allocator_ref<Allocator>;
        pub type allocator_ref_pointer_type = [u8; 0usize];
        pub type allocator_ref_size_type = [u8; 0usize];
        pub type allocator_ref_difference_type = [u8; 0usize];
        pub type allocator_ref_allow_memory_leaks = [u8; 0usize];
        pub type allocator_ref_allocator_pointer<Allocator> = *mut Allocator;
        pub type allocator_ref_allocator_reference<Allocator> = *mut Allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_node_destructor {
            pub m_allocator: *mut root::AZStd::hash_node_destructor_allocator_type,
        }
        pub type hash_node_destructor_allocator_type = root::AZStd::allocator_traits;
        pub type hash_node_destructor_allocator_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table {
            pub _address: u8,
        }
        pub type hash_table_this_type = u8;
        pub type hash_table_is_dynamic = u8;
        pub type hash_table_storage_type = u8;
        pub type hash_table_traits_type = u8;
        pub type hash_table_key_type = u8;
        pub type hash_table_key_eq = u8;
        pub type hash_table_hasher = u8;
        pub type hash_table_allocator_type = u8;
        pub type hash_table_list_type = u8;
        pub type hash_table_size_type = u8;
        pub type hash_table_difference_type = u8;
        pub type hash_table_pointer = u8;
        pub type hash_table_const_pointer = u8;
        pub type hash_table_reference = u8;
        pub type hash_table_const_reference = u8;
        pub type hash_table_iterator = u8;
        pub type hash_table_const_iterator = u8;
        pub type hash_table_reverse_iterator = u8;
        pub type hash_table_const_reverse_iterator = u8;
        pub type hash_table_value_type = u8;
        pub type hash_table_local_iterator = u8;
        pub type hash_table_const_local_iterator = u8;
        pub type hash_table_vector_value_type = u8;
        pub type hash_table_vector_type = u8;
        pub type hash_table_pair_iter_bool = u8;
        pub type hash_table_pair_iter_iter = u8;
        pub type hash_table_pair_citer_citer = u8;
        pub type hash_table_list_node_type = u8;
        pub type hash_table_vector_node_type = u8;
        pub type hash_table_node_deleter = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table_ConvertFromValue {
            pub _address: u8,
        }
        pub type hash_table_ConvertFromValue_key_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_const_iterator {
            pub m_node: root::AZStd::rbtree_const_iterator_node_ptr_type,
        }
        pub const rbtree_const_iterator_ITERATOR_VERSION:
            root::AZStd::rbtree_const_iterator__bindgen_ty_1 = 0;
        pub type rbtree_const_iterator__bindgen_ty_1 = i32;
        pub type rbtree_const_iterator_this_type = root::AZStd::rbtree_const_iterator;
        pub type rbtree_const_iterator_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type rbtree_const_iterator_difference_type = isize;
        pub type rbtree_const_iterator_value_type<T> = T;
        pub type rbtree_const_iterator_pointer<T> = *const T;
        pub type rbtree_const_iterator_reference<T> = *const T;
        pub type rbtree_const_iterator_base_node_ptr_type =
            *mut root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_iterator_const_base_node_ptr_type =
            *const root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_iterator_node_type = u8;
        pub type rbtree_const_iterator_node_ptr_type =
            *mut root::AZStd::rbtree_const_iterator_node_type;
        pub type rbtree_const_iterator_const_node_ptr_type =
            *const root::AZStd::rbtree_const_iterator_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_iterator {
            pub _base: root::AZStd::rbtree_const_iterator,
        }
        pub type rbtree_iterator_this_type = root::AZStd::rbtree_iterator;
        pub type rbtree_iterator_base_type = root::AZStd::rbtree_const_iterator;
        pub type rbtree_iterator_pointer<T> = *mut T;
        pub type rbtree_iterator_reference<T> = *mut T;
        pub type rbtree_iterator_base_node_ptr_type = root::AZStd::rbtree_iterator_base_type;
        pub type rbtree_iterator_node_ptr_type = root::AZStd::rbtree_iterator_base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_node_destructor {
            pub m_allocator: *mut root::AZStd::rbtree_node_destructor_allocator_type,
        }
        pub type rbtree_node_destructor_allocator_type = root::AZStd::allocator_traits;
        pub type rbtree_node_destructor_allocator_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        pub struct rbtree {
            pub m_head: root::AZStd::Internal::rbtree_node_base,
            pub m_numElements: root::AZStd::rbtree_size_type,
            pub m_keyEq: root::AZStd::rbtree_key_eq,
            pub m_allocator: root::AZStd::rbtree_allocator_type,
        }
        pub type rbtree_this_type = root::AZStd::rbtree;
        pub type rbtree_base_node_ptr_type = *mut root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_base_node_ptr_type = *const root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_traits_type<Traits> = Traits;
        pub type rbtree_key_type = [u8; 0usize];
        pub type rbtree_key_eq = [u8; 0usize];
        pub type rbtree_allocator_type = [u8; 0usize];
        pub type rbtree_size_type = [u8; 0usize];
        pub type rbtree_difference_type = [u8; 0usize];
        pub type rbtree_value_type = [u8; 0usize];
        pub type rbtree_pointer = *mut root::AZStd::rbtree_value_type;
        pub type rbtree_const_pointer = *const root::AZStd::rbtree_value_type;
        pub type rbtree_reference = *mut root::AZStd::rbtree_value_type;
        pub type rbtree_const_reference = *const root::AZStd::rbtree_value_type;
        pub type rbtree_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type rbtree_node_type = u8;
        pub type rbtree_node_ptr_type = *mut root::AZStd::rbtree_node_type;
        pub type rbtree_const_node_ptr_type = *const root::AZStd::rbtree_node_type;
        pub type rbtree_const_iterator_impl = root::AZStd::rbtree_const_iterator;
        pub type rbtree_iterator_impl = root::AZStd::rbtree_iterator;
        pub type rbtree_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::rbtree_iterator>;
        pub type rbtree_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::rbtree_const_iterator>;
        pub type rbtree_node_deleter = root::AZStd::rbtree_node_destructor;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_node {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_base_hook {
            pub _address: u8,
        }
        pub type list_base_hook_pointer<T> = *mut T;
        pub type list_base_hook_const_pointer<T> = *const T;
        pub type list_base_hook_node_type = u8;
        pub type list_base_hook_node_ptr_type = *mut root::AZStd::list_base_hook_node_type;
        pub type list_base_hook_const_node_ptr_type = *const root::AZStd::list_base_hook_node_type;
        pub type list_member_hook_pointer<T> = *mut T;
        pub type list_member_hook_const_pointer<T> = *const T;
        pub type list_member_hook_node_type = u8;
        pub type list_member_hook_node_ptr_type = *mut root::AZStd::list_member_hook_node_type;
        pub type list_member_hook_const_node_ptr_type =
            *const root::AZStd::list_member_hook_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list {
            pub _address: u8,
        }
        pub const intrusive_list_CONTAINER_VERSION: root::AZStd::intrusive_list__bindgen_ty_1 = 0;
        pub type intrusive_list__bindgen_ty_1 = i32;
        pub type intrusive_list_this_type = u8;
        pub type intrusive_list_pointer = u8;
        pub type intrusive_list_const_pointer = u8;
        pub type intrusive_list_reference = u8;
        pub type intrusive_list_const_reference = u8;
        pub type intrusive_list_difference_type = u64;
        pub type intrusive_list_size_type = u64;
        pub type intrusive_list_value_type = u8;
        pub type intrusive_list_node_type = u8;
        pub type intrusive_list_node_ptr_type = u8;
        pub type intrusive_list_const_node_ptr_type = u8;
        pub type intrusive_list_hook_node_type = u8;
        pub type intrusive_list_hook_node_ptr_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_const_iterator_impl {
            pub _address: u8,
        }
        pub const intrusive_list_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::intrusive_list_const_iterator_impl__bindgen_ty_1 = 0;
        pub type intrusive_list_const_iterator_impl__bindgen_ty_1 = i32;
        pub type intrusive_list_const_iterator_impl_this_type = u8;
        pub type intrusive_list_const_iterator_impl_value_type = u8;
        pub type intrusive_list_const_iterator_impl_difference_type = u64;
        pub type intrusive_list_const_iterator_impl_pointer = u8;
        pub type intrusive_list_const_iterator_impl_reference = u8;
        pub type intrusive_list_const_iterator_impl_iterator_category = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_iterator_impl {
            pub _address: u8,
        }
        pub type intrusive_list_iterator_impl_this_type = u8;
        pub type intrusive_list_iterator_impl_base_type = u8;
        pub type intrusive_list_iterator_impl_pointer = u8;
        pub type intrusive_list_iterator_impl_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_reverse_iterator_impl {
            pub _address: u8,
        }
        pub type intrusive_list_reverse_iterator_impl_this_type = u8;
        pub type intrusive_list_reverse_iterator_impl_value_type = u8;
        pub type intrusive_list_reverse_iterator_impl_difference_type = u8;
        pub type intrusive_list_reverse_iterator_impl_pointer = u8;
        pub type intrusive_list_reverse_iterator_impl_reference = u8;
        pub type intrusive_list_reverse_iterator_impl_iterator_category = u8;
        pub type intrusive_list_reverse_iterator_impl_iterator_type = u8;
        pub type intrusive_list_iterator = u8;
        pub type intrusive_list_const_iterator = u8;
        pub type intrusive_list_reverse_iterator = u8;
        pub type intrusive_list_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub const unordered_map_CONTAINER_VERSION: root::AZStd::unordered_map__bindgen_ty_1 = 0;
        pub type unordered_map__bindgen_ty_1 = i32;
        pub type unordered_map_this_type = root::AZStd::unordered_map;
        pub type unordered_map_base_type = u8;
        pub type unordered_map_traits_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_eq = root::AZStd::unordered_map_base_type;
        pub type unordered_map_hasher = root::AZStd::unordered_map_base_type;
        pub type unordered_map_mapped_type<MappedType> = MappedType;
        pub type unordered_map_allocator_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_size_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_difference_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_value_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pair_iter_bool = root::AZStd::unordered_map_base_type;
        pub type unordered_map_node_type = root::AZStd::map_node_handle;
        pub type unordered_map_insert_return_type = root::AZStd::insert_return_type<
            root::AZStd::unordered_map_iterator,
            root::AZStd::unordered_map_node_type,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_multimap {
            pub _address: u8,
        }
        pub const unordered_multimap_CONTAINER_VERSION:
            root::AZStd::unordered_multimap__bindgen_ty_1 = 0;
        pub type unordered_multimap__bindgen_ty_1 = i32;
        pub type unordered_multimap_this_type = root::AZStd::unordered_multimap;
        pub type unordered_multimap_base_type = u8;
        pub type unordered_multimap_traits_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_key_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_key_eq = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_hasher = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_mapped_type<MappedType> = MappedType;
        pub type unordered_multimap_allocator_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_size_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_difference_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_pointer = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_pointer = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_reference = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_reference = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_value_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_local_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_local_iterator =
            root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_pair_iter_bool = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_node_type = root::AZStd::map_node_handle;
        pub type array_this_type = u8;
        pub type array_pointer<T> = *mut T;
        pub type array_const_pointer<T> = *const T;
        pub type array_reference<T> = *mut T;
        pub type array_const_reference<T> = *const T;
        pub type array_difference_type = isize;
        pub type array_size_type = usize;
        pub type array_iterator<T> = root::AZStd::array_pointer<T>;
        pub type array_const_iterator<T> = root::AZStd::array_const_pointer<T>;
        pub type array_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::array_iterator<T>>;
        pub type array_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::array_const_iterator<T>>;
        pub type array_value_type<T> = T;
        pub type array_node_type<T> = root::AZStd::array_value_type<T>;
        pub const array_array_size: root::AZStd::array__bindgen_ty_1 = 0;
        pub type array__bindgen_ty_1 = i32;
        pub type tuple = root::std::tuple;
        pub type tuple_size = root::std::tuple_size;
        pub type tuple_element = u8;
        pub type tuple_element_t = u8;
        pub type ignore_t = root::std::_Ignore;
        #[repr(C)]
        #[derive(Debug)]
        pub struct scoped_lock {
            pub m_mutexes: root::AZStd::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct disjunction {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function_traits {
            pub _address: u8,
        }
        pub type function_traits_get_result_t = root::AZStd::function_traits;
        pub type function_traits_get_arg_t = root::AZStd::function_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_extent {
            pub _address: u8,
        }
        pub type remove_extent_type<T> = T;
        pub type unique_ptr = root::std::unique_ptr;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_set {
            pub _address: u8,
        }
        pub const unordered_set_CONTAINER_VERSION: root::AZStd::unordered_set__bindgen_ty_1 = 0;
        pub type unordered_set__bindgen_ty_1 = i32;
        pub type unordered_set_this_type = root::AZStd::unordered_set;
        pub type unordered_set_base_type = u8;
        pub type unordered_set_traits_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_key_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_key_eq = root::AZStd::unordered_set_base_type;
        pub type unordered_set_hasher = root::AZStd::unordered_set_base_type;
        pub type unordered_set_allocator_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_size_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_difference_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_pointer = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_pointer = root::AZStd::unordered_set_base_type;
        pub type unordered_set_reference = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_reference = root::AZStd::unordered_set_base_type;
        pub type unordered_set_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_value_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_local_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_local_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_node_type = root::AZStd::set_node_handle;
        pub type unordered_set_insert_return_type = root::AZStd::insert_return_type<
            root::AZStd::unordered_set_iterator,
            root::AZStd::unordered_set_node_type,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_multiset {
            pub _address: u8,
        }
        pub const unordered_multiset_CONTAINER_VERSION:
            root::AZStd::unordered_multiset__bindgen_ty_1 = 0;
        pub type unordered_multiset__bindgen_ty_1 = i32;
        pub type unordered_multiset_this_type = root::AZStd::unordered_multiset;
        pub type unordered_multiset_base_type = u8;
        pub type unordered_multiset_traits_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_key_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_key_eq = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_hasher = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_allocator_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_size_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_difference_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_pointer = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_pointer = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_reference = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_reference = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_value_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_local_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_local_iterator =
            root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_node_type = root::AZStd::set_node_handle;
        #[repr(C)]
        pub struct shared_mutex {
            pub m_value: root::std::atomic,
        }
        pub const shared_mutex_m_exclusiveLockBit: root::AZ::u32 = 2147483648;
        #[repr(C)]
        pub struct basic_string<Element, Allocator> {
            pub __bindgen_anon_1: root::AZStd::basic_string__bindgen_ty_3<Element>,
            pub m_size: root::AZStd::basic_string_size_type,
            pub m_capacity: root::AZStd::basic_string_size_type,
            pub m_allocator: root::AZStd::basic_string_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type basic_string_this_type<Element, Allocator> =
            root::AZStd::basic_string<Element, Allocator>;
        pub type basic_string_pointer<Element> = *mut Element;
        pub type basic_string_const_pointer<Element> = *const Element;
        pub type basic_string_reference<Element> = *mut Element;
        pub type basic_string_const_reference<Element> = *const Element;
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_iterator_impl<Element> = root::AZStd::basic_string_pointer<Element>;
        pub type basic_string_const_iterator_impl<Element> =
            root::AZStd::basic_string_const_pointer<Element>;
        pub type basic_string_iterator<Element> = root::AZStd::basic_string_iterator_impl<Element>;
        pub type basic_string_const_iterator<Element> =
            root::AZStd::basic_string_const_iterator_impl<Element>;
        pub type basic_string_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_iterator<Element>>;
        pub type basic_string_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_const_iterator<Element>>;
        pub type basic_string_value_type<Element> = Element;
        pub type basic_string_traits_type<Traits> = Traits;
        pub type basic_string_allocator_type<Allocator> = Allocator;
        pub type basic_string_node_type<Element> = root::AZStd::basic_string_value_type<Element>;
        pub const basic_string_SSO_BUF_SIZE: root::AZStd::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        pub const basic_string__ALLOC_MASK: root::AZStd::basic_string__bindgen_ty_2 = 0;
        pub type basic_string__bindgen_ty_2 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_3<Element> {
            pub m_buffer: *mut Element,
            pub m_data: root::AZStd::basic_string_pointer<Element>,
            _bindgen_union_align: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type string = root::AZStd::basic_string<::std::os::raw::c_char, root::AZStd::allocator>;
        pub type wstring = root::AZStd::basic_string<u16, root::AZStd::allocator>;
        pub type size_type = root::AZStd::allocator_size_type;
    }
    pub type HANDLE = *mut ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _RTL_CRITICAL_SECTION {
        _unused: [u8; 0],
    }
    pub type RTL_CRITICAL_SECTION = root::_RTL_CRITICAL_SECTION;
    pub type CRITICAL_SECTION = root::RTL_CRITICAL_SECTION;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _RTL_CONDITION_VARIABLE {
        _unused: [u8; 0],
    }
    pub type RTL_CONDITION_VARIABLE = root::_RTL_CONDITION_VARIABLE;
    pub type CONDITION_VARIABLE = root::RTL_CONDITION_VARIABLE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _GUID {
        _unused: [u8; 0],
    }
    pub type GUID = root::_GUID;
    pub mod AzFramework {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct AssetCatalogEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetCatalogEvents {
            pub vtable_: *const AssetCatalogEvents__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetCatalogEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetCatalogEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type AssetCatalogEventBus = root::AZ::EBus;
        #[repr(C)]
        pub struct LegacyAssetEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct LegacyAssetEvents {
            pub vtable_: *const LegacyAssetEvents__bindgen_vtable,
        }
        pub type LegacyAssetEvents_BusIdType = root::AZ::u32;
        pub const LegacyAssetEvents_EnableEventQueue: bool = true;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@LegacyAssetEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static LegacyAssetEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@LegacyAssetEvents@AzFramework@@2W4EBusAddressPolicy@AZ@@B"]
            pub static LegacyAssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        pub type LegacyAssetEventBus = root::AZ::EBus;
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_20 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_21 {
        pub _address: u8,
    }
    pub type rep = ::std::os::raw::c_longlong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_22 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_23 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_24 {
        pub _address: u8,
    }
}
