/* automatically generated by rust-bindgen */


            type F32 = f32;
            type F64 = f64;
            type U8 = u8;
            type U16 = u16;
            type U32 = u32;
            type U64 = u64;

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[repr(C)]
    #[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
    pub struct __BindgenBitfieldUnit<Storage, Align> {
        storage: Storage,
        align: [Align; 0],
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align> {
        #[inline]
        pub const fn new(storage: Storage) -> Self {
            Self { storage, align: [] }
        }
    }
    impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
    where
        Storage: AsRef<[u8]> + AsMut<[u8]>,
    {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            debug_assert!(index / 8 < self.storage.as_ref().len());
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if cfg!(target_endian = "big") {
                7 - (index % 8)
            } else {
                index % 8
            };
            let mask = 1 << bit_index;
            if val {
                *byte |= mask;
            } else {
                *byte &= !mask;
            }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index = if cfg!(target_endian = "big") {
                        bit_width as usize - 1 - i
                    } else {
                        i
                    };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            debug_assert!(bit_width <= 64);
            debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
            debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    #[repr(C)]
    pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
    impl<T> __BindgenUnionField<T> {
        #[inline]
        pub const fn new() -> Self {
            __BindgenUnionField(::std::marker::PhantomData)
        }
        #[inline]
        pub unsafe fn as_ref(&self) -> &T {
            ::std::mem::transmute(self)
        }
        #[inline]
        pub unsafe fn as_mut(&mut self) -> &mut T {
            ::std::mem::transmute(self)
        }
    }
    impl<T> ::std::default::Default for __BindgenUnionField<T> {
        #[inline]
        fn default() -> Self {
            Self::new()
        }
    }
    impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
        #[inline]
        fn clone(&self) -> Self {
            Self::new()
        }
    }
    impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
    impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
        fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
            fmt.write_str("__BindgenUnionField")
        }
    }
    impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
        fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
    }
    impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
        fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
            true
        }
    }
    impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
    #[allow(unused_imports)]
    use self::super::root;
    pub type f32 = crate::F32;
    pub type f64 = crate::F64;
    pub type u8 = crate::U8;
    pub type u16 = crate::U16;
    pub type u32 = crate::U32;
    pub type u64 = crate::U64;
    pub type const_iterator = root::const_iterator_impl;
    pub type const_iterator_impl = root::const_pointer;
    pub type const_pointer = u64;
    pub mod AZ {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type f32 = crate::F32;
        pub type f64 = crate::F64;
        pub type u8 = crate::U8;
        pub type u16 = crate::U16;
        pub type u32 = crate::U32;
        pub type u64 = crate::U64;
        pub mod Debug {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Trace {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?GetDefaultSystemWindow@Trace@Debug@AZ@@SAPEBDXZ"]
                pub fn Trace_GetDefaultSystemWindow() -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?IsDebuggerPresent@Trace@Debug@AZ@@SA_NXZ"]
                pub fn Trace_IsDebuggerPresent() -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?HandleExceptions@Trace@Debug@AZ@@SAX_N@Z"]
                pub fn Trace_HandleExceptions(isEnabled: bool);
            }
            extern "C" {
                #[link_name = "\u{1}?Break@Trace@Debug@AZ@@SAXXZ"]
                pub fn Trace_Break();
            }
            extern "C" {
                #[link_name = "\u{1}?Terminate@Trace@Debug@AZ@@SAXH@Z"]
                pub fn Trace_Terminate(exitCode: ::std::os::raw::c_int);
            }
            extern "C" {
                #[link_name = "\u{1}?Assert@Trace@Debug@AZ@@SAXPEBDH00ZZ"]
                pub fn Trace_Assert(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Error@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Error(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Warning@Trace@Debug@AZ@@SAXPEBDH000ZZ"]
                pub fn Trace_Warning(
                    fileName: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                    funcName: *const ::std::os::raw::c_char,
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Printf@Trace@Debug@AZ@@SAXPEBD0ZZ"]
                pub fn Trace_Printf(
                    window: *const ::std::os::raw::c_char,
                    format: *const ::std::os::raw::c_char,
                    ...
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Output@Trace@Debug@AZ@@SAXPEBD0@Z"]
                pub fn Trace_Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?PrintCallstack@Trace@Debug@AZ@@SAXPEBDIPEAX@Z"]
                pub fn Trace_PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?GetNativeExceptionInfo@Trace@Debug@AZ@@SAPEAXXZ"]
                pub fn Trace_GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void;
            }
            impl Trace {
                #[inline]
                pub unsafe fn GetDefaultSystemWindow() -> *const ::std::os::raw::c_char {
                    Trace_GetDefaultSystemWindow()
                }
                #[inline]
                pub unsafe fn IsDebuggerPresent() -> bool {
                    Trace_IsDebuggerPresent()
                }
                #[inline]
                pub unsafe fn HandleExceptions(isEnabled: bool) {
                    Trace_HandleExceptions(isEnabled)
                }
                #[inline]
                pub unsafe fn Break() {
                    Trace_Break()
                }
                #[inline]
                pub unsafe fn Terminate(exitCode: ::std::os::raw::c_int) {
                    Trace_Terminate(exitCode)
                }
                #[inline]
                pub unsafe fn Output(
                    window: *const ::std::os::raw::c_char,
                    message: *const ::std::os::raw::c_char,
                ) {
                    Trace_Output(window, message)
                }
                #[inline]
                pub unsafe fn PrintCallstack(
                    window: *const ::std::os::raw::c_char,
                    suppressCount: ::std::os::raw::c_uint,
                    nativeContext: *mut ::std::os::raw::c_void,
                ) {
                    Trace_PrintCallstack(window, suppressCount, nativeContext)
                }
                #[inline]
                pub unsafe fn GetNativeExceptionInfo() -> *mut ::std::os::raw::c_void {
                    Trace_GetNativeExceptionInfo()
                }
            }
            pub type ProfileCategoryPrimitiveType = root::AZ::u64;
            pub const ProfileCategory_Any: root::AZ::Debug::ProfileCategory = 0;
            pub const ProfileCategory_Renderer: root::AZ::Debug::ProfileCategory = 1;
            pub const ProfileCategory_ThreeDEngine: root::AZ::Debug::ProfileCategory = 2;
            pub const ProfileCategory_Particle: root::AZ::Debug::ProfileCategory = 3;
            pub const ProfileCategory_AI: root::AZ::Debug::ProfileCategory = 4;
            pub const ProfileCategory_Animation: root::AZ::Debug::ProfileCategory = 5;
            pub const ProfileCategory_Movie: root::AZ::Debug::ProfileCategory = 6;
            pub const ProfileCategory_Entity: root::AZ::Debug::ProfileCategory = 7;
            pub const ProfileCategory_Font: root::AZ::Debug::ProfileCategory = 8;
            pub const ProfileCategory_Network: root::AZ::Debug::ProfileCategory = 9;
            pub const ProfileCategory_Physics: root::AZ::Debug::ProfileCategory = 10;
            pub const ProfileCategory_Script: root::AZ::Debug::ProfileCategory = 11;
            pub const ProfileCategory_ScriptCFunc: root::AZ::Debug::ProfileCategory = 12;
            pub const ProfileCategory_Audio: root::AZ::Debug::ProfileCategory = 13;
            pub const ProfileCategory_Editor: root::AZ::Debug::ProfileCategory = 14;
            pub const ProfileCategory_System: root::AZ::Debug::ProfileCategory = 15;
            pub const ProfileCategory_Action: root::AZ::Debug::ProfileCategory = 16;
            pub const ProfileCategory_Game: root::AZ::Debug::ProfileCategory = 17;
            pub const ProfileCategory_Input: root::AZ::Debug::ProfileCategory = 18;
            pub const ProfileCategory_Sync: root::AZ::Debug::ProfileCategory = 19;
            pub const ProfileCategory_LegacyNetworkTrafficReserved:
                root::AZ::Debug::ProfileCategory = 20;
            pub const ProfileCategory_LegacyDeviceReserved: root::AZ::Debug::ProfileCategory = 21;
            pub const ProfileCategory_LegacyLast: root::AZ::Debug::ProfileCategory = 22;
            pub const ProfileCategory_AzCore: root::AZ::Debug::ProfileCategory = 23;
            pub const ProfileCategory_AzRender: root::AZ::Debug::ProfileCategory = 24;
            pub const ProfileCategory_AzFramework: root::AZ::Debug::ProfileCategory = 25;
            pub const ProfileCategory_AzToolsFramework: root::AZ::Debug::ProfileCategory = 26;
            pub const ProfileCategory_ScriptCanvas: root::AZ::Debug::ProfileCategory = 27;
            pub const ProfileCategory_FirstDetailedCategory: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_RendererDetailed: root::AZ::Debug::ProfileCategory = 28;
            pub const ProfileCategory_ThreeDEngineDetailed: root::AZ::Debug::ProfileCategory = 29;
            pub const ProfileCategory_JobManagerDetailed: root::AZ::Debug::ProfileCategory = 30;
            pub const ProfileCategory_FirstReservedCategory: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_MemoryReserved: root::AZ::Debug::ProfileCategory = 31;
            pub const ProfileCategory_Global: root::AZ::Debug::ProfileCategory = 32;
            pub const ProfileCategory_Count: root::AZ::Debug::ProfileCategory = 33;
            pub type ProfileCategory = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerThreadData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct Profiler {
                pub m_data: *mut root::AZ::Debug::ProfilerData,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Profiler_Descriptor {
                pub _address: u8,
            }
            pub type Profiler_ReadProfileRegisterCB = root::AZStd::function;
            pub const Profiler_m_maxNumberOfThreads: ::std::os::raw::c_int = 32;
            pub const Profiler_m_maxNumberOfSystems: ::std::os::raw::c_int = 64;
            extern "C" {
                #[link_name = "\u{1}?s_instance@Profiler@Debug@AZ@@0PEAV123@EA"]
                pub static mut Profiler_s_instance: *mut root::AZ::Debug::Profiler;
            }
            extern "C" {
                #[link_name = "\u{1}?s_id@Profiler@Debug@AZ@@0_KA"]
                pub static mut Profiler_s_id: root::AZ::u64;
            }
            extern "C" {
                #[link_name = "\u{1}?s_useCount@Profiler@Debug@AZ@@0HA"]
                pub static mut Profiler_s_useCount: ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?Create@Profiler@Debug@AZ@@SA_NAEBUDescriptor@123@@Z"]
                pub fn Profiler_Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Destroy@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_Destroy();
            }
            extern "C" {
                #[link_name = "\u{1}?AddReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_AddReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ReleaseReference@Profiler@Debug@AZ@@SAXXZ"]
                pub fn Profiler_ReleaseReference();
            }
            extern "C" {
                #[link_name = "\u{1}?ActivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_ActivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?DeactivateSystem@Profiler@Debug@AZ@@QEAAXPEBD@Z"]
                pub fn Profiler_DeactivateSystem(
                    this: *mut root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NPEBD@Z"]
                pub fn Profiler_IsSystemActive(
                    this: *const root::AZ::Debug::Profiler,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsSystemActive@Profiler@Debug@AZ@@QEBA_NI@Z"]
                pub fn Profiler_IsSystemActive1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetNumberOfSystems@Profiler@Debug@AZ@@QEBAHXZ"]
                pub fn Profiler_GetNumberOfSystems(
                    this: *const root::AZ::Debug::Profiler,
                ) -> ::std::os::raw::c_int;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDH@Z"]
                pub fn Profiler_GetSystemName(
                    this: *const root::AZ::Debug::Profiler,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?GetSystemName@Profiler@Debug@AZ@@QEBAPEBDI@Z"]
                pub fn Profiler_GetSystemName1(
                    this: *const root::AZ::Debug::Profiler,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?ReadRegisterValues@Profiler@Debug@AZ@@QEBAXAEBV?$function@$$A6A_NAEBVProfilerRegister@Debug@AZ@@AEBUthread_id@AZStd@@@Z@AZStd@@IPEBUthread_id@5@@Z"]
                pub fn Profiler_ReadRegisterValues(
                    this: *const root::AZ::Debug::Profiler,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ResetRegisters@Profiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_ResetRegisters(this: *mut root::AZ::Debug::Profiler);
            }
            extern "C" {
                #[link_name = "\u{1}?RemoveThreadData@Profiler@Debug@AZ@@QEAAXUthread_id@AZStd@@@Z"]
                pub fn Profiler_RemoveThreadData(
                    this: *mut root::AZ::Debug::Profiler,
                    id: root::AZStd::thread_id,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??_DProfiler@Debug@AZ@@QEAAXXZ"]
                pub fn Profiler_Profiler_destructor(this: *mut root::AZ::Debug::Profiler);
            }
            impl Profiler {
                #[inline]
                pub unsafe fn Create(desc: *const root::AZ::Debug::Profiler_Descriptor) -> bool {
                    Profiler_Create(desc)
                }
                #[inline]
                pub unsafe fn Destroy() {
                    Profiler_Destroy()
                }
                #[inline]
                pub unsafe fn AddReference() {
                    Profiler_AddReference()
                }
                #[inline]
                pub unsafe fn ReleaseReference() {
                    Profiler_ReleaseReference()
                }
                #[inline]
                pub unsafe fn ActivateSystem(&mut self, systemName: *const ::std::os::raw::c_char) {
                    Profiler_ActivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn DeactivateSystem(
                    &mut self,
                    systemName: *const ::std::os::raw::c_char,
                ) {
                    Profiler_DeactivateSystem(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive(
                    &self,
                    systemName: *const ::std::os::raw::c_char,
                ) -> bool {
                    Profiler_IsSystemActive(self, systemName)
                }
                #[inline]
                pub unsafe fn IsSystemActive1(&self, systemId: root::AZ::u32) -> bool {
                    Profiler_IsSystemActive1(self, systemId)
                }
                #[inline]
                pub unsafe fn GetNumberOfSystems(&self) -> ::std::os::raw::c_int {
                    Profiler_GetNumberOfSystems(self)
                }
                #[inline]
                pub unsafe fn GetSystemName(
                    &self,
                    index: ::std::os::raw::c_int,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName(self, index)
                }
                #[inline]
                pub unsafe fn GetSystemName1(
                    &self,
                    systemId: root::AZ::u32,
                ) -> *const ::std::os::raw::c_char {
                    Profiler_GetSystemName1(self, systemId)
                }
                #[inline]
                pub unsafe fn ReadRegisterValues(
                    &self,
                    callback: *const root::AZ::Debug::Profiler_ReadProfileRegisterCB,
                    systemFilter: root::AZ::u32,
                    threadFilter: *const root::AZStd::thread_id,
                ) {
                    Profiler_ReadRegisterValues(self, callback, systemFilter, threadFilter)
                }
                #[inline]
                pub unsafe fn ResetRegisters(&mut self) {
                    Profiler_ResetRegisters(self)
                }
                #[inline]
                pub unsafe fn RemoveThreadData(&mut self, id: root::AZStd::thread_id) {
                    Profiler_RemoveThreadData(self, id)
                }
                #[inline]
                pub unsafe fn destruct(&mut self) {
                    Profiler_Profiler_destructor(self)
                }
            }
            #[repr(C)]
            pub struct ProfilerRegister {
                pub __bindgen_anon_1: root::AZ::Debug::ProfilerRegister__bindgen_ty_1,
                pub m_name: *const ::std::os::raw::c_char,
                pub m_function: *const ::std::os::raw::c_char,
                pub m_line: ::std::os::raw::c_int,
                pub m_systemId: root::AZ::u32,
                pub _bitfield_1: root::__BindgenBitfieldUnit<[u8; 1usize], u8>,
                pub m_threadData: *mut root::AZ::Debug::ProfilerThreadData,
            }
            pub const ProfilerRegister_Type_PRT_TIME: root::AZ::Debug::ProfilerRegister_Type = 0;
            pub const ProfilerRegister_Type_PRT_VALUE: root::AZ::Debug::ProfilerRegister_Type = 1;
            pub type ProfilerRegister_Type = i32;
            #[repr(C)]
            pub struct ProfilerRegister_TimeData {
                pub m_time: root::AZ::u64,
                pub m_childrenTime: root::AZ::u64,
                pub m_calls: root::AZ::s64,
                pub m_childrenCalls: root::AZ::s64,
                pub m_lastParent: *mut root::AZ::Debug::ProfilerRegister,
            }
            extern "C" {
                #[link_name = "\u{1}?s_startStopOverheadPer1000Calls@TimeData@ProfilerRegister@Debug@AZ@@2V?$duration@_JV?$ratio@$00$0PECEA@@AZStd@@@chrono@AZStd@@A"]
                pub static mut ProfilerRegister_TimeData_s_startStopOverheadPer1000Calls:
                    root::AZStd::chrono::microseconds;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ProfilerRegister_ValuesData {
                pub m_value1: root::AZ::s64,
                pub m_value2: root::AZ::s64,
                pub m_value3: root::AZ::s64,
                pub m_value4: root::AZ::s64,
                pub m_value5: root::AZ::s64,
            }
            #[repr(C)]
            pub struct ProfilerRegister__bindgen_ty_1 {
                pub m_timeData:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_TimeData>,
                pub m_userValues:
                    root::__BindgenUnionField<root::AZ::Debug::ProfilerRegister_ValuesData>,
                pub bindgen_union_field: [u64; 5usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TimerCreateAndStart@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD0PEAVProfilerSection@23@0H@Z"]
                pub fn ProfilerRegister_TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?ValueCreate@ProfilerRegister@Debug@AZ@@SAPEAV123@PEBD00H@Z"]
                pub fn ProfilerRegister_ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister;
            }
            extern "C" {
                #[link_name = "\u{1}?TimerStart@ProfilerRegister@Debug@AZ@@QEAAXPEAVProfilerSection@23@@Z"]
                pub fn ProfilerRegister_TimerStart(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    section: *mut root::AZ::Debug::ProfilerSection,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueSet(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueSet1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueSet2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueSet3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueSet@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueSet4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J@Z"]
                pub fn ProfilerRegister_ValueAdd(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0@Z"]
                pub fn ProfilerRegister_ValueAdd1(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J00@Z"]
                pub fn ProfilerRegister_ValueAdd2(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J000@Z"]
                pub fn ProfilerRegister_ValueAdd3(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ValueAdd@ProfilerRegister@Debug@AZ@@QEAAXAEB_J0000@Z"]
                pub fn ProfilerRegister_ValueAdd4(
                    this: *mut root::AZ::Debug::ProfilerRegister,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                );
            }
            impl ProfilerRegister {
                #[inline]
                pub fn m_type(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u8) }
                }
                #[inline]
                pub fn set_m_type(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(0usize, 7u8, val as u64)
                    }
                }
                #[inline]
                pub fn m_isActive(&self) -> ::std::os::raw::c_uchar {
                    unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u8) }
                }
                #[inline]
                pub fn set_m_isActive(&mut self, val: ::std::os::raw::c_uchar) {
                    unsafe {
                        let val: u8 = ::std::mem::transmute(val);
                        self._bitfield_1.set(7usize, 1u8, val as u64)
                    }
                }
                #[inline]
                pub fn new_bitfield_1(
                    m_type: ::std::os::raw::c_uchar,
                    m_isActive: ::std::os::raw::c_uchar,
                ) -> root::__BindgenBitfieldUnit<[u8; 1usize], u8> {
                    let mut __bindgen_bitfield_unit: root::__BindgenBitfieldUnit<[u8; 1usize], u8> =
                        Default::default();
                    __bindgen_bitfield_unit.set(0usize, 7u8, {
                        let m_type: u8 = unsafe { ::std::mem::transmute(m_type) };
                        m_type as u64
                    });
                    __bindgen_bitfield_unit.set(7usize, 1u8, {
                        let m_isActive: u8 = unsafe { ::std::mem::transmute(m_isActive) };
                        m_isActive as u64
                    });
                    __bindgen_bitfield_unit
                }
                #[inline]
                pub unsafe fn TimerCreateAndStart(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    section: *mut root::AZ::Debug::ProfilerSection,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_TimerCreateAndStart(systemName, name, section, function, line)
                }
                #[inline]
                pub unsafe fn ValueCreate(
                    systemName: *const ::std::os::raw::c_char,
                    name: *const ::std::os::raw::c_char,
                    function: *const ::std::os::raw::c_char,
                    line: ::std::os::raw::c_int,
                ) -> *mut root::AZ::Debug::ProfilerRegister {
                    ProfilerRegister_ValueCreate(systemName, name, function, line)
                }
                #[inline]
                pub unsafe fn TimerStart(
                    &mut self,
                    section: *mut root::AZ::Debug::ProfilerSection,
                ) {
                    ProfilerRegister_TimerStart(self, section)
                }
                #[inline]
                pub unsafe fn ValueSet(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueSet(self, v1)
                }
                #[inline]
                pub unsafe fn ValueSet1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueSet2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueSet3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueSet4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueSet4(self, v1, v2, v3, v4, v5)
                }
                #[inline]
                pub unsafe fn ValueAdd(&mut self, v1: *const root::AZ::s64) {
                    ProfilerRegister_ValueAdd(self, v1)
                }
                #[inline]
                pub unsafe fn ValueAdd1(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd1(self, v1, v2)
                }
                #[inline]
                pub unsafe fn ValueAdd2(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd2(self, v1, v2, v3)
                }
                #[inline]
                pub unsafe fn ValueAdd3(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd3(self, v1, v2, v3, v4)
                }
                #[inline]
                pub unsafe fn ValueAdd4(
                    &mut self,
                    v1: *const root::AZ::s64,
                    v2: *const root::AZ::s64,
                    v3: *const root::AZ::s64,
                    v4: *const root::AZ::s64,
                    v5: *const root::AZ::s64,
                ) {
                    ProfilerRegister_ValueAdd4(self, v1, v2, v3, v4, v5)
                }
            }
            #[repr(C)]
            pub struct ProfilerSection {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
                pub m_start: root::AZStd::chrono::system_clock_time_point,
                pub m_childTime: root::AZStd::chrono::microseconds,
                pub m_childCalls: ::std::os::raw::c_int,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocationRecords {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct MemoryDriller {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct TraceMessageEvents__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct TraceMessageEvents {
                pub vtable_: *const TraceMessageEvents__bindgen_vtable,
            }
            pub type TraceMessageEvents_MutexType = root::AZStd::recursive_mutex;
            pub type TraceMessageEvents_AllocatorType = root::AZ::OSStdAllocator;
            pub type TraceMessageBus = root::AZ::EBus;
        }
        pub const PlatformID_PLATFORM_WINDOWS_32: root::AZ::PlatformID = 0;
        pub const PlatformID_PLATFORM_WINDOWS_64: root::AZ::PlatformID = 1;
        pub const PlatformID_PLATFORM_LINUX_64: root::AZ::PlatformID = 2;
        pub const PlatformID_PLATFORM_ANDROID: root::AZ::PlatformID = 3;
        pub const PlatformID_PLATFORM_APPLE_IOS: root::AZ::PlatformID = 4;
        pub const PlatformID_PLATFORM_APPLE_OSX: root::AZ::PlatformID = 5;
        pub const PlatformID_PLATFORM_APPLE_TV: root::AZ::PlatformID = 6;
        pub const PlatformID_PLATFORM_ANDROID_64: root::AZ::PlatformID = 7;
        pub const PlatformID_PLATFORM_MAX: root::AZ::PlatformID = 8;
        pub type PlatformID = i32;
        extern "C" {
            #[link_name = "\u{1}?GetPlatformName@AZ@@YAPEBDW4PlatformID@1@@Z"]
            pub fn GetPlatformName(platform: root::AZ::PlatformID)
                -> *const ::std::os::raw::c_char;
        }
        pub type s8 = i8;
        pub type s16 = i16;
        pub type s32 = i32;
        pub type s64 = i64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct s128 {
            pub a: root::AZ::s64,
            pub b: root::AZ::s64,
        }
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct Uuid {
            pub data: [::std::os::raw::c_uchar; 16usize],
        }
        pub const Uuid_Variant_VAR_UNKNOWN: root::AZ::Uuid_Variant = -1;
        pub const Uuid_Variant_VAR_NCS: root::AZ::Uuid_Variant = 0;
        pub const Uuid_Variant_VAR_RFC_4122: root::AZ::Uuid_Variant = 2;
        pub const Uuid_Variant_VAR_MICROSOFT: root::AZ::Uuid_Variant = 6;
        pub const Uuid_Variant_VAR_RESERVED: root::AZ::Uuid_Variant = 7;
        pub type Uuid_Variant = i32;
        pub const Uuid_Version_VER_UNKNOWN: root::AZ::Uuid_Version = -1;
        pub const Uuid_Version_VER_TIME: root::AZ::Uuid_Version = 1;
        pub const Uuid_Version_VER_DCE: root::AZ::Uuid_Version = 2;
        pub const Uuid_Version_VER_NAME_MD5: root::AZ::Uuid_Version = 3;
        pub const Uuid_Version_VER_RANDOM: root::AZ::Uuid_Version = 4;
        pub const Uuid_Version_VER_NAME_SHA1: root::AZ::Uuid_Version = 5;
        pub type Uuid_Version = i32;
        pub type Uuid_iterator = *mut ::std::os::raw::c_uchar;
        pub type Uuid_const_iterator = *const ::std::os::raw::c_uchar;
        pub const Uuid_MaxStringBuffer: usize = 39;
        extern "C" {
            #[link_name = "\u{1}?CreateNull@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateNull() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateString@Uuid@AZ@@SA?AU12@PEBD_K@Z"]
            pub fn Uuid_CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateRandom@Uuid@AZ@@SA?AU12@XZ"]
            pub fn Uuid_CreateRandom() -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateName@Uuid@AZ@@SA?AU12@PEBD@Z"]
            pub fn Uuid_CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateData@Uuid@AZ@@SA?AU12@PEBX_K@Z"]
            pub fn Uuid_CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid;
        }
        extern "C" {
            #[link_name = "\u{1}?IsNull@Uuid@AZ@@QEBA_NXZ"]
            pub fn Uuid_IsNull(this: *const root::AZ::Uuid) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVariant@Uuid@AZ@@QEBA?AW4Variant@12@XZ"]
            pub fn Uuid_GetVariant(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Variant;
        }
        extern "C" {
            #[link_name = "\u{1}?GetVersion@Uuid@AZ@@QEBA?AW4Version@12@XZ"]
            pub fn Uuid_GetVersion(this: *const root::AZ::Uuid) -> root::AZ::Uuid_Version;
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@Uuid@AZ@@QEBAHPEADH_N1@Z"]
            pub fn Uuid_ToString(
                this: *const root::AZ::Uuid,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}??0Uuid@AZ@@QEAA@AEBU_GUID@@@Z"]
            pub fn Uuid_Uuid(this: *mut root::AZ::Uuid, guid: *const root::GUID);
        }
        impl Uuid {
            #[inline]
            pub unsafe fn CreateNull() -> root::AZ::Uuid {
                Uuid_CreateNull()
            }
            #[inline]
            pub unsafe fn CreateString(
                string: *const ::std::os::raw::c_char,
                stringLength: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateString(string, stringLength)
            }
            #[inline]
            pub unsafe fn CreateRandom() -> root::AZ::Uuid {
                Uuid_CreateRandom()
            }
            #[inline]
            pub unsafe fn CreateName(name: *const ::std::os::raw::c_char) -> root::AZ::Uuid {
                Uuid_CreateName(name)
            }
            #[inline]
            pub unsafe fn CreateData(
                data: *const ::std::os::raw::c_void,
                dataSize: usize,
            ) -> root::AZ::Uuid {
                Uuid_CreateData(data, dataSize)
            }
            #[inline]
            pub unsafe fn IsNull(&self) -> bool {
                Uuid_IsNull(self)
            }
            #[inline]
            pub unsafe fn GetVariant(&self) -> root::AZ::Uuid_Variant {
                Uuid_GetVariant(self)
            }
            #[inline]
            pub unsafe fn GetVersion(&self) -> root::AZ::Uuid_Version {
                Uuid_GetVersion(self)
            }
            #[inline]
            pub unsafe fn ToString(
                &self,
                output: *mut ::std::os::raw::c_char,
                outputSize: ::std::os::raw::c_int,
                isBrackets: bool,
                isDashes: bool,
            ) -> ::std::os::raw::c_int {
                Uuid_ToString(self, output, outputSize, isBrackets, isDashes)
            }
            #[inline]
            pub unsafe fn new(guid: *const root::GUID) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Uuid_Uuid(__bindgen_tmp.as_mut_ptr(), guid);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Crc32 {
            pub m_value: root::AZ::u32,
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBD@Z"]
            pub fn Crc32_Add(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}?Add@Crc32@AZ@@QEAAXPEBX_K_N@Z"]
            pub fn Crc32_Add1(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@Crc32@AZ@@SAXAEAVSerializeContext@2@@Z"]
            pub fn Crc32_Reflect(context: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?Set@Crc32@AZ@@IEAAXPEBX_K_N@Z"]
            pub fn Crc32_Set(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Combine@Crc32@AZ@@IEAAXI_K@Z"]
            pub fn Crc32_Combine(this: *mut root::AZ::Crc32, crc: root::AZ::u32, len: usize);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBD@Z"]
            pub fn Crc32_Crc32(this: *mut root::AZ::Crc32, str: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
            pub fn Crc32_Crc321(this: *mut root::AZ::Crc32, view: root::AZStd::string_view);
        }
        extern "C" {
            #[link_name = "\u{1}??0Crc32@AZ@@QEAA@PEBX_K_N@Z"]
            pub fn Crc32_Crc322(
                this: *mut root::AZ::Crc32,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            );
        }
        impl Crc32 {
            #[inline]
            pub unsafe fn Add(&mut self, str: *const ::std::os::raw::c_char) {
                Crc32_Add(self, str)
            }
            #[inline]
            pub unsafe fn Add1(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Add1(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::SerializeContext) {
                Crc32_Reflect(context)
            }
            #[inline]
            pub unsafe fn Set(
                &mut self,
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) {
                Crc32_Set(self, data, size, forceLowerCase)
            }
            #[inline]
            pub unsafe fn Combine(&mut self, crc: root::AZ::u32, len: usize) {
                Crc32_Combine(self, crc, len)
            }
            #[inline]
            pub unsafe fn new(str: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc32(__bindgen_tmp.as_mut_ptr(), str);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(view: root::AZStd::string_view) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc321(__bindgen_tmp.as_mut_ptr(), view);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                data: *const ::std::os::raw::c_void,
                size: usize,
                forceLowerCase: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Crc32_Crc322(__bindgen_tmp.as_mut_ptr(), data, size, forceLowerCase);
                __bindgen_tmp.assume_init()
            }
        }
        pub type TypeId = root::AZ::Uuid;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct PointerRemovedTypeIdTag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CanonicalTypeIdTag {
            pub _address: u8,
        }
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type AZTypeInfoIntrusiveResultType_type = root::std::true_type;
            pub type HasAZTypeInfoIntrusive_Yes = ::std::os::raw::c_char;
            pub type HasAZTypeInfoIntrusive_No = ::std::os::raw::c_long;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoIntrusive_Helper {
                pub _address: u8,
            }
            pub type HasAZTypeInfoIntrusive_Helper_mfp =
                ::std::option::Option<unsafe extern "C" fn()>;
            pub type HasAZTypeInfoIntrusive_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfoSpecialized {
                pub _base: root::std::false_type,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HasAZTypeInfo {
                pub _address: u8,
            }
            pub type HasAZTypeInfo_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AggregateTypes {
                pub _address: u8,
            }
            pub type TypeIdHolder = root::AZ::TypeId;
            #[repr(C)]
            pub struct CallstackEntryBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryBase {
                pub vtable_: *const CallstackEntryBase__bindgen_vtable,
                pub m_busId: *const [u8; 0usize],
                pub m_prev: *mut root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryBase_BusType = root::AZ::EBus;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntry {
                pub _base: root::AZ::Internal::CallstackEntryBase,
                pub m_context: root::AZ::Internal::CallstackEntry_BusContextPtr,
                pub m_threadId: root::AZStd::native_thread_id_type,
            }
            pub type CallstackEntry_BusType = root::AZ::EBus;
            pub type CallstackEntry_BusContextPtr = *mut root::AZ::Internal::CallstackEntry_BusType;
            #[repr(C)]
            #[derive(Debug)]
            pub struct CallstackEntryRoot {
                pub _base: root::AZ::Internal::CallstackEntryBase,
            }
            pub type CallstackEntryRoot_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct RegisterData {
                pub m_register: *mut root::AZ::Debug::ProfilerRegister,
                pub m_profilerId: root::AZ::u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EnvironmentVariableResult {
                pub m_state: root::AZ::Internal::EnvironmentVariableResult_States,
                pub m_variable: *mut ::std::os::raw::c_void,
            }
            pub const EnvironmentVariableResult_States_Added:
                root::AZ::Internal::EnvironmentVariableResult_States = 0;
            pub const EnvironmentVariableResult_States_Removed:
                root::AZ::Internal::EnvironmentVariableResult_States = 1;
            pub const EnvironmentVariableResult_States_Found:
                root::AZ::Internal::EnvironmentVariableResult_States = 2;
            pub const EnvironmentVariableResult_States_NotFound:
                root::AZ::Internal::EnvironmentVariableResult_States = 3;
            pub const EnvironmentVariableResult_States_OutOfMemory:
                root::AZ::Internal::EnvironmentVariableResult_States = 4;
            pub type EnvironmentVariableResult_States = i32;
            #[repr(C)]
            pub struct EnvironmentInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EnvironmentInterface {
                pub vtable_: *const EnvironmentInterface__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?s_environment@EnvironmentInterface@Internal@AZ@@2PEAV123@EA"]
                pub static mut EnvironmentInterface_s_environment:
                    *mut root::AZ::Internal::EnvironmentInterface;
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolderBase {
                pub m_environmentOwner: *mut root::AZ::Internal::EnvironmentInterface,
                pub m_moduleOwner: *mut ::std::os::raw::c_void,
                pub m_canTransferOwnership: bool,
                pub m_isConstructed: bool,
                pub m_guid: root::AZ::u32,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
                pub m_useCount: ::std::os::raw::c_int,
                pub m_mutex: root::AZStd::spin_mutex,
            }
            #[repr(C)]
            pub struct EnvironmentVariableHolder {
                pub _base: root::AZ::Internal::EnvironmentVariableHolderBase,
                pub m_value: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?AddAndAllocateVariable@Internal@AZ@@YA?AUEnvironmentVariableResult@12@I_K0PEAPEAVrecursive_mutex@AZStd@@@Z"]
                pub fn AddAndAllocateVariable(
                    guid: root::AZ::u32,
                    byteSize: usize,
                    alignment: usize,
                    addedVariableLock: *mut *mut root::AZStd::recursive_mutex,
                ) -> root::AZ::Internal::EnvironmentVariableResult;
            }
            extern "C" {
                #[link_name = "\u{1}?GetVariable@Internal@AZ@@YA?AUEnvironmentVariableResult@12@I@Z"]
                pub fn GetVariable(
                    guid: root::AZ::u32,
                ) -> root::AZ::Internal::EnvironmentVariableResult;
            }
            extern "C" {
                #[link_name = "\u{1}?GetAllocator@Internal@AZ@@YAPEAVAllocatorInterface@Environment@2@XZ"]
                pub fn GetAllocator() -> *mut root::AZ::Environment::AllocatorInterface;
            }
            extern "C" {
                #[link_name = "\u{1}?EnvironmentVariableNameToId@Internal@AZ@@YAIPEBD@Z"]
                pub fn EnvironmentVariableNameToId(
                    uniqueName: *const ::std::os::raw::c_char,
                ) -> root::AZ::u32;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorDummy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct RttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            pub type RttiHelper_ValueType<T> = T;
            #[repr(C)]
            #[derive(Debug)]
            pub struct ExternalVariadicRttiHelper {
                pub _base: root::AZ::IRttiHelper,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsSameCast {
                pub _address: u8,
            }
            pub type AddressTypeHelper_type = *const ::std::os::raw::c_void;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiRemoveQualifiers {
                pub _address: u8,
            }
            pub type RttiRemoveQualifiers_type = root::std::remove_cv;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfHelper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RttiIsTypeOfIdHelper {
                pub _address: u8,
            }
            pub type EBusEnvironmentGetterType =
                ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::EBusEnvironment>;
            pub type EBusEnvironmentSetterType =
                ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::AZ::EBusEnvironment)>;
            #[repr(C)]
            pub struct ContextBase__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct ContextBase {
                pub vtable_: *const ContextBase__bindgen_vtable,
                pub m_ebusEnvironmentTLSIndex: ::std::os::raw::c_int,
                pub m_ebusEnvironmentGetter: root::AZ::Internal::EBusEnvironmentGetterType,
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@XZ"]
                pub fn ContextBase_ContextBase(this: *mut root::AZ::Internal::ContextBase);
            }
            extern "C" {
                #[link_name = "\u{1}??0ContextBase@Internal@AZ@@QEAA@PEAVEBusEnvironment@2@@Z"]
                pub fn ContextBase_ContextBase1(
                    this: *mut root::AZ::Internal::ContextBase,
                    arg1: *mut root::AZ::EBusEnvironment,
                );
            }
            impl ContextBase {
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ContextBase_ContextBase(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(arg1: *mut root::AZ::EBusEnvironment) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    ContextBase_ContextBase1(__bindgen_tmp.as_mut_ptr(), arg1);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentTLSAccessors {
                pub m_getter: root::AZ::Internal::EBusEnvironmentGetterType,
                pub m_setter: root::AZ::Internal::EBusEnvironmentSetterType,
                pub m_numUniqueEBuses: root::AZStd::atomic_int,
            }
            extern "C" {
                #[link_name = "\u{1}?s_tlsCurrentEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@2PEAVEBusEnvironment@3@EA"]
                pub static mut EBusEnvironmentTLSAccessors_s_tlsCurrentEnvironment:
                    *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?GetId@EBusEnvironmentTLSAccessors@Internal@AZ@@SAIXZ"]
                pub fn EBusEnvironmentTLSAccessors_GetId() -> root::AZ::u32;
            }
            extern "C" {
                #[link_name = "\u{1}?GetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAPEAVEBusEnvironment@3@XZ"]
                pub fn EBusEnvironmentTLSAccessors_GetTLSEnvironment(
                ) -> *mut root::AZ::EBusEnvironment;
            }
            extern "C" {
                #[link_name = "\u{1}?SetTLSEnvironment@EBusEnvironmentTLSAccessors@Internal@AZ@@SAXPEAVEBusEnvironment@3@@Z"]
                pub fn EBusEnvironmentTLSAccessors_SetTLSEnvironment(
                    environment: *mut root::AZ::EBusEnvironment,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentTLSAccessors@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(
                    this: *mut root::AZ::Internal::EBusEnvironmentTLSAccessors,
                );
            }
            impl EBusEnvironmentTLSAccessors {
                #[inline]
                pub unsafe fn GetId() -> root::AZ::u32 {
                    EBusEnvironmentTLSAccessors_GetId()
                }
                #[inline]
                pub unsafe fn GetTLSEnvironment() -> *mut root::AZ::EBusEnvironment {
                    EBusEnvironmentTLSAccessors_GetTLSEnvironment()
                }
                #[inline]
                pub unsafe fn SetTLSEnvironment(environment: *mut root::AZ::EBusEnvironment) {
                    EBusEnvironmentTLSAccessors_SetTLSEnvironment(environment)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentTLSAccessors_EBusEnvironmentTLSAccessors(
                        __bindgen_tmp.as_mut_ptr(),
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEnvironmentAllocator {
                pub m_name: *const ::std::os::raw::c_char,
                pub m_allocator: *mut root::AZ::Environment::AllocatorInterface,
            }
            pub type EBusEnvironmentAllocator_pointer_type = *mut ::std::os::raw::c_void;
            pub type EBusEnvironmentAllocator_size_type = usize;
            pub type EBusEnvironmentAllocator_difference_type = isize;
            pub type EBusEnvironmentAllocator_allow_memory_leaks = root::std::false_type;
            extern "C" {
                #[link_name = "\u{1}?allocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAPEAX_K0H@Z"]
                pub fn EBusEnvironmentAllocator_allocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type;
            }
            extern "C" {
                #[link_name = "\u{1}?deallocate@EBusEnvironmentAllocator@Internal@AZ@@QEAAXPEAX_K1@Z"]
                pub fn EBusEnvironmentAllocator_deallocate(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@XZ"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0EBusEnvironmentAllocator@Internal@AZ@@QEAA@AEBV012@@Z"]
                pub fn EBusEnvironmentAllocator_EBusEnvironmentAllocator1(
                    this: *mut root::AZ::Internal::EBusEnvironmentAllocator,
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                );
            }
            impl EBusEnvironmentAllocator {
                #[inline]
                pub unsafe fn allocate(
                    &mut self,
                    byteSize: usize,
                    alignment: usize,
                    flags: ::std::os::raw::c_int,
                ) -> root::AZ::Internal::EBusEnvironmentAllocator_pointer_type {
                    EBusEnvironmentAllocator_allocate(self, byteSize, alignment, flags)
                }
                #[inline]
                pub unsafe fn deallocate(
                    &mut self,
                    ptr: root::AZ::Internal::EBusEnvironmentAllocator_pointer_type,
                    byteSize: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                    alignment: root::AZ::Internal::EBusEnvironmentAllocator_size_type,
                ) {
                    EBusEnvironmentAllocator_deallocate(self, ptr, byteSize, alignment)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    rhs: *const root::AZ::Internal::EBusEnvironmentAllocator,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    EBusEnvironmentAllocator_EBusEnvironmentAllocator1(
                        __bindgen_tmp.as_mut_ptr(),
                        rhs,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullBusMessageCall {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct HandlerCompare<Comparer> {
                pub _base: Comparer,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Comparer>>,
            }
            #[repr(C)]
            pub struct NonIdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct NonIdHandler<Interface> {
                pub vtable_: *const NonIdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type NonIdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct IdHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            pub struct IdHandler<Interface> {
                pub vtable_: *const IdHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_node: [u8; 0usize],
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type IdHandler_IdType = [u8; 0usize];
            pub type IdHandler_BusType = root::AZ::EBus;
            #[repr(C)]
            pub struct MultiHandler__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct MultiHandler<Interface> {
                pub vtable_: *const MultiHandler__bindgen_vtable,
                pub _base: Interface,
                pub m_handlerNodes: root::AZStd::unordered_map,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
            }
            pub type MultiHandler_IdType = [u8; 0usize];
            pub type MultiHandler_HandlerNode = [u8; 0usize];
            pub type MultiHandler_BusType = root::AZ::EBus;
            pub mod _bindgen_mod_id_97839 {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug)]
                pub struct MidDispatchDisconnectFixer<PreHandler, PostHandler> {
                    pub _base: root::AZ::Internal::CallstackEntry,
                    pub m_onPreDisconnect: PreHandler,
                    pub m_onPostDisconnect: PostHandler,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<PreHandler>>,
                    pub _phantom_1:
                        ::std::marker::PhantomData<::std::cell::UnsafeCell<PostHandler>>,
                }
                pub type MidDispatchDisconnectFixer_Base = root::AZ::Internal::CallstackEntry;
            }
            pub type EBusContainer_ContainerType = u8;
            pub type EBusContainer_IdType = [u8; 0usize];
            pub type EBusContainer_CallstackEntry = root::AZ::Internal::CallstackEntry;
            pub type EBusContainer_HandlerNode = u8;
            pub type EBusContainer_AddressStorage = u8;
            pub type EBusContainer_HandlerStorage = u8;
            pub type EBusContainer_Handler<Interface> = root::AZ::Internal::IdHandler<Interface>;
            pub type EBusContainer_MultiHandler<Interface> =
                root::AZ::Internal::MultiHandler<Interface>;
            pub type EBusContainer_BusPtr =
                root::AZStd::intrusive_ptr<root::AZ::Internal::EBusContainer_HandlerHolder>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusContainer_Dispatcher {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusContainer_HandlerHolder {
                pub m_busContainer: *mut root::AZ::Internal::EBusContainer_ContainerType,
                pub m_busId: root::AZ::Internal::EBusContainer_IdType,
                pub m_handlers: root::AZ::Internal::EBusContainer_HandlerStorage,
                pub m_refCount: root::AZStd::atomic_uint,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct NullLockGuard {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterQueueEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusRouterEventForwarder {
                pub _address: u8,
            }
            #[repr(C)]
            pub struct EBusRouter__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct EBusRouter<EBus> {
                pub vtable_: *const EBusRouter__bindgen_vtable,
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub m_isConnected: bool,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNestedVersionRouter<EBus> {
                pub m_routerNode: root::AZ::EBusRouterNode<EBus>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<EBus>>,
            }
            pub type ReflectionFunctionRef =
                ::std::option::Option<unsafe extern "C" fn(context: *mut root::AZ::ReflectContext)>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AttributeValueTypeClassChecker {
                pub _address: u8,
            }
            pub type enable_if_not_void = u8;
            pub type enable_if_constructible = u8;
            pub type OutcomeStorage_ValueType<ValueT> = ValueT;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct RValueToLValueWrapper<TRValue> {
                pub m_data: TRValue,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<TRValue>>,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct NullFactory {
                pub _base: root::AZ::SerializeContext_IObjectFactory,
            }
            pub type AZStdBasicContainer_ValueType = [u8; 0usize];
            pub type AZStdFixedCapacityRandomAccessContainer_ValueType = [u8; 0usize];
            pub type AZStdFixedCapacityRandomAccessContainer_ValueClass = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZStdArrayEvents {
                pub _base: root::AZ::SerializeContext_IEventHandler,
            }
            pub type AZStdArrayEvents_Stack =
                root::AZStd::stack<root::AZStd::vector<usize, root::AZ::OSStdAllocator>>;
            extern "C" {
                #[link_name = "\u{1}?m_indices@AZStdArrayEvents@Internal@AZ@@0PEAXEA"]
                pub static mut AZStdArrayEvents_m_indices: *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?GetIndex@AZStdArrayEvents@Internal@AZ@@QEBA_KXZ"]
                pub fn AZStdArrayEvents_GetIndex(
                    this: *const root::AZ::Internal::AZStdArrayEvents,
                ) -> usize;
            }
            extern "C" {
                #[link_name = "\u{1}?Increment@AZStdArrayEvents@Internal@AZ@@QEAAXXZ"]
                pub fn AZStdArrayEvents_Increment(this: *mut root::AZ::Internal::AZStdArrayEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?IsEmpty@AZStdArrayEvents@Internal@AZ@@QEBA_NXZ"]
                pub fn AZStdArrayEvents_IsEmpty(
                    this: *const root::AZ::Internal::AZStdArrayEvents,
                ) -> bool;
            }
            impl AZStdArrayEvents {
                #[inline]
                pub unsafe fn GetIndex(&self) -> usize {
                    AZStdArrayEvents_GetIndex(self)
                }
                #[inline]
                pub unsafe fn Increment(&mut self) {
                    AZStdArrayEvents_Increment(self)
                }
                #[inline]
                pub unsafe fn IsEmpty(&self) -> bool {
                    AZStdArrayEvents_IsEmpty(self)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?OnWriteBegin@AZStdArrayEvents@Internal@AZ@@UEAAXPEAX@Z"]
                pub fn AZStdArrayEvents_OnWriteBegin(
                    this: *mut ::std::os::raw::c_void,
                    classPtr: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnWriteEnd@AZStdArrayEvents@Internal@AZ@@UEAAXPEAX@Z"]
                pub fn AZStdArrayEvents_OnWriteEnd(
                    this: *mut ::std::os::raw::c_void,
                    classPtr: *mut ::std::os::raw::c_void,
                );
            }
            pub type AZStdArrayContainer_ContainerType = u8;
            pub type AZStdArrayContainer_ValueType<T> = T;
            #[repr(C)]
            pub struct AZStdAssociativeContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub _base_1: root::AZ::SerializeContext_IDataContainer_IAssociativeDataContainer,
                pub m_classElement: root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdAssociativeContainer_ValueType = [u8; 0usize];
            pub type AZStdAssociativeContainer_ValueClass = root::AZStd::remove_pointer_t;
            pub type AZStdAssociativeContainer_KeyType = [u8; 0usize];
            pub type AZStdAssociativeContainer_WrappedKeyType =
                root::AZ::Internal::RValueToLValueWrapper<
                    root::AZ::Internal::AZStdAssociativeContainer_KeyType,
                >;
            #[repr(C)]
            pub struct AZStdPairContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub __bindgen_padding_0: u64,
                pub m_value1ClassElement: root::AZ::SerializeContext_ClassElement,
                pub m_value2ClassElement: root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdPairContainer_Value1Class = root::std::remove_pointer;
            pub type AZStdPairContainer_Value2Class = root::std::remove_pointer;
            pub type AZStdPairContainer_PairType<T1, T2> = root::AZStd::pair<T1, T2>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ArraySafeTupleSize {
                pub _base: u8,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZStdTupleContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub m_valueClassElements: *mut root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdTupleContainer_TupleType = root::AZStd::tuple;
            #[repr(C)]
            pub struct AZRValueContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub __bindgen_padding_0: u64,
                pub m_valueClassElement: root::AZ::SerializeContext_ClassElement,
            }
            pub type AZRValueContainer_WrapperType<T> =
                root::AZ::Internal::RValueToLValueWrapper<T>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AZSmartPtrValueType {
                pub _address: u8,
            }
            pub type AZSmartPtrValueType_value_type = [u8; 0usize];
            #[repr(C)]
            pub struct AZStdSmartPtrContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub __bindgen_padding_0: u64,
                pub m_classElement: root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdSmartPtrContainer_ValueType = root::AZ::Internal::AZSmartPtrValueType;
            #[repr(C)]
            pub struct AZStdOptionalContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub __bindgen_padding_0: u64,
                pub m_classElement: root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdOptionalContainer_ValueType = root::AZ::Internal::AZSmartPtrValueType;
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZStdString {
                pub _base: root::AZ::SerializeContext_IDataSerializer,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZBinaryData {
                pub _base: root::AZ::SerializeContext_IDataSerializer,
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZByteStream {
                pub _base: root::AZ::Internal::AZBinaryData,
            }
            pub type AZByteStream_ContainerType = u8;
            pub type AZBitSet_ContainerType = u8;
        }
        pub type EnvironmentInstance = *mut root::AZ::Internal::EnvironmentInterface;
        pub mod Environment {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct AllocatorInterface__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AllocatorInterface {
                pub vtable_: *const AllocatorInterface__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?GetInstance@Environment@AZ@@YAPEAVEnvironmentInterface@Internal@2@XZ"]
                pub fn GetInstance() -> root::AZ::EnvironmentInstance;
            }
            extern "C" {
                #[link_name = "\u{1}?GetModuleId@Environment@AZ@@YAPEAXXZ"]
                pub fn GetModuleId() -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?Create@Environment@AZ@@YA_NPEAVAllocatorInterface@12@@Z"]
                pub fn Create(allocator: *mut root::AZ::Environment::AllocatorInterface) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Destroy@Environment@AZ@@YAXXZ"]
                pub fn Destroy();
            }
            extern "C" {
                #[link_name = "\u{1}?Attach@Environment@AZ@@YAXPEAVEnvironmentInterface@Internal@2@_N@Z"]
                pub fn Attach(
                    sourceEnvironment: root::AZ::EnvironmentInstance,
                    useAsGetFallback: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Detach@Environment@AZ@@YAXXZ"]
                pub fn Detach();
            }
            extern "C" {
                #[link_name = "\u{1}?IsReady@Environment@AZ@@YA_NXZ"]
                pub fn IsReady() -> bool;
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EnvironmentVariable {
            pub m_data: *mut root::AZ::EnvironmentVariable_HolderType,
        }
        pub type EnvironmentVariable_HolderType = root::AZ::Internal::EnvironmentVariableHolder;
        pub type EnvironmentVariable_unspecified_bool_type =
            *mut *mut root::AZ::EnvironmentVariable_HolderType;
        #[repr(C)]
        pub struct IAllocatorAllocate__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocatorAllocate {
            pub vtable_: *const IAllocatorAllocate__bindgen_vtable,
        }
        pub type IAllocatorAllocate_pointer_type = *mut ::std::os::raw::c_void;
        pub type IAllocatorAllocate_size_type = usize;
        pub type IAllocatorAllocate_difference_type = isize;
        #[repr(C)]
        #[derive(Debug)]
        pub struct IAllocator {
            pub _base: root::AZ::IAllocatorAllocate,
            pub m_records: *mut root::AZ::Debug::AllocationRecords,
            pub m_isReady: bool,
        }
        extern "C" {
            #[link_name = "\u{1}?OnCreated@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnCreated(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnDestroy@IAllocator@AZ@@IEAAXXZ"]
            pub fn IAllocator_OnDestroy(this: *mut root::AZ::IAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?OnOutOfMemory@IAllocator@AZ@@IEAA_N_K0HPEBD1H@Z"]
            pub fn IAllocator_OnOutOfMemory(
                this: *mut root::AZ::IAllocator,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0IAllocator@AZ@@QEAA@XZ"]
            pub fn IAllocator_IAllocator(this: *mut root::AZ::IAllocator);
        }
        impl IAllocator {
            #[inline]
            pub unsafe fn OnCreated(&mut self) {
                IAllocator_OnCreated(self)
            }
            #[inline]
            pub unsafe fn OnDestroy(&mut self) {
                IAllocator_OnDestroy(self)
            }
            #[inline]
            pub unsafe fn OnOutOfMemory(
                &mut self,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
            ) -> bool {
                IAllocator_OnOutOfMemory(self, byteSize, alignment, flags, name, fileName, lineNum)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                IAllocator_IAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DIAllocator@AZ@@QEAAXXZ"]
            pub fn IAllocator_IAllocator_destructor(this: *mut root::AZ::IAllocator);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AllocatorBase<SchemaType> {
            pub _base: root::AZ::IAllocator,
            pub m_schema: *mut root::AZ::AllocatorBase_Schema<SchemaType>,
            pub m_name: *const ::std::os::raw::c_char,
            pub m_desc: *const ::std::os::raw::c_char,
            pub m_schemaStorage: u8,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<SchemaType>>,
        }
        pub type AllocatorBase_Descriptor<DescriptorType> = DescriptorType;
        pub type AllocatorBase_Schema<SchemaType> = SchemaType;
        pub mod Memory {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AllocatorInstance {
            pub _address: u8,
        }
        pub type AllocatorInstance_Descriptor = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug)]
        pub struct ChildAllocatorSchema {
            pub _base: root::AZ::IAllocatorAllocate,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ChildAllocatorSchema_Descriptor {
            pub _address: u8,
        }
        pub type ChildAllocatorSchema_Parent<ParentAllocator> = ParentAllocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdAlloc {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdAlloc_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdAlloc_size_type = usize;
        pub type AZStdAlloc_difference_type = isize;
        pub type AZStdAlloc_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdIAllocator {
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdIAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdIAllocator_size_type = usize;
        pub type AZStdIAllocator_difference_type = isize;
        pub type AZStdIAllocator_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AZStdFunctorAllocator {
            pub m_allocatorFunctor: root::AZ::AZStdFunctorAllocator_functor_type,
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type AZStdFunctorAllocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type AZStdFunctorAllocator_size_type = usize;
        pub type AZStdFunctorAllocator_difference_type = isize;
        pub type AZStdFunctorAllocator_allow_memory_leaks = root::std::false_type;
        pub type AZStdFunctorAllocator_functor_type =
            ::std::option::Option<unsafe extern "C" fn() -> *mut root::AZ::IAllocatorAllocate>;
        pub type AZClassAllocatorResultType_type = root::std::true_type;
        pub type HasAZClassAllocator_Yes = ::std::os::raw::c_char;
        pub type HasAZClassAllocator_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZClassAllocator_Helper {
            pub _address: u8,
        }
        pub type HasAZClassAllocator_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZClassAllocator_type = u8;
        extern "C" {
            #[link_name = "\u{1}?OperatorNew@AZ@@YAPEAX_KPEBDH1@Z"]
            pub fn OperatorNew(
                size: usize,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNew@AZ@@YAPEAX_K@Z"]
            pub fn OperatorNew1(byteSize: usize) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorDelete@AZ@@YAXPEAX@Z"]
            pub fn OperatorDelete(ptr: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNewArray@AZ@@YAPEAX_KPEBDH1@Z"]
            pub fn OperatorNewArray(
                size: usize,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorNewArray@AZ@@YAPEAX_K@Z"]
            pub fn OperatorNewArray1(byteSize: usize) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?OperatorDeleteArray@AZ@@YAXPEAX@Z"]
            pub fn OperatorDeleteArray(ptr: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct OSAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_numAllocatedBytes: root::AZ::IAllocatorAllocate_size_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OSAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_TYPEINFO_Enable(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@OSAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn OSAllocator_Create(
                this: *mut root::AZ::OSAllocator,
                desc: *const root::AZ::OSAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@OSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_Destroy(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@QEAA@XZ"]
            pub fn OSAllocator_OSAllocator(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0OSAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn OSAllocator_OSAllocator1(
                this: *mut root::AZ::OSAllocator,
                arg1: *const root::AZ::OSAllocator,
            );
        }
        impl OSAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                OSAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Create(&mut self, desc: *const root::AZ::OSAllocator_Descriptor) -> bool {
                OSAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                OSAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OSAllocator_OSAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::OSAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OSAllocator_OSAllocator1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DOSAllocator@AZ@@QEAAXXZ"]
            pub fn OSAllocator_OSAllocator_destructor(this: *mut root::AZ::OSAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@OSAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn OSAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@OSAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn OSAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        pub type OSStdAllocator = root::AZ::AZStdAlloc;
        pub type RTTI_EnumCallback = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const root::AZ::TypeId, arg2: *mut ::std::os::raw::c_void),
        >;
        pub type AZRttiIntrusiveResultType_type = root::std::true_type;
        pub type HasAZRttiIntrusive_Yes = ::std::os::raw::c_char;
        pub type HasAZRttiIntrusive_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiIntrusive_Helper {
            pub _address: u8,
        }
        pub type HasAZRttiIntrusive_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasAZRttiIntrusive_type = u8;
        pub const RttiKind_None: root::AZ::RttiKind = 0;
        pub const RttiKind_Intrusive: root::AZ::RttiKind = 1;
        pub const RttiKind_External: root::AZ::RttiKind = 2;
        pub type RttiKind = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRttiExternal {
            pub _address: u8,
        }
        pub type HasAZRttiExternal_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasAZRtti {
            pub _address: u8,
        }
        pub type HasAZRtti_type = u8;
        pub type HasAZRtti_kind_type = u8;
        #[repr(C)]
        pub struct IRttiHelper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct IRttiHelper {
            pub vtable_: *const IRttiHelper__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusEnvironment {
            pub m_tlsAccessor: root::AZ::EnvironmentVariable,
            pub m_stackPrevEnvironment: *mut root::AZ::EBusEnvironment,
            pub m_busContexts: root::AZStd::vector<
                root::AZStd::pair<*mut root::AZ::Internal::ContextBase, bool>,
                root::AZ::OSStdAllocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?ActivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_ActivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?DeactivateOnCurrentThread@EBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_DeactivateOnCurrentThread(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@EBusEnvironment@AZ@@SAPEAV12@XZ"]
            pub fn EBusEnvironment_Create() -> *mut root::AZ::EBusEnvironment;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@EBusEnvironment@AZ@@SAXPEAV12@@Z"]
            pub fn EBusEnvironment_Destroy(environment: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}?FindContext@EBusEnvironment@AZ@@QEAAPEAVContextBase@Internal@2@H@Z"]
            pub fn EBusEnvironment_FindContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase;
        }
        extern "C" {
            #[link_name = "\u{1}?InsertContext@EBusEnvironment@AZ@@QEAA_NHPEAVContextBase@Internal@2@_N@Z"]
            pub fn EBusEnvironment_InsertContext(
                this: *mut root::AZ::EBusEnvironment,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0EBusEnvironment@AZ@@QEAA@XZ"]
            pub fn EBusEnvironment_EBusEnvironment(this: *mut root::AZ::EBusEnvironment);
        }
        extern "C" {
            #[link_name = "\u{1}??_DEBusEnvironment@AZ@@QEAAXXZ"]
            pub fn EBusEnvironment_EBusEnvironment_destructor(this: *mut root::AZ::EBusEnvironment);
        }
        impl EBusEnvironment {
            #[inline]
            pub unsafe fn ActivateOnCurrentThread(&mut self) {
                EBusEnvironment_ActivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn DeactivateOnCurrentThread(&mut self) {
                EBusEnvironment_DeactivateOnCurrentThread(self)
            }
            #[inline]
            pub unsafe fn Create() -> *mut root::AZ::EBusEnvironment {
                EBusEnvironment_Create()
            }
            #[inline]
            pub unsafe fn Destroy(environment: *mut root::AZ::EBusEnvironment) {
                EBusEnvironment_Destroy(environment)
            }
            #[inline]
            pub unsafe fn FindContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
            ) -> *mut root::AZ::Internal::ContextBase {
                EBusEnvironment_FindContext(self, tlsKey)
            }
            #[inline]
            pub unsafe fn InsertContext(
                &mut self,
                tlsKey: ::std::os::raw::c_int,
                context: *mut root::AZ::Internal::ContextBase,
                isTakeOwnership: bool,
            ) -> bool {
                EBusEnvironment_InsertContext(self, tlsKey, context, isTakeOwnership)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                EBusEnvironment_EBusEnvironment(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                EBusEnvironment_EBusEnvironment_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusEnvironmentStoragePolicy {
            pub _address: u8,
        }
        pub const EBusAddressPolicy_Single: root::AZ::EBusAddressPolicy = 0;
        pub const EBusAddressPolicy_ById: root::AZ::EBusAddressPolicy = 1;
        pub const EBusAddressPolicy_ByIdAndOrdered: root::AZ::EBusAddressPolicy = 2;
        pub type EBusAddressPolicy = i32;
        pub const EBusHandlerPolicy_Single: root::AZ::EBusHandlerPolicy = 0;
        pub const EBusHandlerPolicy_Multiple: root::AZ::EBusHandlerPolicy = 1;
        pub const EBusHandlerPolicy_MultipleAndOrdered: root::AZ::EBusHandlerPolicy = 2;
        pub type EBusHandlerPolicy = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusConnectionPolicy {
            pub _address: u8,
        }
        pub type EBusConnectionPolicy_BusPtr = [u8; 0usize];
        pub type EBusConnectionPolicy_BusIdType = [u8; 0usize];
        pub type EBusConnectionPolicy_HandlerNode = [u8; 0usize];
        pub type EBusConnectionPolicy_Context = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusGlobalStoragePolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusThreadLocalStoragePolicy {
            pub _address: u8,
        }
        pub type EBusQueuePolicy_BusMessageCall = root::AZ::Internal::NullBusMessageCall;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct BusHandlerCompareDefault {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterNode<Interface> {
            pub _base: root::AZStd::intrusive_multiset_node<root::AZ::EBusRouterNode<Interface>>,
            pub m_handler: *mut Interface,
            pub m_order: ::std::os::raw::c_int,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Interface>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusRouterPolicy {
            pub _address: u8,
        }
        pub type EBusRouterPolicy_RouterNode = u8;
        pub type EBusRouterPolicy_Container = u8;
        pub const EBusRouterPolicy_EventProcessingState_ContinueProcess:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListeners:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub const EBusRouterPolicy_EventProcessingState_SkipListenersAndRouters:
            root::AZ::EBusRouterPolicy_EventProcessingState = 0;
        pub type EBusRouterPolicy_EventProcessingState = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HphaSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HeapSchema {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SystemAllocator {
            pub _base: root::AZ::IAllocator,
            pub m_isCustom: bool,
            pub m_allocator: *mut root::AZ::IAllocatorAllocate,
            pub m_ownsOSAllocator: bool,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor {
            pub m_custom: *mut root::AZ::IAllocatorAllocate,
            pub m_heap: root::AZ::SystemAllocator_Descriptor_Heap,
            pub m_allocationRecords: bool,
            pub m_stackRecordLevels: ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SystemAllocator_Descriptor_Heap {
            pub m_pageSize: ::std::os::raw::c_uint,
            pub m_poolPageSize: ::std::os::raw::c_uint,
            pub m_isPoolAllocations: bool,
            pub m_numFixedMemoryBlocks: ::std::os::raw::c_int,
            pub m_fixedMemoryBlocks: [*mut ::std::os::raw::c_void; 3usize],
            pub m_fixedMemoryBlocksByteSize: [usize; 3usize],
            pub m_subAllocator: *mut root::AZ::IAllocatorAllocate,
            pub m_systemChunkSize: usize,
        }
        pub const SystemAllocator_Descriptor_Heap_m_defaultPageSize: ::std::os::raw::c_int = 65536;
        pub const SystemAllocator_Descriptor_Heap_m_defaultPoolPageSize: ::std::os::raw::c_int =
            4096;
        pub const SystemAllocator_Descriptor_Heap_m_memoryBlockAlignment: ::std::os::raw::c_int =
            65536;
        pub const SystemAllocator_Descriptor_Heap_m_maxNumFixedBlocks: ::std::os::raw::c_int = 3;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_TYPEINFO_Enable(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Create@SystemAllocator@AZ@@QEAA_NAEBUDescriptor@12@@Z"]
            pub fn SystemAllocator_Create(
                this: *mut root::AZ::SystemAllocator,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Destroy@SystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_Destroy(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@QEAA@XZ"]
            pub fn SystemAllocator_SystemAllocator(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}??0SystemAllocator@AZ@@IEAA@AEBV01@@Z"]
            pub fn SystemAllocator_SystemAllocator1(
                this: *mut root::AZ::SystemAllocator,
                arg1: *const root::AZ::SystemAllocator,
            );
        }
        impl SystemAllocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                SystemAllocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Create(
                &mut self,
                desc: *const root::AZ::SystemAllocator_Descriptor,
            ) -> bool {
                SystemAllocator_Create(self, desc)
            }
            #[inline]
            pub unsafe fn Destroy(&mut self) {
                SystemAllocator_Destroy(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SystemAllocator_SystemAllocator(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::AZ::SystemAllocator) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SystemAllocator_SystemAllocator1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DSystemAllocator@AZ@@QEAAXXZ"]
            pub fn SystemAllocator_SystemAllocator_destructor(this: *mut root::AZ::SystemAllocator);
        }
        extern "C" {
            #[link_name = "\u{1}?Allocate@SystemAllocator@AZ@@UEAAPEAX_K0HPEBD1HI@Z"]
            pub fn SystemAllocator_Allocate(
                this: *mut ::std::os::raw::c_void,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
                flags: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                fileName: *const ::std::os::raw::c_char,
                lineNum: ::std::os::raw::c_int,
                suppressStackRecord: ::std::os::raw::c_uint,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?DeAllocate@SystemAllocator@AZ@@UEAAXPEAX_K1@Z"]
            pub fn SystemAllocator_DeAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                byteSize: root::AZ::IAllocatorAllocate_size_type,
                alignment: root::AZ::IAllocatorAllocate_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ReAllocate@SystemAllocator@AZ@@UEAAPEAXPEAX_K1@Z"]
            pub fn SystemAllocator_ReAllocate(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
                newAlignment: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?Resize@SystemAllocator@AZ@@UEAA_KPEAX_K@Z"]
            pub fn SystemAllocator_Resize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
                newSize: root::AZ::IAllocatorAllocate_size_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?AllocationSize@SystemAllocator@AZ@@UEAA_KPEAX@Z"]
            pub fn SystemAllocator_AllocationSize(
                this: *mut ::std::os::raw::c_void,
                ptr: root::AZ::IAllocatorAllocate_pointer_type,
            ) -> root::AZ::IAllocatorAllocate_size_type;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullMutex {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusId {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NullBusIdCompare {
            _unused: [u8; 0],
        }
        pub mod BusInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusImplTraits {
                pub _address: u8,
            }
            pub type EBusImplTraits_Traits<BusTraits> = BusTraits;
            pub type EBusImplTraits_AllocatorType = [u8; 0usize];
            pub type EBusImplTraits_InterfaceType<Interface> = Interface;
            pub type EBusImplTraits_Events<Interface> = Interface;
            pub type EBusImplTraits_BusIdType = [u8; 0usize];
            pub type EBusImplTraits_BusIdOrderCompare = [u8; 0usize];
            pub type EBusImplTraits_MutexType = [u8; 0usize];
            pub type EBusImplTraits_BusesContainer = u8;
            pub type EBusImplTraits_EventQueueMutexType = [u8; 0usize];
            pub type EBusImplTraits_BusPtr = root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            pub type EBusImplTraits_HandlerNode =
                root::AZ::BusInternal::EBusImplTraits_BusesContainer;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventer {
                pub _address: u8,
            }
            pub type EBusEventer_BusIdType = [u8; 0usize];
            pub type EBusEventer_BusPtr = [u8; 0usize];
            pub type EBusEventer_MultiHandler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventEnumerator {
                pub _address: u8,
            }
            pub type EBusEventEnumerator_BusIdType = [u8; 0usize];
            pub type EBusEventEnumerator_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcaster {
                pub _address: u8,
            }
            pub type EBusBroadcaster_Handler = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusNullQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastQueue {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusEventQueue {
                pub _address: u8,
            }
            pub type EBusEventQueue_BusIdType = [u8; 0usize];
            pub type EBusEventQueue_BusPtr = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct EBusBroadcastEnumerator {
                pub _address: u8,
            }
            pub type EventDispatcher = [u8; 0usize];
            #[repr(C)]
            pub struct EBusImpl {
                pub _address: u8,
            }
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type ArgumentValidatorHelper_is_non_const_lvalue_reference = u8;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusReduceResult<T, Aggregator> {
            pub value: T,
            pub unary: Aggregator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Aggregator>>,
        }
        pub type EBusArithmericResult<T, Arithmetic> = root::AZ::EBusReduceResult<T, Arithmetic>;
        pub type EBusLogicalResult<T, Operator> = root::AZ::EBusReduceResult<T, Operator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EBusAggregateResults {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBusTraits {
            pub _address: u8,
        }
        pub type EBusTraits_AllocatorType = root::AZStd::allocator;
        pub type EBusTraits_BusIdType = root::AZ::NullBusId;
        pub type EBusTraits_BusIdOrderCompare = root::AZ::NullBusIdCompare;
        pub type EBusTraits_BusHandlerOrderCompare = root::AZ::BusHandlerCompareDefault;
        pub type EBusTraits_MutexType = root::AZ::NullMutex;
        pub type EBusTraits_EventQueueMutexType = root::AZ::NullMutex;
        pub type EBusTraits_ConnectionPolicy = root::AZ::EBusConnectionPolicy;
        pub type EBusTraits_StoragePolicy = root::AZ::EBusEnvironmentStoragePolicy;
        pub type EBusTraits_RouterPolicy = u8;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@EBusTraits@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static EBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@EBusTraits@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static EBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        pub const EBusTraits_EnableEventQueue: bool = false;
        pub const EBusTraits_EventQueueingActiveByDefault: bool = true;
        pub const EBusTraits_EnableQueuedReferences: bool = false;
        pub const EBusTraits_LocklessDispatch: bool = false;
        #[repr(C)]
        pub struct EBus {
            pub _address: u8,
        }
        pub type EBus_ImplTraits = root::AZ::BusInternal::EBusImplTraits;
        pub type EBus_BaseImpl = root::AZ::BusInternal::EBusImpl;
        pub type EBus_Traits = root::AZ::EBus_ImplTraits;
        pub type EBus_ThisType = root::AZ::EBus;
        pub type EBus_AllocatorType = root::AZ::EBus_ImplTraits;
        pub type EBus_InterfaceType = root::AZ::EBus_ImplTraits;
        pub type EBus_Events = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusIdOrderCompare = root::AZ::EBus_ImplTraits;
        pub type EBus_MutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusesContainer = root::AZ::EBus_ImplTraits;
        pub type EBus_EventQueueMutexType = root::AZ::EBus_ImplTraits;
        pub type EBus_BusPtr = root::AZ::EBus_ImplTraits;
        pub type EBus_HandlerNode = root::AZ::EBus_ImplTraits;
        pub type EBus_QueuePolicy = u8;
        pub type EBus_ConnectionPolicy = root::AZ::EBus_Traits;
        pub type EBus_CallstackEntry = root::AZ::Internal::CallstackEntry;
        pub type EBus_Router = root::AZ::Internal::EBusRouter<root::AZ::EBus_ThisType>;
        pub type EBus_NestedVersionRouter =
            root::AZ::Internal::EBusNestedVersionRouter<root::AZ::EBus_ThisType>;
        pub type EBus_RouterPolicy = root::AZ::EBus_Traits;
        pub type EBus_RouterProcessingState = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_Context {
            pub _base: root::AZ::Internal::ContextBase,
            pub m_buses: root::AZ::EBus_BusesContainer,
            pub m_contextMutex: root::AZ::EBus_Context_ContextMutexType,
            pub m_queue: root::AZ::EBus_QueuePolicy,
            pub m_routing: root::AZ::EBus_RouterPolicy,
            pub m_callstackRoots: root::AZStd::unordered_map,
            pub s_callstack: root::AZ::EBus_Context_CallstackEntryStorageType,
            pub m_dispatches: root::AZStd::atomic_uint,
        }
        pub type EBus_Context_ContextMutexType = root::AZStd::conditional_t;
        pub type EBus_Context_DispatchLockGuard = root::AZStd::conditional_t;
        pub type EBus_Context_CallstackEntryBase = root::AZ::Internal::CallstackEntryBase;
        pub type EBus_Context_CallstackEntryRoot = root::AZ::Internal::CallstackEntryRoot;
        pub type EBus_Context_CallstackEntryStorageType = u8;
        pub type EBus_StoragePolicy = root::AZ::EBus_Traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct EBus_RouterCallstackEntry {
            pub _base: root::AZ::EBus_CallstackEntry,
            pub m_iterator: root::AZ::EBus_RouterCallstackEntry_Iterator,
            pub m_processingState: root::AZ::EBus_RouterProcessingState,
            pub m_isQueued: bool,
            pub m_isReverse: bool,
        }
        pub type EBus_RouterCallstackEntry_Iterator = root::AZ::EBus_RouterPolicy;
        #[repr(C)]
        pub struct EntityId {
            pub m_id: root::AZ::u64,
        }
        pub const EntityId_InvalidEntityId: root::AZ::u64 = 4294967295;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@EntityId@AZ@@QEAAXXZ"]
            pub fn EntityId_TYPEINFO_Enable(this: *mut root::AZ::EntityId);
        }
        impl EntityId {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                EntityId_TYPEINFO_Enable(self)
            }
        }
        pub type ComponentId = root::AZ::u64;
        #[repr(C)]
        pub struct ComponentBus__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentBus {
            pub vtable_: *const ComponentBus__bindgen_vtable,
        }
        pub type ComponentBus_BusIdType = root::AZ::EntityId;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@ComponentBus@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static ComponentBus_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        #[repr(C)]
        pub struct ComponentConfig__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentConfig {
            pub vtable_: *const ComponentConfig__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ComponentConfig@AZ@@QEAAXXZ"]
            pub fn ComponentConfig_TYPEINFO_Enable(this: *mut root::AZ::ComponentConfig);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@ComponentConfig@AZ@@QEAAXXZ"]
            pub fn ComponentConfig_RTTI_Enable(this: *mut root::AZ::ComponentConfig);
        }
        impl ComponentConfig {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ComponentConfig_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                ComponentConfig_RTTI_Enable(self)
            }
        }
        #[repr(C)]
        pub struct EntityComponentIdPair__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct EntityComponentIdPair {
            pub vtable_: *const EntityComponentIdPair__bindgen_vtable,
            pub m_entityId: root::AZ::EntityId,
            pub m_componentId: root::AZ::ComponentId,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@EntityComponentIdPair@AZ@@QEAAXXZ"]
            pub fn EntityComponentIdPair_TYPEINFO_Enable(
                this: *mut root::AZ::EntityComponentIdPair,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@EntityComponentIdPair@AZ@@QEAAXXZ"]
            pub fn EntityComponentIdPair_RTTI_Enable(this: *mut root::AZ::EntityComponentIdPair);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@EntityComponentIdPair@AZ@@SAXPEAVReflectContext@2@@Z"]
            pub fn EntityComponentIdPair_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl EntityComponentIdPair {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                EntityComponentIdPair_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                EntityComponentIdPair_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                EntityComponentIdPair_Reflect(context)
            }
        }
        #[repr(C)]
        pub struct EntityComponentBus__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct EntityComponentBus {
            pub vtable_: *const EntityComponentBus__bindgen_vtable,
        }
        pub type EntityComponentBus_BusIdType = root::AZ::EntityComponentIdPair;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@EntityComponentBus@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static EntityComponentBus_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ScriptTimePoint {
            pub m_timePoint: root::AZStd::chrono::system_clock_time_point,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ScriptTimePoint@AZ@@QEAAXXZ"]
            pub fn ScriptTimePoint_TYPEINFO_Enable(this: *mut root::AZ::ScriptTimePoint);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ScriptTimePoint@AZ@@SAXPEAVReflectContext@2@@Z"]
            pub fn ScriptTimePoint_Reflect(reflection: *mut root::AZ::ReflectContext);
        }
        impl ScriptTimePoint {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ScriptTimePoint_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(reflection: *mut root::AZ::ReflectContext) {
                ScriptTimePoint_Reflect(reflection)
            }
        }
        pub const ComponentTickBus_TICK_FIRST: root::AZ::ComponentTickBus = 0;
        pub const ComponentTickBus_TICK_PLACEMENT: root::AZ::ComponentTickBus = 50;
        pub const ComponentTickBus_TICK_INPUT: root::AZ::ComponentTickBus = 75;
        pub const ComponentTickBus_TICK_GAME: root::AZ::ComponentTickBus = 80;
        pub const ComponentTickBus_TICK_ANIMATION: root::AZ::ComponentTickBus = 100;
        pub const ComponentTickBus_TICK_PHYSICS: root::AZ::ComponentTickBus = 200;
        pub const ComponentTickBus_TICK_ATTACHMENT: root::AZ::ComponentTickBus = 500;
        pub const ComponentTickBus_TICK_PRE_RENDER: root::AZ::ComponentTickBus = 750;
        pub const ComponentTickBus_TICK_DEFAULT: root::AZ::ComponentTickBus = 1000;
        pub const ComponentTickBus_TICK_UI: root::AZ::ComponentTickBus = 2000;
        pub const ComponentTickBus_TICK_LAST: root::AZ::ComponentTickBus = 100000;
        pub type ComponentTickBus = i32;
        #[repr(C)]
        pub struct TickEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct TickEvents {
            pub vtable_: *const TickEvents__bindgen_vtable,
            pub m_tickOrder: ::std::os::raw::c_int,
        }
        pub type TickEvents_EventQueueMutexType = root::AZStd::recursive_mutex;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TickEvents_BusHandlerOrderCompare {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@TickEvents@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static TickEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub const TickEvents_EnableEventQueue: bool = true;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@TickEvents@AZ@@QEAAXXZ"]
            pub fn TickEvents_TYPEINFO_Enable(this: *mut root::AZ::TickEvents);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@TickEvents@AZ@@QEAAXXZ"]
            pub fn TickEvents_RTTI_Enable(this: *mut root::AZ::TickEvents);
        }
        impl TickEvents {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                TickEvents_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                TickEvents_RTTI_Enable(self)
            }
        }
        pub type TickBus = root::AZ::EBus;
        #[repr(C)]
        pub struct TickRequests__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct TickRequests {
            pub vtable_: *const TickRequests__bindgen_vtable,
        }
        pub type TickRequestBus = root::AZ::EBus;
        #[repr(C)]
        pub struct SystemTickEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SystemTickEvents {
            pub vtable_: *const SystemTickEvents__bindgen_vtable,
        }
        pub type SystemTickEvents_EventQueueMutexType = root::AZStd::mutex;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@SystemTickEvents@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static SystemTickEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub const SystemTickEvents_EnableEventQueue: bool = true;
        pub type SystemTickBus = root::AZ::EBus;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AssetEventHandler {
            _unused: [u8; 0],
        }
        pub mod Data {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetManager {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEntry {
                _unused: [u8; 0],
            }
            pub type AssetType = root::AZ::Uuid;
            pub mod AssetInternal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                extern "C" {
                    #[link_name = "\u{1}?IsValidAssetType@AssetInternal@Data@AZ@@YA_NAEBUUuid@3@PEAVSerializeContext@3@@Z"]
                    pub fn IsValidAssetType(
                        type_: *const root::AZ::Data::AssetType,
                        serializeContext: *mut root::AZ::SerializeContext,
                    ) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?QueueAssetLoad@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@PEAVAssetData@23@AEBV?$function@$$A6A_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@@Z@AZStd@@@Z"]
                    pub fn QueueAssetLoad(
                        assetData: *mut root::AZ::Data::AssetData,
                        assetLoadFilterCB: *const root::AZ::Data::AssetFilterCB,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?GetAsset@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@AEBUAssetId@23@AEBUUuid@3@_N2@Z"]
                    pub fn GetAsset(
                        id: *const root::AZ::Data::AssetId,
                        type_: *const root::AZ::Data::AssetType,
                        queueLoad: bool,
                        isCreate: bool,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?UpdateAssetInfo@AssetInternal@Data@AZ@@YAXAEAUAssetId@23@AEAV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
                    pub fn UpdateAssetInfo(
                        id: *mut root::AZ::Data::AssetId,
                        assetHint: *mut root::AZStd::string,
                    );
                }
                extern "C" {
                    #[link_name = "\u{1}?ReloadAsset@AssetInternal@Data@AZ@@YA_NPEAVAssetData@23@@Z"]
                    pub fn ReloadAsset(assetData: *mut root::AZ::Data::AssetData) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?SaveAsset@AssetInternal@Data@AZ@@YA_NPEAVAssetData@23@@Z"]
                    pub fn SaveAsset(assetData: *mut root::AZ::Data::AssetData) -> bool;
                }
                extern "C" {
                    #[link_name = "\u{1}?GetAssetData@AssetInternal@Data@AZ@@YA?AV?$Asset@VAssetData@Data@AZ@@@23@AEBUAssetId@23@@Z"]
                    pub fn GetAssetData(
                        id: *const root::AZ::Data::AssetId,
                    ) -> root::AZ::Data::Asset;
                }
                extern "C" {
                    #[link_name = "\u{1}?ResolveAssetId@AssetInternal@Data@AZ@@YA?AUAssetId@23@AEBU423@@Z"]
                    pub fn ResolveAssetId(
                        id: *const root::AZ::Data::AssetId,
                    ) -> root::AZ::Data::AssetId;
                }
            }
            pub type AssetPtr = *mut root::AZ::Data::AssetData;
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetId {
                pub m_guid: root::AZ::Uuid,
                pub m_subId: root::AZ::u32,
                pub __bindgen_padding_0: [u32; 3usize],
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?IsValid@AssetId@Data@AZ@@QEBA_NXZ"]
                pub fn AssetId_IsValid(this: *const root::AZ::Data::AssetId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?SetInvalid@AssetId@Data@AZ@@QEAAXXZ"]
                pub fn AssetId_SetInvalid(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}?CreateString@AssetId@Data@AZ@@SA?AU123@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
                pub fn AssetId_CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@XZ"]
                pub fn AssetId_AssetId(this: *mut root::AZ::Data::AssetId);
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetId@Data@AZ@@QEAA@AEBUUuid@2@I@Z"]
                pub fn AssetId_AssetId1(
                    this: *mut root::AZ::Data::AssetId,
                    guid: *const root::AZ::Uuid,
                    sudId: root::AZ::u32,
                );
            }
            impl AssetId {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetId_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn IsValid(&self) -> bool {
                    AssetId_IsValid(self)
                }
                #[inline]
                pub unsafe fn SetInvalid(&mut self) {
                    AssetId_SetInvalid(self)
                }
                #[inline]
                pub unsafe fn CreateString(
                    input: root::AZStd::string_view,
                ) -> root::AZ::Data::AssetId {
                    AssetId_CreateString(input)
                }
                #[inline]
                pub unsafe fn new() -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetId_AssetId(__bindgen_tmp.as_mut_ptr());
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(guid: *const root::AZ::Uuid, sudId: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetId_AssetId1(__bindgen_tmp.as_mut_ptr(), guid, sudId);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct AssetData__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetData {
                pub vtable_: *const AssetData__bindgen_vtable,
                pub __bindgen_padding_0: [u32; 2usize],
                pub m_useCount: root::AZStd::atomic_int,
                pub m_status: root::AZStd::atomic_int,
                pub __bindgen_padding_1: u64,
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_creationToken: ::std::os::raw::c_int,
                pub __bindgen_padding_2: [u32; 3usize],
            }
            pub const AssetData_AssetStatus_NotLoaded: root::AZ::Data::AssetData_AssetStatus = 0;
            pub const AssetData_AssetStatus_Loading: root::AZ::Data::AssetData_AssetStatus = 1;
            pub const AssetData_AssetStatus_ReadyPreNotify: root::AZ::Data::AssetData_AssetStatus =
                2;
            pub const AssetData_AssetStatus_Ready: root::AZ::Data::AssetData_AssetStatus = 3;
            pub const AssetData_AssetStatus_Error: root::AZ::Data::AssetData_AssetStatus = 4;
            pub type AssetData_AssetStatus = i32;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_RTTI_Enable(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?Acquire@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Acquire(this: *mut root::AZ::Data::AssetData);
            }
            extern "C" {
                #[link_name = "\u{1}?Release@AssetData@Data@AZ@@QEAAXXZ"]
                pub fn AssetData_Release(this: *mut root::AZ::Data::AssetData);
            }
            impl AssetData {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetData_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetData_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Acquire(&mut self) {
                    AssetData_Acquire(self)
                }
                #[inline]
                pub unsafe fn Release(&mut self) {
                    AssetData_Release(self)
                }
            }
            pub const AssetLoadBehavior_Default: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_PreLoad: root::AZ::Data::AssetLoadBehavior = 0;
            pub const AssetLoadBehavior_QueueLoad: root::AZ::Data::AssetLoadBehavior = 1;
            pub const AssetLoadBehavior_NoLoad: root::AZ::Data::AssetLoadBehavior = 2;
            pub const AssetLoadBehavior_Count: root::AZ::Data::AssetLoadBehavior = 3;
            pub type AssetLoadBehavior = u8;
            pub type AssetFilterCB = [u64; 5usize];
            #[repr(C)]
            pub struct Asset {
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_assetData: *mut root::AZ::Data::AssetData,
                pub m_loadBehavior: root::AZ::Data::AssetLoadBehavior,
                pub m_assetHint: root::AZStd::string,
            }
            pub type Asset_ThisType = root::AZ::Data::Asset;
            #[repr(C)]
            pub struct AssetEvents__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetEvents {
                pub vtable_: *const AssetEvents__bindgen_vtable,
            }
            pub type AssetEvents_MutexType = root::AZStd::recursive_mutex;
            pub type AssetEvents_BusIdType = root::AZ::Data::AssetId;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetEvents_AssetConnectionPolicy {
                pub _address: u8,
            }
            pub type AssetEvents_ConnectionPolicy =
                root::AZ::Data::AssetEvents_AssetConnectionPolicy;
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetEvents@Data@AZ@@2W4EBusAddressPolicy@3@B"]
                pub static AssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
            pub const AssetEvents_EnableEventQueue: bool = true;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetEvents@Data@AZ@@QEAAXXZ"]
                pub fn AssetEvents_RTTI_Enable(this: *mut root::AZ::Data::AssetEvents);
            }
            impl AssetEvents {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetEvents_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetEvents_RTTI_Enable(self)
                }
            }
            pub type AssetBus = root::AZ::EBus;
            #[repr(C)]
            pub struct AssetBusCallbacks__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct AssetBusCallbacks {
                pub vtable_: *const AssetBusCallbacks__bindgen_vtable,
                pub _base: [u64; 5usize],
                pub m_onAssetReadyCB: root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                pub m_onAssetMovedCB: root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                pub m_onAssetReloadedCB: root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                pub m_onAssetSavedCB: root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                pub m_onAssetUnloadedCB: root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                pub m_onAssetErrorCB: root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
            }
            pub type AssetBusCallbacks_AssetReadyCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetMovedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetReloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetSavedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetUnloadedCB = [u64; 5usize];
            pub type AssetBusCallbacks_AssetErrorCB = [u64; 5usize];
            extern "C" {
                #[link_name = "\u{1}?SetCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@5@0AEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@5@AEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@5@0@Z"]
                pub fn AssetBusCallbacks_SetCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?ClearCallbacks@AssetBusCallbacks@Data@AZ@@QEAAXXZ"]
                pub fn AssetBusCallbacks_ClearCallbacks(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReadyCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReadyCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetMovedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@PEAXAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetMovedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetReloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetReloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetSavedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@_NAEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetSavedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetUnloadedCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXAEBUAssetId@Data@AZ@@AEBUUuid@3@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetUnloadedCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?SetOnAssetErrorCallback@AssetBusCallbacks@Data@AZ@@QEAAXAEBV?$function@$$A6AXV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@AEAVAssetBusCallbacks@23@@Z@AZStd@@@Z"]
                pub fn AssetBusCallbacks_SetOnAssetErrorCallback(
                    this: *mut root::AZ::Data::AssetBusCallbacks,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                );
            }
            impl AssetBusCallbacks {
                #[inline]
                pub unsafe fn SetCallbacks(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetCallbacks(
                        self, readyCB, movedCB, reloadedCB, savedCB, unloadedCB, errorCB,
                    )
                }
                #[inline]
                pub unsafe fn ClearCallbacks(&mut self) {
                    AssetBusCallbacks_ClearCallbacks(self)
                }
                #[inline]
                pub unsafe fn SetOnAssetReadyCallback(
                    &mut self,
                    readyCB: *const root::AZ::Data::AssetBusCallbacks_AssetReadyCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReadyCallback(self, readyCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetMovedCallback(
                    &mut self,
                    movedCB: *const root::AZ::Data::AssetBusCallbacks_AssetMovedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetMovedCallback(self, movedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetReloadedCallback(
                    &mut self,
                    reloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetReloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetReloadedCallback(self, reloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetSavedCallback(
                    &mut self,
                    savedCB: *const root::AZ::Data::AssetBusCallbacks_AssetSavedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetSavedCallback(self, savedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetUnloadedCallback(
                    &mut self,
                    unloadedCB: *const root::AZ::Data::AssetBusCallbacks_AssetUnloadedCB,
                ) {
                    AssetBusCallbacks_SetOnAssetUnloadedCallback(self, unloadedCB)
                }
                #[inline]
                pub unsafe fn SetOnAssetErrorCallback(
                    &mut self,
                    errorCB: *const root::AZ::Data::AssetBusCallbacks_AssetErrorCB,
                ) {
                    AssetBusCallbacks_SetOnAssetErrorCallback(self, errorCB)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReady@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReady(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetMoved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@PEAX@Z"]
                pub fn AssetBusCallbacks_OnAssetMoved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    oldDataPointer: *mut ::std::os::raw::c_void,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetReloaded@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetReloaded(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetSaved@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@_N@Z"]
                pub fn AssetBusCallbacks_OnAssetSaved(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                    isSuccessful: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetUnloaded@AssetBusCallbacks@Data@AZ@@UEAAXUAssetId@23@UUuid@3@@Z"]
                pub fn AssetBusCallbacks_OnAssetUnloaded(
                    this: *mut ::std::os::raw::c_void,
                    assetId: root::AZ::Data::AssetId,
                    assetType: root::AZ::Data::AssetType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?OnAssetError@AssetBusCallbacks@Data@AZ@@UEAAXV?$Asset@VAssetData@Data@AZ@@@23@@Z"]
                pub fn AssetBusCallbacks_OnAssetError(
                    this: *mut ::std::os::raw::c_void,
                    asset: root::AZ::Data::Asset,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?AssetFilterNoAssetLoading@Data@AZ@@YA_NAEBV?$Asset@VAssetData@Data@AZ@@@12@@Z"]
                pub fn AssetFilterNoAssetLoading(arg1: *const root::AZ::Data::Asset) -> bool;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetInfo {
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_sizeBytes: root::AZ::u64,
                pub m_relativePath: root::AZStd::string,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetInfo@Data@AZ@@QEAAXXZ"]
                pub fn AssetInfo_TYPEINFO_Enable(this: *mut root::AZ::Data::AssetInfo);
            }
            impl AssetInfo {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetInfo_TYPEINFO_Enable(self)
                }
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct ProductDependency {
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_flags: [u32; 2usize],
                pub __bindgen_padding_0: u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ProductDependency@Data@AZ@@QEAAXXZ"]
                pub fn ProductDependency_TYPEINFO_Enable(
                    this: *mut root::AZ::Data::ProductDependency,
                );
            }
            impl ProductDependency {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ProductDependency_TYPEINFO_Enable(self)
                }
            }
            #[repr(C)]
            pub struct AssetCatalogRequests__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetCatalogRequests {
                pub vtable_: *const AssetCatalogRequests__bindgen_vtable,
            }
            pub type AssetCatalogRequests_MutexType = root::AZStd::recursive_mutex;
            pub type AssetCatalogRequests_BeginAssetEnumerationCB = [u64; 5usize];
            pub type AssetCatalogRequests_AssetEnumerationCB = [u64; 5usize];
            pub type AssetCatalogRequests_EndAssetEnumerationCB = [u64; 5usize];
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetCatalogRequests@Data@AZ@@2W4EBusHandlerPolicy@3@B"]
                pub static AssetCatalogRequests_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            pub type AssetCatalogRequestBus = root::AZ::EBus;
            #[repr(C)]
            pub struct AssetManagerEvents__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetManagerEvents {
                pub vtable_: *const AssetManagerEvents__bindgen_vtable,
            }
            pub type AssetManagerEvents_MutexType = root::AZStd::recursive_mutex;
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetManagerEvents@Data@AZ@@2W4EBusHandlerPolicy@3@B"]
                pub static AssetManagerEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            pub type AssetManagerBus = root::AZ::EBus;
            #[repr(C)]
            pub struct AssetManagerNotifications__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetManagerNotifications {
                pub vtable_: *const AssetManagerNotifications__bindgen_vtable,
            }
            pub type AssetManagerNotifications_MutexType = root::AZStd::recursive_mutex;
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetManagerNotifications@Data@AZ@@2W4EBusHandlerPolicy@3@B"]
                pub static AssetManagerNotifications_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            pub type AssetManagerNotificationBus = root::AZ::EBus;
        }
        extern "C" {
            #[link_name = "\u{1}?ScriptTimePoint_GetSeconds@AZ@@YANAEAVScriptTimePoint@1@@Z"]
            pub fn ScriptTimePoint_GetSeconds(self_: *mut root::AZ::ScriptTimePoint) -> f64;
        }
        #[repr(C)]
        pub struct NamedEntityId__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct NamedEntityId {
            pub vtable_: *const NamedEntityId__bindgen_vtable,
            pub _base: root::AZ::EntityId,
            pub m_entityName: root::AZStd::string,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@NamedEntityId@AZ@@QEAAXXZ"]
            pub fn NamedEntityId_TYPEINFO_Enable(this: *mut root::AZ::NamedEntityId);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@NamedEntityId@AZ@@QEAAXXZ"]
            pub fn NamedEntityId_RTTI_Enable(this: *mut root::AZ::NamedEntityId);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@NamedEntityId@AZ@@SAXPEAVReflectContext@2@@Z"]
            pub fn NamedEntityId_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@NamedEntityId@AZ@@QEBA?AV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@XZ"]
            pub fn NamedEntityId_ToString(
                this: *const root::AZ::NamedEntityId,
            ) -> root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}?GetName@NamedEntityId@AZ@@QEBA?AV?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@XZ"]
            pub fn NamedEntityId_GetName(
                this: *const root::AZ::NamedEntityId,
            ) -> root::AZStd::string_view;
        }
        extern "C" {
            #[link_name = "\u{1}??0NamedEntityId@AZ@@QEAA@XZ"]
            pub fn NamedEntityId_NamedEntityId(this: *mut root::AZ::NamedEntityId);
        }
        extern "C" {
            #[link_name = "\u{1}??0NamedEntityId@AZ@@QEAA@AEBVEntityId@1@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@@Z"]
            pub fn NamedEntityId_NamedEntityId1(
                this: *mut root::AZ::NamedEntityId,
                entityId: *const root::AZ::EntityId,
                entityName: root::AZStd::string_view,
            );
        }
        impl NamedEntityId {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                NamedEntityId_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                NamedEntityId_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                NamedEntityId_Reflect(context)
            }
            #[inline]
            pub unsafe fn ToString(&self) -> root::AZStd::string {
                NamedEntityId_ToString(self)
            }
            #[inline]
            pub unsafe fn GetName(&self) -> root::AZStd::string_view {
                NamedEntityId_GetName(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NamedEntityId_NamedEntityId(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                entityId: *const root::AZ::EntityId,
                entityName: root::AZStd::string_view,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                NamedEntityId_NamedEntityId1(__bindgen_tmp.as_mut_ptr(), entityId, entityName);
                __bindgen_tmp.assume_init()
            }
        }
        pub type StaticReflectionFunctionPtr =
            ::std::option::Option<unsafe extern "C" fn(context: *mut root::AZ::ReflectContext)>;
        pub type ReflectionFunction = root::AZStd::function;
        #[repr(C)]
        pub struct OnDemandReflectionOwner__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct OnDemandReflectionOwner {
            pub vtable_: *const OnDemandReflectionOwner__bindgen_vtable,
            pub m_reflectFunctions: root::AZStd::vector<
                root::AZStd::shared_ptr<root::AZ::Internal::ReflectionFunctionRef>,
                root::AZStd::allocator,
            >,
            pub m_reflectContext: *mut root::AZ::ReflectContext,
        }
        extern "C" {
            #[link_name = "\u{1}?AddReflectFunction@OnDemandReflectionOwner@AZ@@QEAAXUUuid@2@P6AXPEAVReflectContext@2@@Z@Z"]
            pub fn OnDemandReflectionOwner_AddReflectFunction(
                this: *mut root::AZ::OnDemandReflectionOwner,
                typeId: root::AZ::Uuid,
                reflectFunction: root::AZ::StaticReflectionFunctionPtr,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0OnDemandReflectionOwner@AZ@@IEAA@AEAVReflectContext@1@@Z"]
            pub fn OnDemandReflectionOwner_OnDemandReflectionOwner(
                this: *mut root::AZ::OnDemandReflectionOwner,
                context: *mut root::AZ::ReflectContext,
            );
        }
        impl OnDemandReflectionOwner {
            #[inline]
            pub unsafe fn AddReflectFunction(
                &mut self,
                typeId: root::AZ::Uuid,
                reflectFunction: root::AZ::StaticReflectionFunctionPtr,
            ) {
                OnDemandReflectionOwner_AddReflectFunction(self, typeId, reflectFunction)
            }
            #[inline]
            pub unsafe fn new(context: *mut root::AZ::ReflectContext) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OnDemandReflectionOwner_OnDemandReflectionOwner(
                    __bindgen_tmp.as_mut_ptr(),
                    context,
                );
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DOnDemandReflectionOwner@AZ@@QEAAXXZ"]
            pub fn OnDemandReflectionOwner_OnDemandReflectionOwner_destructor(
                this: *mut root::AZ::OnDemandReflectionOwner,
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OnDemandReflection {
            pub _address: u8,
        }
        pub type NoOnDemandReflectionResultType_type = root::std::true_type;
        pub type HasNoOnDemandReflection_Yes = ::std::os::raw::c_char;
        pub type HasNoOnDemandReflection_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasNoOnDemandReflection_Helper {
            pub _address: u8,
        }
        pub type HasNoOnDemandReflection_Helper_mfp = ::std::option::Option<unsafe extern "C" fn()>;
        pub type HasNoOnDemandReflection_type = u8;
        #[repr(C)]
        pub struct ReflectContext__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ReflectContext {
            pub vtable_: *const ReflectContext__bindgen_vtable,
            pub m_isRemoveReflection: bool,
            pub m_onDemandReflection: root::AZStd::unordered_map,
            pub m_toProcessOnDemandReflection: root::AZStd::vector<
                root::AZStd::pair<root::AZ::Uuid, root::AZ::StaticReflectionFunctionPtr>,
                root::AZStd::allocator,
            >,
            pub m_currentlyProcessingTypeIds: [u64; 5usize],
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ReflectContext@AZ@@QEAAXXZ"]
            pub fn ReflectContext_TYPEINFO_Enable(this: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@ReflectContext@AZ@@QEAAXXZ"]
            pub fn ReflectContext_RTTI_Enable(this: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?EnableRemoveReflection@ReflectContext@AZ@@QEAAXXZ"]
            pub fn ReflectContext_EnableRemoveReflection(this: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?DisableRemoveReflection@ReflectContext@AZ@@QEAAXXZ"]
            pub fn ReflectContext_DisableRemoveReflection(this: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?IsRemovingReflection@ReflectContext@AZ@@QEBA_NXZ"]
            pub fn ReflectContext_IsRemovingReflection(
                this: *const root::AZ::ReflectContext,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsOnDemandTypeReflected@ReflectContext@AZ@@QEAA_NUUuid@2@@Z"]
            pub fn ReflectContext_IsOnDemandTypeReflected(
                this: *mut root::AZ::ReflectContext,
                typeId: root::AZ::Uuid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ExecuteQueuedOnDemandReflections@ReflectContext@AZ@@QEAAXXZ"]
            pub fn ReflectContext_ExecuteQueuedOnDemandReflections(
                this: *mut root::AZ::ReflectContext,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0ReflectContext@AZ@@QEAA@XZ"]
            pub fn ReflectContext_ReflectContext(this: *mut root::AZ::ReflectContext);
        }
        impl ReflectContext {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ReflectContext_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                ReflectContext_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn EnableRemoveReflection(&mut self) {
                ReflectContext_EnableRemoveReflection(self)
            }
            #[inline]
            pub unsafe fn DisableRemoveReflection(&mut self) {
                ReflectContext_DisableRemoveReflection(self)
            }
            #[inline]
            pub unsafe fn IsRemovingReflection(&self) -> bool {
                ReflectContext_IsRemovingReflection(self)
            }
            #[inline]
            pub unsafe fn IsOnDemandTypeReflected(&mut self, typeId: root::AZ::Uuid) -> bool {
                ReflectContext_IsOnDemandTypeReflected(self, typeId)
            }
            #[inline]
            pub unsafe fn ExecuteQueuedOnDemandReflections(&mut self) {
                ReflectContext_ExecuteQueuedOnDemandReflections(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ReflectContext_ReflectContext(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Attribute__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct Attribute {
            pub vtable_: *const Attribute__bindgen_vtable,
            pub m_describesChildren: bool,
            pub m_childClassOwned: bool,
            pub m_contextData: root::std::unique_ptr,
        }
        pub type Attribute_ContextDeleter =
            ::std::option::Option<unsafe extern "C" fn(contextData: *mut ::std::os::raw::c_void)>;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@Attribute@AZ@@QEAAXXZ"]
            pub fn Attribute_TYPEINFO_Enable(this: *mut root::AZ::Attribute);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@Attribute@AZ@@QEAAXXZ"]
            pub fn Attribute_RTTI_Enable(this: *mut root::AZ::Attribute);
        }
        impl Attribute {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                Attribute_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                Attribute_RTTI_Enable(self)
            }
        }
        pub type AttributeId = root::AZ::u32;
        pub type AttributePair = root::AZStd::pair<root::AZ::AttributeId, *mut root::AZ::Attribute>;
        pub type AttributeArray =
            root::AZStd::vector<root::AZ::AttributePair, root::AZStd::allocator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct AttributeData<T> {
            pub _base: root::AZ::Attribute,
            pub m_data: T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AttributeMemberData {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AttributeFunction {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AttributeMemberFunction {
            pub _address: u8,
        }
        pub type AttributeContainerType = u8;
        pub type SuccessValue = u8;
        pub type FailureValue = u8;
        #[repr(C)]
        pub struct Outcome {
            pub __bindgen_anon_1: root::AZ::Outcome__bindgen_ty_1,
            pub m_isSuccess: bool,
        }
        pub type Outcome_ValueType<ValueT> = ValueT;
        pub type Outcome_ErrorType<ErrorT> = ErrorT;
        pub type Outcome_SuccessType = root::AZ::SuccessValue;
        pub type Outcome_FailureType = root::AZ::FailureValue;
        #[repr(C)]
        pub union Outcome__bindgen_ty_1 {
            pub m_success: u8,
            pub m_failure: u8,
            _bindgen_union_align: [u8; 0usize],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DefaultFailure {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Entity {
            _unused: [u8; 0],
        }
        pub type ComponentServiceType = root::AZ::u32;
        pub type ImmutableEntityVector =
            root::AZStd::vector<*const root::AZ::Entity, root::AZStd::allocator>;
        pub type ComponentTypeList = root::AZStd::vector<root::AZ::Uuid, root::AZStd::allocator>;
        pub type ComponentValidationResult = root::AZ::Outcome;
        #[repr(C)]
        pub struct Component__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct Component {
            pub vtable_: *const Component__bindgen_vtable,
            pub m_entity: *mut root::AZ::Entity,
            pub m_id: root::AZ::ComponentId,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@Component@AZ@@QEAAXXZ"]
            pub fn Component_TYPEINFO_Enable(this: *mut root::AZ::Component);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@Component@AZ@@QEAAXXZ"]
            pub fn Component_RTTI_Enable(this: *mut root::AZ::Component);
        }
        extern "C" {
            #[link_name = "\u{1}?GetEntityId@Component@AZ@@QEBA?AVEntityId@2@XZ"]
            pub fn Component_GetEntityId(this: *const root::AZ::Component) -> root::AZ::EntityId;
        }
        extern "C" {
            #[link_name = "\u{1}?GetNamedEntityId@Component@AZ@@QEBA?AVNamedEntityId@2@XZ"]
            pub fn Component_GetNamedEntityId(
                this: *const root::AZ::Component,
            ) -> root::AZ::NamedEntityId;
        }
        extern "C" {
            #[link_name = "\u{1}?SetConfiguration@Component@AZ@@QEAA_NAEBVComponentConfig@2@@Z"]
            pub fn Component_SetConfiguration(
                this: *mut root::AZ::Component,
                config: *const root::AZ::ComponentConfig,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetConfiguration@Component@AZ@@QEBA_NAEAVComponentConfig@2@@Z"]
            pub fn Component_GetConfiguration(
                this: *const root::AZ::Component,
                outConfig: *mut root::AZ::ComponentConfig,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?SetEntity@Component@AZ@@IEAAXPEAVEntity@2@@Z"]
            pub fn Component_SetEntity(
                this: *mut root::AZ::Component,
                entity: *mut root::AZ::Entity,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ReflectInternal@Component@AZ@@KAXPEAVReflectContext@2@@Z"]
            pub fn Component_ReflectInternal(reflection: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0Component@AZ@@QEAA@XZ"]
            pub fn Component_Component(this: *mut root::AZ::Component);
        }
        impl Component {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                Component_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                Component_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn GetEntityId(&self) -> root::AZ::EntityId {
                Component_GetEntityId(self)
            }
            #[inline]
            pub unsafe fn GetNamedEntityId(&self) -> root::AZ::NamedEntityId {
                Component_GetNamedEntityId(self)
            }
            #[inline]
            pub unsafe fn SetConfiguration(
                &mut self,
                config: *const root::AZ::ComponentConfig,
            ) -> bool {
                Component_SetConfiguration(self, config)
            }
            #[inline]
            pub unsafe fn GetConfiguration(
                &self,
                outConfig: *mut root::AZ::ComponentConfig,
            ) -> bool {
                Component_GetConfiguration(self, outConfig)
            }
            #[inline]
            pub unsafe fn SetEntity(&mut self, entity: *mut root::AZ::Entity) {
                Component_SetEntity(self, entity)
            }
            #[inline]
            pub unsafe fn ReflectInternal(reflection: *mut root::AZ::ReflectContext) {
                Component_ReflectInternal(reflection)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Component_Component(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DComponent@AZ@@QEAAXXZ"]
            pub fn Component_Component_destructor(this: *mut root::AZ::Component);
        }
        extern "C" {
            #[link_name = "\u{1}?ReadInConfig@Component@AZ@@MEAA_NPEBVComponentConfig@2@@Z"]
            pub fn Component_ReadInConfig(
                this: *mut ::std::os::raw::c_void,
                baseConfig: *const root::AZ::ComponentConfig,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?WriteOutConfig@Component@AZ@@MEBA_NPEAVComponentConfig@2@@Z"]
            pub fn Component_WriteOutConfig(
                this: *mut ::std::os::raw::c_void,
                outBaseConfig: *mut root::AZ::ComponentConfig,
            ) -> bool;
        }
        #[repr(C)]
        pub struct ComponentDescriptor__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentDescriptor {
            pub vtable_: *const ComponentDescriptor__bindgen_vtable,
        }
        pub type ComponentDescriptor_DependencyArrayType =
            root::AZStd::vector<root::AZ::ComponentServiceType, root::AZStd::allocator>;
        extern "C" {
            #[link_name = "\u{1}?ReleaseDescriptor@ComponentDescriptor@AZ@@UEAAXXZ"]
            pub fn ComponentDescriptor_ReleaseDescriptor(this: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentDescriptorBusTraits {
            pub _address: u8,
        }
        pub type ComponentDescriptorBusTraits_BusIdType = root::AZ::Uuid;
        pub type ComponentDescriptorBusTraits_MutexType = root::AZStd::recursive_mutex;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@ComponentDescriptorBusTraits@AZ@@2W4EBusAddressPolicy@2@B"]
            pub static ComponentDescriptorBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@ComponentDescriptorBusTraits@AZ@@2W4EBusHandlerPolicy@2@B"]
            pub static ComponentDescriptorBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type ComponentDescriptorBus = root::AZ::EBus;
        #[repr(C)]
        pub struct ComponentDescriptorHelper__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentDescriptorHelper {
            pub vtable_: *const ComponentDescriptorHelper__bindgen_vtable,
            pub _base: [u64; 3usize],
        }
        pub type ComponentReflectResultType_type = root::std::true_type;
        pub type HasComponentReflect_Yes = ::std::os::raw::c_char;
        pub type HasComponentReflect_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasComponentReflect_Helper {
            pub _address: u8,
        }
        pub type HasComponentReflect_Helper_mfp =
            ::std::option::Option<unsafe extern "C" fn(arg1: *mut root::AZ::ReflectContext)>;
        pub type HasComponentReflect_type = u8;
        pub type ComponentProvidedServicesResultType_type = root::std::true_type;
        pub type HasComponentProvidedServices_Yes = ::std::os::raw::c_char;
        pub type HasComponentProvidedServices_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasComponentProvidedServices_Helper {
            pub _address: u8,
        }
        pub type HasComponentProvidedServices_Helper_mfp = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::AZ::ComponentDescriptor_DependencyArrayType),
        >;
        pub type HasComponentProvidedServices_type = u8;
        pub type ComponentDependentServicesResultType_type = root::std::true_type;
        pub type HasComponentDependentServices_Yes = ::std::os::raw::c_char;
        pub type HasComponentDependentServices_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasComponentDependentServices_Helper {
            pub _address: u8,
        }
        pub type HasComponentDependentServices_Helper_mfp = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::AZ::ComponentDescriptor_DependencyArrayType),
        >;
        pub type HasComponentDependentServices_type = u8;
        pub type ComponentRequiredServicesResultType_type = root::std::true_type;
        pub type HasComponentRequiredServices_Yes = ::std::os::raw::c_char;
        pub type HasComponentRequiredServices_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasComponentRequiredServices_Helper {
            pub _address: u8,
        }
        pub type HasComponentRequiredServices_Helper_mfp = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::AZ::ComponentDescriptor_DependencyArrayType),
        >;
        pub type HasComponentRequiredServices_type = u8;
        pub type ComponentIncompatibleServicesResultType_type = root::std::true_type;
        pub type HasComponentIncompatibleServices_Yes = ::std::os::raw::c_char;
        pub type HasComponentIncompatibleServices_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasComponentIncompatibleServices_Helper {
            pub _address: u8,
        }
        pub type HasComponentIncompatibleServices_Helper_mfp = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::AZ::ComponentDescriptor_DependencyArrayType),
        >;
        pub type HasComponentIncompatibleServices_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ComponentDescriptorDefault {
            pub _base: root::AZ::ComponentDescriptorHelper,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct NumericCasted<FromType> {
            pub m_value: FromType,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<FromType>>,
        }
        pub mod IO {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type SizeType = root::AZ::u64;
            pub type OffsetType = root::AZ::s64;
            pub type OpenMode = u32;
            #[repr(C)]
            pub struct GenericStream__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct GenericStream {
                pub vtable_: *const GenericStream__bindgen_vtable,
            }
            pub const GenericStream_SeekMode_ST_SEEK_BEGIN: root::AZ::IO::GenericStream_SeekMode =
                0;
            pub const GenericStream_SeekMode_ST_SEEK_CUR: root::AZ::IO::GenericStream_SeekMode = 1;
            pub const GenericStream_SeekMode_ST_SEEK_END: root::AZ::IO::GenericStream_SeekMode = 2;
            pub type GenericStream_SeekMode = i32;
            extern "C" {
                #[link_name = "\u{1}?ComputeSeekPosition@GenericStream@IO@AZ@@IEAA_K_JW4SeekMode@123@@Z"]
                pub fn GenericStream_ComputeSeekPosition(
                    this: *mut root::AZ::IO::GenericStream,
                    bytes: root::AZ::IO::OffsetType,
                    mode: root::AZ::IO::GenericStream_SeekMode,
                ) -> root::AZ::IO::SizeType;
            }
            impl GenericStream {
                #[inline]
                pub unsafe fn ComputeSeekPosition(
                    &mut self,
                    bytes: root::AZ::IO::OffsetType,
                    mode: root::AZ::IO::GenericStream_SeekMode,
                ) -> root::AZ::IO::SizeType {
                    GenericStream_ComputeSeekPosition(self, bytes, mode)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?ReadAtOffset@GenericStream@IO@AZ@@UEAA_K_KPEAX_J@Z"]
                pub fn GenericStream_ReadAtOffset(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    oBuffer: *mut ::std::os::raw::c_void,
                    offset: root::AZ::IO::OffsetType,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?WriteAtOffset@GenericStream@IO@AZ@@UEAA_K_KPEBX_J@Z"]
                pub fn GenericStream_WriteAtOffset(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    iBuffer: *const ::std::os::raw::c_void,
                    offset: root::AZ::IO::OffsetType,
                ) -> root::AZ::IO::SizeType;
            }
            #[repr(C)]
            pub struct StreamerStream {
                pub _base: root::AZ::IO::GenericStream,
                pub m_filename: root::AZStd::string,
                pub m_baseOffset: root::AZ::IO::SizeType,
                pub m_curPos: root::AZ::IO::SizeType,
                pub m_fakeLen: root::AZ::IO::SizeType,
                pub m_exists: root::AZ::IO::StreamerStream_Availability,
            }
            pub const StreamerStream_Availability_NotChecked:
                root::AZ::IO::StreamerStream_Availability = 0;
            pub const StreamerStream_Availability_FileExists:
                root::AZ::IO::StreamerStream_Availability = 1;
            pub const StreamerStream_Availability_FileMissing:
                root::AZ::IO::StreamerStream_Availability = 2;
            pub type StreamerStream_Availability = i32;
            extern "C" {
                #[link_name = "\u{1}??0StreamerStream@IO@AZ@@QEAA@PEBDW4OpenMode@12@_K2@Z"]
                pub fn StreamerStream_StreamerStream(
                    this: *mut root::AZ::IO::StreamerStream,
                    filename: *const ::std::os::raw::c_char,
                    flags: root::AZ::IO::OpenMode,
                    baseOffset: root::AZ::IO::SizeType,
                    fakeLen: root::AZ::IO::SizeType,
                );
            }
            impl StreamerStream {
                #[inline]
                pub unsafe fn new(
                    filename: *const ::std::os::raw::c_char,
                    flags: root::AZ::IO::OpenMode,
                    baseOffset: root::AZ::IO::SizeType,
                    fakeLen: root::AZ::IO::SizeType,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    StreamerStream_StreamerStream(
                        __bindgen_tmp.as_mut_ptr(),
                        filename,
                        flags,
                        baseOffset,
                        fakeLen,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?IsOpen@StreamerStream@IO@AZ@@UEBA_NXZ"]
                pub fn StreamerStream_IsOpen(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?CanRead@StreamerStream@IO@AZ@@UEBA_NXZ"]
                pub fn StreamerStream_CanRead(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?CanWrite@StreamerStream@IO@AZ@@UEBA_NXZ"]
                pub fn StreamerStream_CanWrite(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Seek@StreamerStream@IO@AZ@@UEAAX_JW4SeekMode@GenericStream@23@@Z"]
                pub fn StreamerStream_Seek(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::OffsetType,
                    mode: root::AZ::IO::GenericStream_SeekMode,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Read@StreamerStream@IO@AZ@@UEAA_K_KPEAX@Z"]
                pub fn StreamerStream_Read(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    oBuffer: *mut ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?Write@StreamerStream@IO@AZ@@UEAA_K_KPEBX@Z"]
                pub fn StreamerStream_Write(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    iBuffer: *const ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?GetLength@StreamerStream@IO@AZ@@UEBA_KXZ"]
                pub fn StreamerStream_GetLength(
                    this: *mut ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct SystemFile {
                _unused: [u8; 0],
            }
            #[repr(C)]
            pub struct SystemFileStream {
                pub _base: root::AZ::IO::GenericStream,
                pub m_file: *mut root::AZ::IO::SystemFile,
                pub m_baseOffset: root::AZ::IO::SizeType,
                pub m_curPos: root::AZ::IO::SizeType,
                pub m_fakeLen: root::AZ::IO::SizeType,
                pub m_isFileOwner: bool,
                pub m_mode: root::AZ::IO::OpenMode,
            }
            extern "C" {
                #[link_name = "\u{1}?Open@SystemFileStream@IO@AZ@@QEAA_NPEBDW4OpenMode@23@@Z"]
                pub fn SystemFileStream_Open(
                    this: *mut root::AZ::IO::SystemFileStream,
                    path: *const ::std::os::raw::c_char,
                    mode: root::AZ::IO::OpenMode,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}??0SystemFileStream@IO@AZ@@QEAA@PEAVSystemFile@12@_N_K2@Z"]
                pub fn SystemFileStream_SystemFileStream(
                    this: *mut root::AZ::IO::SystemFileStream,
                    file: *mut root::AZ::IO::SystemFile,
                    isOwner: bool,
                    baseOffset: root::AZ::IO::SizeType,
                    fakeLen: root::AZ::IO::SizeType,
                );
            }
            impl SystemFileStream {
                #[inline]
                pub unsafe fn Open(
                    &mut self,
                    path: *const ::std::os::raw::c_char,
                    mode: root::AZ::IO::OpenMode,
                ) -> bool {
                    SystemFileStream_Open(self, path, mode)
                }
                #[inline]
                pub unsafe fn new(
                    file: *mut root::AZ::IO::SystemFile,
                    isOwner: bool,
                    baseOffset: root::AZ::IO::SizeType,
                    fakeLen: root::AZ::IO::SizeType,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SystemFileStream_SystemFileStream(
                        __bindgen_tmp.as_mut_ptr(),
                        file,
                        isOwner,
                        baseOffset,
                        fakeLen,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}??_DSystemFileStream@IO@AZ@@QEAAXXZ"]
                pub fn SystemFileStream_SystemFileStream_destructor(
                    this: *mut root::AZ::IO::SystemFileStream,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Close@SystemFileStream@IO@AZ@@UEAAXXZ"]
                pub fn SystemFileStream_Close(this: *mut ::std::os::raw::c_void);
            }
            extern "C" {
                #[link_name = "\u{1}?IsOpen@SystemFileStream@IO@AZ@@UEBA_NXZ"]
                pub fn SystemFileStream_IsOpen(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?CanRead@SystemFileStream@IO@AZ@@UEBA_NXZ"]
                pub fn SystemFileStream_CanRead(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?CanWrite@SystemFileStream@IO@AZ@@UEBA_NXZ"]
                pub fn SystemFileStream_CanWrite(this: *mut ::std::os::raw::c_void) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?Seek@SystemFileStream@IO@AZ@@UEAAX_JW4SeekMode@GenericStream@23@@Z"]
                pub fn SystemFileStream_Seek(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::OffsetType,
                    mode: root::AZ::IO::GenericStream_SeekMode,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Read@SystemFileStream@IO@AZ@@UEAA_K_KPEAX@Z"]
                pub fn SystemFileStream_Read(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    oBuffer: *mut ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?Write@SystemFileStream@IO@AZ@@UEAA_K_KPEBX@Z"]
                pub fn SystemFileStream_Write(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    iBuffer: *const ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?GetLength@SystemFileStream@IO@AZ@@UEBA_KXZ"]
                pub fn SystemFileStream_GetLength(
                    this: *mut ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?GetFilename@SystemFileStream@IO@AZ@@UEBAPEBDXZ"]
                pub fn SystemFileStream_GetFilename(
                    this: *mut ::std::os::raw::c_void,
                ) -> *const ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?ReOpen@SystemFileStream@IO@AZ@@UEAA_NXZ"]
                pub fn SystemFileStream_ReOpen(this: *mut ::std::os::raw::c_void) -> bool;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct MemoryStream {
                pub _base: root::AZ::IO::GenericStream,
                pub m_buffer: *const ::std::os::raw::c_char,
                pub m_bufferLen: usize,
                pub m_curOffset: usize,
                pub m_curLen: usize,
                pub m_mode: root::AZ::IO::MemoryStream_MemoryStreamMode,
            }
            pub const MemoryStream_MemoryStreamMode_MSM_READONLY:
                root::AZ::IO::MemoryStream_MemoryStreamMode = 0;
            pub const MemoryStream_MemoryStreamMode_MSM_READWRITE:
                root::AZ::IO::MemoryStream_MemoryStreamMode = 1;
            pub type MemoryStream_MemoryStreamMode = i32;
            extern "C" {
                #[link_name = "\u{1}?Seek@MemoryStream@IO@AZ@@UEAAX_JW4SeekMode@GenericStream@23@@Z"]
                pub fn MemoryStream_Seek(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::OffsetType,
                    mode: root::AZ::IO::GenericStream_SeekMode,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Read@MemoryStream@IO@AZ@@UEAA_K_KPEAX@Z"]
                pub fn MemoryStream_Read(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    oBuffer: *mut ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            extern "C" {
                #[link_name = "\u{1}?Write@MemoryStream@IO@AZ@@UEAA_K_KPEBX@Z"]
                pub fn MemoryStream_Write(
                    this: *mut ::std::os::raw::c_void,
                    bytes: root::AZ::IO::SizeType,
                    iBuffer: *const ::std::os::raw::c_void,
                ) -> root::AZ::IO::SizeType;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ByteContainerStream<ContainerType> {
                pub _base: root::AZ::IO::GenericStream,
                pub m_buffer: *mut ContainerType,
                pub m_pos: usize,
                pub m_maxGrowSize: usize,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ContainerType>>,
            }
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                pub type ResizeNoConstructResultType_type = root::std::true_type;
                pub type HasResizeNoConstruct_Yes = ::std::os::raw::c_char;
                pub type HasResizeNoConstruct_No = ::std::os::raw::c_long;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct HasResizeNoConstruct_Helper {
                    pub _address: u8,
                }
                pub type HasResizeNoConstruct_Helper_mfp =
                    ::std::option::Option<unsafe extern "C" fn(arg1: usize)>;
                pub type HasResizeNoConstruct_type = u8;
                pub type SetCapacityResultType_type = root::std::true_type;
                pub type HasSetCapacity_Yes = ::std::os::raw::c_char;
                pub type HasSetCapacity_No = ::std::os::raw::c_long;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct HasSetCapacity_Helper {
                    pub _address: u8,
                }
                pub type HasSetCapacity_Helper_mfp =
                    ::std::option::Option<unsafe extern "C" fn(arg1: usize)>;
                pub type HasSetCapacity_type = u8;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct Stream {
                _unused: [u8; 0],
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EditContext {
            _unused: [u8; 0],
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataPatchNodeInfo {
            _unused: [u8; 0],
        }
        pub mod ObjectStreamInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ObjectStreamImpl {
                _unused: [u8; 0],
            }
        }
        pub mod Edit {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ElementData {
                _unused: [u8; 0],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ClassData {
                _unused: [u8; 0],
            }
        }
        pub mod Serialize {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct StaticInstance {
                pub _address: u8,
            }
        }
        pub type AttributePtr = root::AZStd::shared_ptr<root::AZ::Attribute>;
        pub type AttributeSharedPair =
            root::AZStd::pair<root::AZ::AttributeId, root::AZ::AttributePtr>;
        #[repr(C)]
        pub struct SerializeContext {
            pub _base: root::AZ::ReflectContext,
            pub m_editContext: *mut root::AZ::EditContext,
            pub m_uuidMap: root::AZ::SerializeContext_UuidToClassMap,
            pub m_classNameToUuid: root::AZStd::unordered_multimap,
            pub m_uuidGenericMap: root::AZStd::unordered_multimap,
            pub m_legacySpecializeTypeIdToTypeIdMap: root::AZStd::unordered_multimap,
            pub m_uuidAnyCreationMap: root::AZStd::unordered_map,
            pub m_dataContainers:
                root::AZStd::vector<root::std::unique_ptr, root::AZStd::allocator>,
            pub m_perModuleSet: root::AZStd::unordered_set,
        }
        pub type SerializeContext_ClassInfo = root::AZ::SerializeContext_ClassBuilder;
        pub type SerializeContext_IRttiHelper = root::AZ::IRttiHelper;
        pub type SerializeContext_VersionConverter = ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut root::AZ::SerializeContext,
                arg2: *mut root::AZ::SerializeContext_DataElementNode,
            ) -> bool,
        >;
        pub type SerializeContext_ClassPersistentId = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> root::AZ::u64,
        >;
        pub type SerializeContext_ClassDoSave = ::std::option::Option<
            unsafe extern "C" fn(arg1: *const ::std::os::raw::c_void) -> bool,
        >;
        pub type SerializeContext_UuidToClassMap = root::AZStd::unordered_map;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext_DbgStackEntry {
            pub m_dataPtr: *const ::std::os::raw::c_void,
            pub m_uuidPtr: *const root::AZ::Uuid,
            pub m_classData: *const root::AZ::SerializeContext_ClassData,
            pub m_elementName: *const ::std::os::raw::c_char,
            pub m_classElement: *const root::AZ::SerializeContext_ClassElement,
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@DbgStackEntry@SerializeContext@AZ@@QEBAXAEAV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
            pub fn SerializeContext_DbgStackEntry_ToString(
                this: *const root::AZ::SerializeContext_DbgStackEntry,
                str: *mut root::AZStd::string,
            );
        }
        impl SerializeContext_DbgStackEntry {
            #[inline]
            pub unsafe fn ToString(&self, str: *mut root::AZStd::string) {
                SerializeContext_DbgStackEntry_ToString(self, str)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_ErrorHandler {
            pub m_stack: root::AZ::SerializeContext_ErrorHandler_DbgStack,
            pub m_nErrors: ::std::os::raw::c_uint,
            pub m_nWarnings: ::std::os::raw::c_uint,
        }
        pub type SerializeContext_ErrorHandler_DbgStack =
            root::AZStd::vector<root::AZ::SerializeContext_DbgStackEntry, root::AZStd::allocator>;
        extern "C" {
            #[link_name = "\u{1}?ReportError@ErrorHandler@SerializeContext@AZ@@QEAAXPEBD@Z"]
            pub fn SerializeContext_ErrorHandler_ReportError(
                this: *mut root::AZ::SerializeContext_ErrorHandler,
                message: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ReportWarning@ErrorHandler@SerializeContext@AZ@@QEAAXPEBD@Z"]
            pub fn SerializeContext_ErrorHandler_ReportWarning(
                this: *mut root::AZ::SerializeContext_ErrorHandler,
                message: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Push@ErrorHandler@SerializeContext@AZ@@QEAAXAEBUDbgStackEntry@23@@Z"]
            pub fn SerializeContext_ErrorHandler_Push(
                this: *mut root::AZ::SerializeContext_ErrorHandler,
                de: *const root::AZ::SerializeContext_DbgStackEntry,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Pop@ErrorHandler@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ErrorHandler_Pop(
                this: *mut root::AZ::SerializeContext_ErrorHandler,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reset@ErrorHandler@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ErrorHandler_Reset(
                this: *mut root::AZ::SerializeContext_ErrorHandler,
            );
        }
        impl SerializeContext_ErrorHandler {
            #[inline]
            pub unsafe fn ReportError(&mut self, message: *const ::std::os::raw::c_char) {
                SerializeContext_ErrorHandler_ReportError(self, message)
            }
            #[inline]
            pub unsafe fn ReportWarning(&mut self, message: *const ::std::os::raw::c_char) {
                SerializeContext_ErrorHandler_ReportWarning(self, message)
            }
            #[inline]
            pub unsafe fn Push(&mut self, de: *const root::AZ::SerializeContext_DbgStackEntry) {
                SerializeContext_ErrorHandler_Push(self, de)
            }
            #[inline]
            pub unsafe fn Pop(&mut self) {
                SerializeContext_ErrorHandler_Pop(self)
            }
            #[inline]
            pub unsafe fn Reset(&mut self) {
                SerializeContext_ErrorHandler_Reset(self)
            }
        }
        pub const SerializeContext_EnumerationAccessFlags_ENUM_ACCESS_FOR_READ:
            root::AZ::SerializeContext_EnumerationAccessFlags = 0;
        pub const SerializeContext_EnumerationAccessFlags_ENUM_ACCESS_FOR_WRITE:
            root::AZ::SerializeContext_EnumerationAccessFlags = 1;
        pub const SerializeContext_EnumerationAccessFlags_ENUM_ACCESS_HOLD:
            root::AZ::SerializeContext_EnumerationAccessFlags = 2;
        pub type SerializeContext_EnumerationAccessFlags = i32;
        pub type SerializeContext_BeginElemEnumCB = [u64; 5usize];
        pub type SerializeContext_EndElemEnumCB = [u64; 5usize];
        pub type SerializeContext_TypeInfoCB = root::AZStd::function;
        #[repr(C)]
        #[repr(align(16))]
        pub struct SerializeContext_ClassElement {
            pub m_name: *const ::std::os::raw::c_char,
            pub m_nameCrc: root::AZ::u32,
            pub __bindgen_padding_0: [u64; 0usize],
            pub m_typeId: root::AZ::Uuid,
            pub m_dataSize: usize,
            pub m_offset: usize,
            pub m_azRtti: *mut root::AZ::SerializeContext_IRttiHelper,
            pub m_genericClassInfo: *mut root::AZ::GenericClassInfo,
            pub m_editData: *mut root::AZ::Edit::ElementData,
            pub m_attributes:
                root::AZStd::vector<root::AZ::AttributeSharedPair, root::AZ::AZStdFunctorAllocator>,
            pub m_attributeOwnership: root::AZ::SerializeContext_ClassElement_AttributeOwnership,
            pub m_flags: ::std::os::raw::c_int,
            pub __bindgen_padding_1: u64,
        }
        pub const SerializeContext_ClassElement_Flags_FLG_POINTER:
            root::AZ::SerializeContext_ClassElement_Flags = 1;
        pub const SerializeContext_ClassElement_Flags_FLG_BASE_CLASS:
            root::AZ::SerializeContext_ClassElement_Flags = 2;
        pub const SerializeContext_ClassElement_Flags_FLG_NO_DEFAULT_VALUE:
            root::AZ::SerializeContext_ClassElement_Flags = 4;
        pub const SerializeContext_ClassElement_Flags_FLG_DYNAMIC_FIELD:
            root::AZ::SerializeContext_ClassElement_Flags = 8;
        pub const SerializeContext_ClassElement_Flags_FLG_UI_ELEMENT:
            root::AZ::SerializeContext_ClassElement_Flags = 16;
        pub type SerializeContext_ClassElement_Flags = i32;
        pub const SerializeContext_ClassElement_AttributeOwnership_Parent:
            root::AZ::SerializeContext_ClassElement_AttributeOwnership = 0;
        pub const SerializeContext_ClassElement_AttributeOwnership_Self_:
            root::AZ::SerializeContext_ClassElement_AttributeOwnership = 1;
        pub const SerializeContext_ClassElement_AttributeOwnership_None:
            root::AZ::SerializeContext_ClassElement_AttributeOwnership = 2;
        pub type SerializeContext_ClassElement_AttributeOwnership = i32;
        extern "C" {
            #[link_name = "\u{1}?ClearAttributes@ClassElement@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ClassElement_ClearAttributes(
                this: *mut root::AZ::SerializeContext_ClassElement,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FindAttribute@ClassElement@SerializeContext@AZ@@QEBAPEAVAttribute@3@I@Z"]
            pub fn SerializeContext_ClassElement_FindAttribute(
                this: *const root::AZ::SerializeContext_ClassElement,
                attributeId: root::AZ::AttributeId,
            ) -> *mut root::AZ::Attribute;
        }
        extern "C" {
            #[link_name = "\u{1}??_DClassElement@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ClassElement_ClassElement_destructor(
                this: *mut root::AZ::SerializeContext_ClassElement,
            );
        }
        impl SerializeContext_ClassElement {
            #[inline]
            pub unsafe fn ClearAttributes(&mut self) {
                SerializeContext_ClassElement_ClearAttributes(self)
            }
            #[inline]
            pub unsafe fn FindAttribute(
                &self,
                attributeId: root::AZ::AttributeId,
            ) -> *mut root::AZ::Attribute {
                SerializeContext_ClassElement_FindAttribute(self, attributeId)
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SerializeContext_ClassElement_ClassElement_destructor(self)
            }
        }
        pub type SerializeContext_ClassElementArray =
            root::AZStd::vector<root::AZ::SerializeContext_ClassElement, root::AZStd::allocator>;
        #[repr(C)]
        #[repr(align(16))]
        pub struct SerializeContext_ClassData {
            pub m_name: *const ::std::os::raw::c_char,
            pub __bindgen_padding_0: u64,
            pub m_typeId: root::AZ::Uuid,
            pub m_version: ::std::os::raw::c_uint,
            pub m_converter: root::AZ::SerializeContext_VersionConverter,
            pub m_factory: *mut root::AZ::SerializeContext_IObjectFactory,
            pub m_persistentId: root::AZ::SerializeContext_ClassPersistentId,
            pub m_doSave: root::AZ::SerializeContext_ClassDoSave,
            pub m_serializer: *mut root::AZ::SerializeContext_IDataSerializer,
            pub m_eventHandler: *mut root::AZ::SerializeContext_IEventHandler,
            pub m_container: *mut root::AZ::SerializeContext_IDataContainer,
            pub m_azRtti: *mut root::AZ::SerializeContext_IRttiHelper,
            pub m_dataConverter: *mut root::AZ::SerializeContext_IDataConverter,
            pub m_editData: *mut root::AZ::Edit::ClassData,
            pub m_elements: root::AZ::SerializeContext_ClassElementArray,
            pub m_attributes:
                root::AZStd::vector<root::AZ::AttributeSharedPair, root::AZ::AZStdFunctorAllocator>,
        }
        extern "C" {
            #[link_name = "\u{1}?ClearAttributes@ClassData@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ClassData_ClearAttributes(
                this: *mut root::AZ::SerializeContext_ClassData,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FindAttribute@ClassData@SerializeContext@AZ@@QEBAPEAVAttribute@3@I@Z"]
            pub fn SerializeContext_ClassData_FindAttribute(
                this: *const root::AZ::SerializeContext_ClassData,
                attributeId: root::AZ::AttributeId,
            ) -> *mut root::AZ::Attribute;
        }
        extern "C" {
            #[link_name = "\u{1}?CanConvertFromType@ClassData@SerializeContext@AZ@@QEBA_NAEBUUuid@3@AEAV23@@Z"]
            pub fn SerializeContext_ClassData_CanConvertFromType(
                this: *const root::AZ::SerializeContext_ClassData,
                convertibleTypeId: *const root::AZ::TypeId,
                serializeContext: *mut root::AZ::SerializeContext,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ConvertFromType@ClassData@SerializeContext@AZ@@QEBA_NAEAPEAXAEBUUuid@3@PEAXAEAV23@@Z"]
            pub fn SerializeContext_ClassData_ConvertFromType(
                this: *const root::AZ::SerializeContext_ClassData,
                convertibleTypePtr: *mut *mut ::std::os::raw::c_void,
                convertibleTypeId: *const root::AZ::TypeId,
                classPtr: *mut ::std::os::raw::c_void,
                serializeContext: *mut root::AZ::SerializeContext,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetPersistentId@ClassData@SerializeContext@AZ@@QEBAP6A_KPEBX@ZAEBV23@@Z"]
            pub fn SerializeContext_ClassData_GetPersistentId(
                this: *const root::AZ::SerializeContext_ClassData,
                context: *const root::AZ::SerializeContext,
            ) -> root::AZ::SerializeContext_ClassPersistentId;
        }
        extern "C" {
            #[link_name = "\u{1}??0ClassData@SerializeContext@AZ@@QEAA@XZ"]
            pub fn SerializeContext_ClassData_ClassData(
                this: *mut root::AZ::SerializeContext_ClassData,
            );
        }
        impl SerializeContext_ClassData {
            #[inline]
            pub unsafe fn ClearAttributes(&mut self) {
                SerializeContext_ClassData_ClearAttributes(self)
            }
            #[inline]
            pub unsafe fn FindAttribute(
                &self,
                attributeId: root::AZ::AttributeId,
            ) -> *mut root::AZ::Attribute {
                SerializeContext_ClassData_FindAttribute(self, attributeId)
            }
            #[inline]
            pub unsafe fn CanConvertFromType(
                &self,
                convertibleTypeId: *const root::AZ::TypeId,
                serializeContext: *mut root::AZ::SerializeContext,
            ) -> bool {
                SerializeContext_ClassData_CanConvertFromType(
                    self,
                    convertibleTypeId,
                    serializeContext,
                )
            }
            #[inline]
            pub unsafe fn ConvertFromType(
                &self,
                convertibleTypePtr: *mut *mut ::std::os::raw::c_void,
                convertibleTypeId: *const root::AZ::TypeId,
                classPtr: *mut ::std::os::raw::c_void,
                serializeContext: *mut root::AZ::SerializeContext,
            ) -> bool {
                SerializeContext_ClassData_ConvertFromType(
                    self,
                    convertibleTypePtr,
                    convertibleTypeId,
                    classPtr,
                    serializeContext,
                )
            }
            #[inline]
            pub unsafe fn GetPersistentId(
                &self,
                context: *const root::AZ::SerializeContext,
            ) -> root::AZ::SerializeContext_ClassPersistentId {
                SerializeContext_ClassData_GetPersistentId(self, context)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_ClassData_ClassData(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct SerializeContext_IObjectFactory__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IObjectFactory {
            pub vtable_: *const SerializeContext_IObjectFactory__bindgen_vtable,
        }
        #[repr(C)]
        pub struct SerializeContext_IDataSerializer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IDataSerializer {
            pub vtable_: *const SerializeContext_IDataSerializer__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext_EqualityCompareHelper {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct SerializeContext_IDataContainer__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IDataContainer {
            pub vtable_: *const SerializeContext_IDataContainer__bindgen_vtable,
        }
        pub type SerializeContext_IDataContainer_ElementCB = [u64; 5usize];
        #[repr(C)]
        pub struct SerializeContext_IDataContainer_IAssociativeDataContainer__bindgen_vtable(
            ::std::os::raw::c_void,
        );
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IDataContainer_IAssociativeDataContainer {
            pub vtable_:
                *const SerializeContext_IDataContainer_IAssociativeDataContainer__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext_IDataContainer_IAssociativeDataContainer_KeyPtrDeleter {
            pub m_associativeDataContainer:
                *mut root::AZ::SerializeContext_IDataContainer_IAssociativeDataContainer,
        }
        pub type SerializeContext_IDataContainer_IAssociativeDataContainer_KeyPtr =
            root::std::unique_ptr;
        extern "C" {
            #[link_name = "\u{1}?DeletePointerData@IDataContainer@SerializeContext@AZ@@IEAAXPEAV23@PEBUClassElement@23@PEBX@Z"]
            pub fn SerializeContext_IDataContainer_DeletePointerData(
                this: *mut root::AZ::SerializeContext_IDataContainer,
                context: *mut root::AZ::SerializeContext,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                element: *const ::std::os::raw::c_void,
            );
        }
        impl SerializeContext_IDataContainer {
            #[inline]
            pub unsafe fn DeletePointerData(
                &mut self,
                context: *mut root::AZ::SerializeContext,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                element: *const ::std::os::raw::c_void,
            ) {
                SerializeContext_IDataContainer_DeletePointerData(
                    self,
                    context,
                    classElement,
                    element,
                )
            }
        }
        #[repr(C)]
        pub struct SerializeContext_IEventHandler__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IEventHandler {
            pub vtable_: *const SerializeContext_IEventHandler__bindgen_vtable,
        }
        #[repr(C)]
        pub struct SerializeContext_IDataConverter__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_IDataConverter {
            pub vtable_: *const SerializeContext_IDataConverter__bindgen_vtable,
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct SerializeContext_DataElement {
            pub m_name: *const ::std::os::raw::c_char,
            pub m_nameCrc: root::AZ::u32,
            pub m_dataType: root::AZ::SerializeContext_DataElement_DataType,
            pub m_id: root::AZ::Uuid,
            pub m_version: ::std::os::raw::c_uint,
            pub m_dataSize: usize,
            pub m_buffer: root::AZStd::vector<::std::os::raw::c_char, root::AZStd::allocator>,
            pub m_byteStream: root::AZ::IO::ByteContainerStream<
                root::AZStd::vector<::std::os::raw::c_char, root::AZStd::allocator>,
            >,
            pub m_stream: *mut root::AZ::IO::GenericStream,
            pub __bindgen_padding_0: u64,
        }
        pub const SerializeContext_DataElement_DataType_DT_TEXT:
            root::AZ::SerializeContext_DataElement_DataType = 0;
        pub const SerializeContext_DataElement_DataType_DT_BINARY:
            root::AZ::SerializeContext_DataElement_DataType = 1;
        pub const SerializeContext_DataElement_DataType_DT_BINARY_BE:
            root::AZ::SerializeContext_DataElement_DataType = 2;
        pub type SerializeContext_DataElement_DataType = i32;
        extern "C" {
            #[link_name = "\u{1}??0DataElement@SerializeContext@AZ@@QEAA@XZ"]
            pub fn SerializeContext_DataElement_DataElement(
                this: *mut root::AZ::SerializeContext_DataElement,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0DataElement@SerializeContext@AZ@@QEAA@AEBU012@@Z"]
            pub fn SerializeContext_DataElement_DataElement1(
                this: *mut root::AZ::SerializeContext_DataElement,
                rhs: *const root::AZ::SerializeContext_DataElement,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0DataElement@SerializeContext@AZ@@QEAA@$$QEAU012@@Z"]
            pub fn SerializeContext_DataElement_DataElement2(
                this: *mut root::AZ::SerializeContext_DataElement,
                rhs: *mut root::AZ::SerializeContext_DataElement,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DDataElement@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_DataElement_DataElement_destructor(
                this: *mut root::AZ::SerializeContext_DataElement,
            );
        }
        impl SerializeContext_DataElement {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_DataElement_DataElement(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(rhs: *const root::AZ::SerializeContext_DataElement) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_DataElement_DataElement1(__bindgen_tmp.as_mut_ptr(), rhs);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(rhs: *mut root::AZ::SerializeContext_DataElement) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_DataElement_DataElement2(__bindgen_tmp.as_mut_ptr(), rhs);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SerializeContext_DataElement_DataElement_destructor(self)
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct SerializeContext_DataElementNode {
            pub m_element: root::AZ::SerializeContext_DataElement,
            pub m_classData: *const root::AZ::SerializeContext_ClassData,
            pub m_subElements: root::AZ::SerializeContext_DataElementNode_NodeArray,
            pub __bindgen_padding_0: u64,
        }
        pub type SerializeContext_DataElementNode_NodeArray =
            root::AZStd::vector<root::AZ::SerializeContext_DataElementNode, root::AZStd::allocator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeContext_DataElementNode_DataElementInstanceData {
            pub m_ptr: *mut ::std::os::raw::c_void,
            pub m_dataElement: *mut root::AZ::SerializeContext_DataElementNode,
            pub m_currentContainerElementIndex: ::std::os::raw::c_int,
        }
        pub type SerializeContext_DataElementNode_NodeStack =
            root::AZStd::list<root::AZStd::allocator>;
        extern "C" {
            #[link_name = "\u{1}?Convert@DataElementNode@SerializeContext@AZ@@QEAA_NAEAV23@PEBDAEBUUuid@3@@Z"]
            pub fn SerializeContext_DataElementNode_Convert(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Convert@DataElementNode@SerializeContext@AZ@@QEAA_NAEAV23@AEBUUuid@3@@Z"]
            pub fn SerializeContext_DataElementNode_Convert1(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                id: *const root::AZ::Uuid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?SetName@DataElementNode@SerializeContext@AZ@@QEAAXPEBD@Z"]
            pub fn SerializeContext_DataElementNode_SetName(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                newName: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FindElement@DataElementNode@SerializeContext@AZ@@QEAAHI@Z"]
            pub fn SerializeContext_DataElementNode_FindElement(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                crc: root::AZ::u32,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?FindSubElement@DataElementNode@SerializeContext@AZ@@QEAAPEAV123@I@Z"]
            pub fn SerializeContext_DataElementNode_FindSubElement(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                crc: root::AZ::u32,
            ) -> *mut root::AZ::SerializeContext_DataElementNode;
        }
        extern "C" {
            #[link_name = "\u{1}?RemoveElement@DataElementNode@SerializeContext@AZ@@QEAAXH@Z"]
            pub fn SerializeContext_DataElementNode_RemoveElement(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RemoveElementByName@DataElementNode@SerializeContext@AZ@@QEAA_NI@Z"]
            pub fn SerializeContext_DataElementNode_RemoveElementByName(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                crc: root::AZ::u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?AddElement@DataElementNode@SerializeContext@AZ@@QEAAHAEBV123@@Z"]
            pub fn SerializeContext_DataElementNode_AddElement(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                elem: *const root::AZ::SerializeContext_DataElementNode,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?AddElement@DataElementNode@SerializeContext@AZ@@QEAAHAEAV23@PEBDAEBUUuid@3@@Z"]
            pub fn SerializeContext_DataElementNode_AddElement1(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?AddElement@DataElementNode@SerializeContext@AZ@@QEAAHAEAV23@PEBDAEBVClassData@23@@Z"]
            pub fn SerializeContext_DataElementNode_AddElement2(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                classData: *const root::AZ::SerializeContext_ClassData,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?AddElement@DataElementNode@SerializeContext@AZ@@QEAAHAEAV23@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@PEAVGenericClassInfo@3@@Z"]
            pub fn SerializeContext_DataElementNode_AddElement3(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                name: root::AZStd::string_view,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?ReplaceElement@DataElementNode@SerializeContext@AZ@@QEAAHAEAV23@HPEBDAEBUUuid@3@@Z"]
            pub fn SerializeContext_DataElementNode_ReplaceElement(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                index: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}?SetDataHierarchy@DataElementNode@SerializeContext@AZ@@IEAA_NAEAV23@PEBXAEBUUuid@3@PEAVErrorHandler@23@PEBVClassData@23@@Z"]
            pub fn SerializeContext_DataElementNode_SetDataHierarchy(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                sc: *mut root::AZ::SerializeContext,
                objectPtr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
                classData: *const root::AZ::SerializeContext_ClassData,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetDataHierarchy@DataElementNode@SerializeContext@AZ@@IEAA_NPEAXAEBUUuid@3@PEAVErrorHandler@23@@Z"]
            pub fn SerializeContext_DataElementNode_GetDataHierarchy(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                objectPtr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetDataHierarchyEnumerate@DataElementNode@SerializeContext@AZ@@IEAA_NPEAVErrorHandler@23@AEAV?$list@UDataElementInstanceData@DataElementNode@SerializeContext@AZ@@Vallocator@AZStd@@@AZStd@@@Z"]
            pub fn SerializeContext_DataElementNode_GetDataHierarchyEnumerate(
                this: *mut root::AZ::SerializeContext_DataElementNode,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
                nodeStack: *mut root::AZ::SerializeContext_DataElementNode_NodeStack,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetClassElement@DataElementNode@SerializeContext@AZ@@IEBA_NAEAUClassElement@23@AEBV123@PEAVErrorHandler@23@@Z"]
            pub fn SerializeContext_DataElementNode_GetClassElement(
                this: *const root::AZ::SerializeContext_DataElementNode,
                classElement: *mut root::AZ::SerializeContext_ClassElement,
                parentDataElement: *const root::AZ::SerializeContext_DataElementNode,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool;
        }
        impl SerializeContext_DataElementNode {
            #[inline]
            pub unsafe fn Convert(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> bool {
                SerializeContext_DataElementNode_Convert(self, sc, name, id)
            }
            #[inline]
            pub unsafe fn Convert1(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                id: *const root::AZ::Uuid,
            ) -> bool {
                SerializeContext_DataElementNode_Convert1(self, sc, id)
            }
            #[inline]
            pub unsafe fn SetName(&mut self, newName: *const ::std::os::raw::c_char) {
                SerializeContext_DataElementNode_SetName(self, newName)
            }
            #[inline]
            pub unsafe fn FindElement(&mut self, crc: root::AZ::u32) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_FindElement(self, crc)
            }
            #[inline]
            pub unsafe fn FindSubElement(
                &mut self,
                crc: root::AZ::u32,
            ) -> *mut root::AZ::SerializeContext_DataElementNode {
                SerializeContext_DataElementNode_FindSubElement(self, crc)
            }
            #[inline]
            pub unsafe fn RemoveElement(&mut self, index: ::std::os::raw::c_int) {
                SerializeContext_DataElementNode_RemoveElement(self, index)
            }
            #[inline]
            pub unsafe fn RemoveElementByName(&mut self, crc: root::AZ::u32) -> bool {
                SerializeContext_DataElementNode_RemoveElementByName(self, crc)
            }
            #[inline]
            pub unsafe fn AddElement(
                &mut self,
                elem: *const root::AZ::SerializeContext_DataElementNode,
            ) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_AddElement(self, elem)
            }
            #[inline]
            pub unsafe fn AddElement1(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_AddElement1(self, sc, name, id)
            }
            #[inline]
            pub unsafe fn AddElement2(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                classData: *const root::AZ::SerializeContext_ClassData,
            ) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_AddElement2(self, sc, name, classData)
            }
            #[inline]
            pub unsafe fn AddElement3(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                name: root::AZStd::string_view,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
            ) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_AddElement3(self, sc, name, genericClassInfo)
            }
            #[inline]
            pub unsafe fn ReplaceElement(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                index: ::std::os::raw::c_int,
                name: *const ::std::os::raw::c_char,
                id: *const root::AZ::Uuid,
            ) -> ::std::os::raw::c_int {
                SerializeContext_DataElementNode_ReplaceElement(self, sc, index, name, id)
            }
            #[inline]
            pub unsafe fn SetDataHierarchy(
                &mut self,
                sc: *mut root::AZ::SerializeContext,
                objectPtr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
                classData: *const root::AZ::SerializeContext_ClassData,
            ) -> bool {
                SerializeContext_DataElementNode_SetDataHierarchy(
                    self,
                    sc,
                    objectPtr,
                    classId,
                    errorHandler,
                    classData,
                )
            }
            #[inline]
            pub unsafe fn GetDataHierarchy(
                &mut self,
                objectPtr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool {
                SerializeContext_DataElementNode_GetDataHierarchy(
                    self,
                    objectPtr,
                    classId,
                    errorHandler,
                )
            }
            #[inline]
            pub unsafe fn GetDataHierarchyEnumerate(
                &mut self,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
                nodeStack: *mut root::AZ::SerializeContext_DataElementNode_NodeStack,
            ) -> bool {
                SerializeContext_DataElementNode_GetDataHierarchyEnumerate(
                    self,
                    errorHandler,
                    nodeStack,
                )
            }
            #[inline]
            pub unsafe fn GetClassElement(
                &self,
                classElement: *mut root::AZ::SerializeContext_ClassElement,
                parentDataElement: *const root::AZ::SerializeContext_DataElementNode,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool {
                SerializeContext_DataElementNode_GetClassElement(
                    self,
                    classElement,
                    parentDataElement,
                    errorHandler,
                )
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_EnumerateInstanceCallContext {
            pub m_beginElemCB: root::AZ::SerializeContext_BeginElemEnumCB,
            pub m_endElemCB: root::AZ::SerializeContext_EndElemEnumCB,
            pub m_accessFlags: ::std::os::raw::c_uint,
            pub m_errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            pub m_context: *const root::AZ::SerializeContext,
            pub m_elementCallback: root::AZ::SerializeContext_IDataContainer_ElementCB,
            pub m_defaultErrorHandler: root::AZ::SerializeContext_ErrorHandler,
        }
        extern "C" {
            #[link_name = "\u{1}??0EnumerateInstanceCallContext@SerializeContext@AZ@@QEAA@AEBV?$function@$$A6A_NPEAXPEBVClassData@SerializeContext@AZ@@PEBUClassElement@23@@Z@AZStd@@AEBV?$function@$$A6A_NXZ@4@PEBV12@IPEAVErrorHandler@12@@Z"]
            pub fn SerializeContext_EnumerateInstanceCallContext_EnumerateInstanceCallContext(
                this: *mut root::AZ::SerializeContext_EnumerateInstanceCallContext,
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                context: *const root::AZ::SerializeContext,
                accessflags: ::std::os::raw::c_uint,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            );
        }
        impl SerializeContext_EnumerateInstanceCallContext {
            #[inline]
            pub unsafe fn new(
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                context: *const root::AZ::SerializeContext,
                accessflags: ::std::os::raw::c_uint,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_EnumerateInstanceCallContext_EnumerateInstanceCallContext(
                    __bindgen_tmp.as_mut_ptr(),
                    beginElemCB,
                    endElemCB,
                    context,
                    accessflags,
                    errorHandler,
                );
                __bindgen_tmp.assume_init()
            }
        }
        pub type SerializeContext_CreateAnyFunc = ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut root::AZ::SerializeContext) -> root::AZStd::any,
        >;
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_ClassBuilder {
            pub m_context: *mut root::AZ::SerializeContext,
            pub m_classData: u64,
            pub m_currentAttributes: *mut root::AZStd::vector<
                root::AZ::AttributeSharedPair,
                root::AZ::AZStdFunctorAllocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?Version@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@IP6A_NAEAV23@AEAVDataElementNode@23@@Z@Z"]
            pub fn SerializeContext_ClassBuilder_Version(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                version: ::std::os::raw::c_uint,
                converter: root::AZ::SerializeContext_VersionConverter,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?Serializer@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@PEAVIDataSerializer@23@@Z"]
            pub fn SerializeContext_ClassBuilder_Serializer(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                serializer: *mut root::AZ::SerializeContext_IDataSerializer,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?SerializeWithNoData@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@XZ"]
            pub fn SerializeContext_ClassBuilder_SerializeWithNoData(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?SerializerForEmptyClass@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@XZ"]
            pub fn SerializeContext_ClassBuilder_SerializerForEmptyClass(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?EventHandler@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@PEAVIEventHandler@23@@Z"]
            pub fn SerializeContext_ClassBuilder_EventHandler(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                eventHandler: *mut root::AZ::SerializeContext_IEventHandler,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?DataContainer@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@PEAVIDataContainer@23@@Z"]
            pub fn SerializeContext_ClassBuilder_DataContainer(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                dataContainer: *mut root::AZ::SerializeContext_IDataContainer,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?PersistentId@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@P6A_KPEBX@Z@Z"]
            pub fn SerializeContext_ClassBuilder_PersistentId(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                persistentId: root::AZ::SerializeContext_ClassPersistentId,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}?SerializerDoSave@ClassBuilder@SerializeContext@AZ@@QEAAPEAV123@P6A_NPEBX@Z@Z"]
            pub fn SerializeContext_ClassBuilder_SerializerDoSave(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
                isSave: root::AZ::SerializeContext_ClassDoSave,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder;
        }
        extern "C" {
            #[link_name = "\u{1}??_DClassBuilder@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_ClassBuilder_ClassBuilder_destructor(
                this: *mut root::AZ::SerializeContext_ClassBuilder,
            );
        }
        impl SerializeContext_ClassBuilder {
            #[inline]
            pub unsafe fn Version(
                &mut self,
                version: ::std::os::raw::c_uint,
                converter: root::AZ::SerializeContext_VersionConverter,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_Version(self, version, converter)
            }
            #[inline]
            pub unsafe fn Serializer(
                &mut self,
                serializer: *mut root::AZ::SerializeContext_IDataSerializer,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_Serializer(self, serializer)
            }
            #[inline]
            pub unsafe fn SerializeWithNoData(
                &mut self,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_SerializeWithNoData(self)
            }
            #[inline]
            pub unsafe fn SerializerForEmptyClass(
                &mut self,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_SerializerForEmptyClass(self)
            }
            #[inline]
            pub unsafe fn EventHandler(
                &mut self,
                eventHandler: *mut root::AZ::SerializeContext_IEventHandler,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_EventHandler(self, eventHandler)
            }
            #[inline]
            pub unsafe fn DataContainer(
                &mut self,
                dataContainer: *mut root::AZ::SerializeContext_IDataContainer,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_DataContainer(self, dataContainer)
            }
            #[inline]
            pub unsafe fn PersistentId(
                &mut self,
                persistentId: root::AZ::SerializeContext_ClassPersistentId,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_PersistentId(self, persistentId)
            }
            #[inline]
            pub unsafe fn SerializerDoSave(
                &mut self,
                isSave: root::AZ::SerializeContext_ClassDoSave,
            ) -> *mut root::AZ::SerializeContext_ClassBuilder {
                SerializeContext_ClassBuilder_SerializerDoSave(self, isSave)
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SerializeContext_ClassBuilder_ClassBuilder_destructor(self)
            }
        }
        pub const SerializeContext_VersionClassDeprecated: ::std::os::raw::c_uint = 4294967295;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_TYPEINFO_Enable(this: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_RTTI_Enable(this: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?CreateEditContext@SerializeContext@AZ@@QEAAPEAVEditContext@2@XZ"]
            pub fn SerializeContext_CreateEditContext(
                this: *mut root::AZ::SerializeContext,
            ) -> *mut root::AZ::EditContext;
        }
        extern "C" {
            #[link_name = "\u{1}?DestroyEditContext@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_DestroyEditContext(this: *mut root::AZ::SerializeContext);
        }
        extern "C" {
            #[link_name = "\u{1}?GetEditContext@SerializeContext@AZ@@QEBAPEAVEditContext@2@XZ"]
            pub fn SerializeContext_GetEditContext(
                this: *const root::AZ::SerializeContext,
            ) -> *mut root::AZ::EditContext;
        }
        extern "C" {
            #[link_name = "\u{1}?ClassDeprecate@SerializeContext@AZ@@QEAAXPEBDAEBUUuid@2@P6A_NAEAV12@AEAVDataElementNode@12@@Z@Z"]
            pub fn SerializeContext_ClassDeprecate(
                this: *mut root::AZ::SerializeContext,
                name: *const ::std::os::raw::c_char,
                typeUuid: *const root::AZ::Uuid,
                converter: root::AZ::SerializeContext_VersionConverter,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateInstanceConst@SerializeContext@AZ@@QEBA_NPEAUEnumerateInstanceCallContext@12@PEBXAEBUUuid@2@PEBVClassData@12@PEBUClassElement@12@@Z"]
            pub fn SerializeContext_EnumerateInstanceConst(
                this: *const root::AZ::SerializeContext,
                callContext: *mut root::AZ::SerializeContext_EnumerateInstanceCallContext,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateInstance@SerializeContext@AZ@@QEBA_NPEAUEnumerateInstanceCallContext@12@PEAXAEBUUuid@2@PEBVClassData@12@PEBUClassElement@12@@Z"]
            pub fn SerializeContext_EnumerateInstance(
                this: *const root::AZ::SerializeContext,
                callContext: *mut root::AZ::SerializeContext_EnumerateInstanceCallContext,
                ptr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateInstanceConst@SerializeContext@AZ@@QEBA_NPEBXAEBUUuid@2@AEBV?$function@$$A6A_NPEAXPEBVClassData@SerializeContext@AZ@@PEBUClassElement@23@@Z@AZStd@@AEBV?$function@$$A6A_NXZ@5@IPEBVClassData@12@PEBUClassElement@12@PEAVErrorHandler@12@@Z"]
            pub fn SerializeContext_EnumerateInstanceConst1(
                this: *const root::AZ::SerializeContext,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                accessFlags: ::std::os::raw::c_uint,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateInstance@SerializeContext@AZ@@QEBA_NPEAXAEBUUuid@2@AEBV?$function@$$A6A_NPEAXPEBVClassData@SerializeContext@AZ@@PEBUClassElement@23@@Z@AZStd@@AEBV?$function@$$A6A_NXZ@5@IPEBVClassData@12@PEBUClassElement@12@PEAVErrorHandler@12@@Z"]
            pub fn SerializeContext_EnumerateInstance1(
                this: *const root::AZ::SerializeContext,
                ptr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                accessFlags: ::std::os::raw::c_uint,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateDerived@SerializeContext@AZ@@QEAAXAEBV?$function@$$A6A_NPEBVClassData@SerializeContext@AZ@@AEBUUuid@3@@Z@AZStd@@AEBUUuid@2@1@Z"]
            pub fn SerializeContext_EnumerateDerived(
                this: *mut root::AZ::SerializeContext,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
                classId: *const root::AZ::Uuid,
                typeId: *const root::AZ::Uuid,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateBase@SerializeContext@AZ@@QEAAXAEBV?$function@$$A6A_NPEBVClassData@SerializeContext@AZ@@AEBUUuid@3@@Z@AZStd@@AEBUUuid@2@@Z"]
            pub fn SerializeContext_EnumerateBase(
                this: *mut root::AZ::SerializeContext,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
                classId: *const root::AZ::Uuid,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?EnumerateAll@SerializeContext@AZ@@QEBAXAEBV?$function@$$A6A_NPEBVClassData@SerializeContext@AZ@@AEBUUuid@3@@Z@AZStd@@@Z"]
            pub fn SerializeContext_EnumerateAll(
                this: *const root::AZ::SerializeContext,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?CloneObject@SerializeContext@AZ@@QEAAPEAXPEBXAEBUUuid@2@@Z"]
            pub fn SerializeContext_CloneObject(
                this: *mut root::AZ::SerializeContext,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?CloneObjectInplace@SerializeContext@AZ@@QEAAXPEAXPEBXAEBUUuid@2@@Z"]
            pub fn SerializeContext_CloneObjectInplace(
                this: *mut root::AZ::SerializeContext,
                dest: *mut ::std::os::raw::c_void,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FindClassData@SerializeContext@AZ@@QEBAPEBVClassData@12@AEBUUuid@2@PEBV312@I@Z"]
            pub fn SerializeContext_FindClassData(
                this: *const root::AZ::SerializeContext,
                classId: *const root::AZ::Uuid,
                parent: *const root::AZ::SerializeContext_ClassData,
                elementNameCrc: root::AZ::u32,
            ) -> *const root::AZ::SerializeContext_ClassData;
        }
        extern "C" {
            #[link_name = "\u{1}?FindClassId@SerializeContext@AZ@@QEBA?AV?$vector@UUuid@AZ@@Vallocator@AZStd@@@AZStd@@AEBVCrc32@2@@Z"]
            pub fn SerializeContext_FindClassId(
                this: *const root::AZ::SerializeContext,
                classNameCrc: *const root::AZ::Crc32,
            ) -> root::AZStd::vector<root::AZ::Uuid, root::AZStd::allocator>;
        }
        extern "C" {
            #[link_name = "\u{1}?FindGenericClassInfo@SerializeContext@AZ@@QEBAPEAVGenericClassInfo@2@AEBUUuid@2@@Z"]
            pub fn SerializeContext_FindGenericClassInfo(
                this: *const root::AZ::SerializeContext,
                classId: *const root::AZ::Uuid,
            ) -> *mut root::AZ::GenericClassInfo;
        }
        extern "C" {
            #[link_name = "\u{1}?CreateAny@SerializeContext@AZ@@QEAA?AVany@AZStd@@AEBUUuid@2@@Z"]
            pub fn SerializeContext_CreateAny(
                this: *mut root::AZ::SerializeContext,
                classId: *const root::AZ::Uuid,
            ) -> root::AZStd::any;
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterGenericClassInfo@SerializeContext@AZ@@QEAAXAEBUUuid@2@PEAVGenericClassInfo@2@AEBQ6A?AVany@AZStd@@PEAV12@@Z@Z"]
            pub fn SerializeContext_RegisterGenericClassInfo(
                this: *mut root::AZ::SerializeContext,
                typeId: *const root::AZ::Uuid,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
                createAnyFunc: *const root::AZ::SerializeContext_CreateAnyFunc,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?CleanupModuleGenericClassInfo@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_CleanupModuleGenericClassInfo(
                this: *mut root::AZ::SerializeContext,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?CanDowncast@SerializeContext@AZ@@QEBA_NAEBUUuid@2@0PEBVIRttiHelper@2@1@Z"]
            pub fn SerializeContext_CanDowncast(
                this: *const root::AZ::SerializeContext,
                fromClassId: *const root::AZ::Uuid,
                toClassId: *const root::AZ::Uuid,
                fromClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
                toClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?DownCast@SerializeContext@AZ@@QEBAPEAXPEAXAEBUUuid@2@1PEBVIRttiHelper@2@2@Z"]
            pub fn SerializeContext_DownCast(
                this: *const root::AZ::SerializeContext,
                instance: *mut ::std::os::raw::c_void,
                fromClassId: *const root::AZ::Uuid,
                toClassId: *const root::AZ::Uuid,
                fromClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
                toClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterDataContainer@SerializeContext@AZ@@QEAAXV?$unique_ptr@VIDataContainer@SerializeContext@AZ@@U?$default_delete@VIDataContainer@SerializeContext@AZ@@@std@@@std@@@Z"]
            pub fn SerializeContext_RegisterDataContainer(
                this: *mut root::AZ::SerializeContext,
                dataContainer: root::std::unique_ptr,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0SerializeContext@AZ@@QEAA@_N0@Z"]
            pub fn SerializeContext_SerializeContext(
                this: *mut root::AZ::SerializeContext,
                registerIntegralTypes: bool,
                createEditContext: bool,
            );
        }
        impl SerializeContext {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                SerializeContext_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                SerializeContext_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn CreateEditContext(&mut self) -> *mut root::AZ::EditContext {
                SerializeContext_CreateEditContext(self)
            }
            #[inline]
            pub unsafe fn DestroyEditContext(&mut self) {
                SerializeContext_DestroyEditContext(self)
            }
            #[inline]
            pub unsafe fn GetEditContext(&self) -> *mut root::AZ::EditContext {
                SerializeContext_GetEditContext(self)
            }
            #[inline]
            pub unsafe fn ClassDeprecate(
                &mut self,
                name: *const ::std::os::raw::c_char,
                typeUuid: *const root::AZ::Uuid,
                converter: root::AZ::SerializeContext_VersionConverter,
            ) {
                SerializeContext_ClassDeprecate(self, name, typeUuid, converter)
            }
            #[inline]
            pub unsafe fn EnumerateInstanceConst(
                &self,
                callContext: *mut root::AZ::SerializeContext_EnumerateInstanceCallContext,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
            ) -> bool {
                SerializeContext_EnumerateInstanceConst(
                    self,
                    callContext,
                    ptr,
                    classId,
                    classData,
                    classElement,
                )
            }
            #[inline]
            pub unsafe fn EnumerateInstance(
                &self,
                callContext: *mut root::AZ::SerializeContext_EnumerateInstanceCallContext,
                ptr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
            ) -> bool {
                SerializeContext_EnumerateInstance(
                    self,
                    callContext,
                    ptr,
                    classId,
                    classData,
                    classElement,
                )
            }
            #[inline]
            pub unsafe fn EnumerateInstanceConst1(
                &self,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                accessFlags: ::std::os::raw::c_uint,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool {
                SerializeContext_EnumerateInstanceConst1(
                    self,
                    ptr,
                    classId,
                    beginElemCB,
                    endElemCB,
                    accessFlags,
                    classData,
                    classElement,
                    errorHandler,
                )
            }
            #[inline]
            pub unsafe fn EnumerateInstance1(
                &self,
                ptr: *mut ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
                beginElemCB: *const root::AZ::SerializeContext_BeginElemEnumCB,
                endElemCB: *const root::AZ::SerializeContext_EndElemEnumCB,
                accessFlags: ::std::os::raw::c_uint,
                classData: *const root::AZ::SerializeContext_ClassData,
                classElement: *const root::AZ::SerializeContext_ClassElement,
                errorHandler: *mut root::AZ::SerializeContext_ErrorHandler,
            ) -> bool {
                SerializeContext_EnumerateInstance1(
                    self,
                    ptr,
                    classId,
                    beginElemCB,
                    endElemCB,
                    accessFlags,
                    classData,
                    classElement,
                    errorHandler,
                )
            }
            #[inline]
            pub unsafe fn EnumerateDerived(
                &mut self,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
                classId: *const root::AZ::Uuid,
                typeId: *const root::AZ::Uuid,
            ) {
                SerializeContext_EnumerateDerived(self, callback, classId, typeId)
            }
            #[inline]
            pub unsafe fn EnumerateBase(
                &mut self,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
                classId: *const root::AZ::Uuid,
            ) {
                SerializeContext_EnumerateBase(self, callback, classId)
            }
            #[inline]
            pub unsafe fn EnumerateAll(
                &self,
                callback: *const root::AZ::SerializeContext_TypeInfoCB,
            ) {
                SerializeContext_EnumerateAll(self, callback)
            }
            #[inline]
            pub unsafe fn CloneObject(
                &mut self,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
            ) -> *mut ::std::os::raw::c_void {
                SerializeContext_CloneObject(self, ptr, classId)
            }
            #[inline]
            pub unsafe fn CloneObjectInplace(
                &mut self,
                dest: *mut ::std::os::raw::c_void,
                ptr: *const ::std::os::raw::c_void,
                classId: *const root::AZ::Uuid,
            ) {
                SerializeContext_CloneObjectInplace(self, dest, ptr, classId)
            }
            #[inline]
            pub unsafe fn FindClassData(
                &self,
                classId: *const root::AZ::Uuid,
                parent: *const root::AZ::SerializeContext_ClassData,
                elementNameCrc: root::AZ::u32,
            ) -> *const root::AZ::SerializeContext_ClassData {
                SerializeContext_FindClassData(self, classId, parent, elementNameCrc)
            }
            #[inline]
            pub unsafe fn FindClassId(
                &self,
                classNameCrc: *const root::AZ::Crc32,
            ) -> root::AZStd::vector<root::AZ::Uuid, root::AZStd::allocator> {
                SerializeContext_FindClassId(self, classNameCrc)
            }
            #[inline]
            pub unsafe fn FindGenericClassInfo(
                &self,
                classId: *const root::AZ::Uuid,
            ) -> *mut root::AZ::GenericClassInfo {
                SerializeContext_FindGenericClassInfo(self, classId)
            }
            #[inline]
            pub unsafe fn CreateAny(&mut self, classId: *const root::AZ::Uuid) -> root::AZStd::any {
                SerializeContext_CreateAny(self, classId)
            }
            #[inline]
            pub unsafe fn RegisterGenericClassInfo(
                &mut self,
                typeId: *const root::AZ::Uuid,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
                createAnyFunc: *const root::AZ::SerializeContext_CreateAnyFunc,
            ) {
                SerializeContext_RegisterGenericClassInfo(
                    self,
                    typeId,
                    genericClassInfo,
                    createAnyFunc,
                )
            }
            #[inline]
            pub unsafe fn CleanupModuleGenericClassInfo(&mut self) {
                SerializeContext_CleanupModuleGenericClassInfo(self)
            }
            #[inline]
            pub unsafe fn CanDowncast(
                &self,
                fromClassId: *const root::AZ::Uuid,
                toClassId: *const root::AZ::Uuid,
                fromClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
                toClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
            ) -> bool {
                SerializeContext_CanDowncast(
                    self,
                    fromClassId,
                    toClassId,
                    fromClassHelper,
                    toClassHelper,
                )
            }
            #[inline]
            pub unsafe fn DownCast(
                &self,
                instance: *mut ::std::os::raw::c_void,
                fromClassId: *const root::AZ::Uuid,
                toClassId: *const root::AZ::Uuid,
                fromClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
                toClassHelper: *const root::AZ::SerializeContext_IRttiHelper,
            ) -> *mut ::std::os::raw::c_void {
                SerializeContext_DownCast(
                    self,
                    instance,
                    fromClassId,
                    toClassId,
                    fromClassHelper,
                    toClassHelper,
                )
            }
            #[inline]
            pub unsafe fn RegisterDataContainer(&mut self, dataContainer: root::std::unique_ptr) {
                SerializeContext_RegisterDataContainer(self, dataContainer)
            }
            #[inline]
            pub unsafe fn new(registerIntegralTypes: bool, createEditContext: bool) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_SerializeContext(
                    __bindgen_tmp.as_mut_ptr(),
                    registerIntegralTypes,
                    createEditContext,
                );
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DSerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_SerializeContext_destructor(
                this: *mut root::AZ::SerializeContext,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?IsTypeReflected@SerializeContext@AZ@@UEBA_NUUuid@2@@Z"]
            pub fn SerializeContext_IsTypeReflected(
                this: *mut ::std::os::raw::c_void,
                typeId: root::AZ::Uuid,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?ElementsUpdated@IDataContainer@SerializeContext@AZ@@UEAAXPEAX@Z"]
            pub fn SerializeContext_IDataContainer_ElementsUpdated(
                this: *mut ::std::os::raw::c_void,
                instance: *mut ::std::os::raw::c_void,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetCurrentSerializeContextModule@AZ@@YAAEAVPerModuleGenericClassInfo@SerializeContext@1@XZ"]
            pub fn GetCurrentSerializeContextModule(
            ) -> *mut root::AZ::SerializeContext_PerModuleGenericClassInfo;
        }
        #[repr(C)]
        pub struct GenericClassInfo__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct GenericClassInfo {
            pub vtable_: *const GenericClassInfo__bindgen_vtable,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeGenericTypeInfo {
            pub _address: u8,
        }
        pub type SerializeGenericTypeInfo_ClassInfoType = root::AZ::GenericClassInfo;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct AnyTypeInfoConcept {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct SerializeTypeInfo {
            pub _address: u8,
        }
        pub type SerializeTypeInfo_ValueType = root::std::remove_pointer;
        pub mod SerializeInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ElementInfo {
                pub _address: u8,
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct SerializeContext_PerModuleGenericClassInfo {
            pub m_moduleOSAllocator: root::AZ::OSAllocator,
            pub m_moduleLocalGenericClassInfos:
                root::AZ::SerializeContext_PerModuleGenericClassInfo_GenericInfoModuleMap,
            pub m_serializeContextSet:
                root::AZ::SerializeContext_PerModuleGenericClassInfo_SerializeContextSet,
        }
        pub type SerializeContext_PerModuleGenericClassInfo_GenericInfoModuleMap =
            root::AZStd::unordered_map;
        pub type SerializeContext_PerModuleGenericClassInfo_SerializeContextSet =
            root::AZStd::unordered_set;
        extern "C" {
            #[link_name = "\u{1}?GetAllocator@PerModuleGenericClassInfo@SerializeContext@AZ@@QEAAAEAVIAllocatorAllocate@3@XZ"]
            pub fn SerializeContext_PerModuleGenericClassInfo_GetAllocator(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
            ) -> *mut root::AZ::IAllocatorAllocate;
        }
        extern "C" {
            #[link_name = "\u{1}?AddGenericClassInfo@PerModuleGenericClassInfo@SerializeContext@AZ@@QEAAXPEAVGenericClassInfo@3@@Z"]
            pub fn SerializeContext_PerModuleGenericClassInfo_AddGenericClassInfo(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RemoveGenericClassInfo@PerModuleGenericClassInfo@SerializeContext@AZ@@QEAAXAEBUUuid@3@@Z"]
            pub fn SerializeContext_PerModuleGenericClassInfo_RemoveGenericClassInfo(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
                canonicalTypeId: *const root::AZ::TypeId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterSerializeContext@PerModuleGenericClassInfo@SerializeContext@AZ@@QEAAXPEAV23@@Z"]
            pub fn SerializeContext_PerModuleGenericClassInfo_RegisterSerializeContext(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
                serializeContext: *mut root::AZ::SerializeContext,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?UnregisterSerializeContext@PerModuleGenericClassInfo@SerializeContext@AZ@@QEAAXPEAV23@@Z"]
            pub fn SerializeContext_PerModuleGenericClassInfo_UnregisterSerializeContext(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
                serializeContext: *mut root::AZ::SerializeContext,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?FindGenericClassInfo@PerModuleGenericClassInfo@SerializeContext@AZ@@QEBAPEAVGenericClassInfo@3@AEBUUuid@3@@Z"]
            pub fn SerializeContext_PerModuleGenericClassInfo_FindGenericClassInfo(
                this: *const root::AZ::SerializeContext_PerModuleGenericClassInfo,
                genericTypeId: *const root::AZ::TypeId,
            ) -> *mut root::AZ::GenericClassInfo;
        }
        extern "C" {
            #[link_name = "\u{1}??0PerModuleGenericClassInfo@SerializeContext@AZ@@QEAA@XZ"]
            pub fn SerializeContext_PerModuleGenericClassInfo_PerModuleGenericClassInfo(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_DPerModuleGenericClassInfo@SerializeContext@AZ@@QEAAXXZ"]
            pub fn SerializeContext_PerModuleGenericClassInfo_PerModuleGenericClassInfo_destructor(
                this: *mut root::AZ::SerializeContext_PerModuleGenericClassInfo,
            );
        }
        impl SerializeContext_PerModuleGenericClassInfo {
            #[inline]
            pub unsafe fn GetAllocator(&mut self) -> *mut root::AZ::IAllocatorAllocate {
                SerializeContext_PerModuleGenericClassInfo_GetAllocator(self)
            }
            #[inline]
            pub unsafe fn AddGenericClassInfo(
                &mut self,
                genericClassInfo: *mut root::AZ::GenericClassInfo,
            ) {
                SerializeContext_PerModuleGenericClassInfo_AddGenericClassInfo(
                    self,
                    genericClassInfo,
                )
            }
            #[inline]
            pub unsafe fn RemoveGenericClassInfo(
                &mut self,
                canonicalTypeId: *const root::AZ::TypeId,
            ) {
                SerializeContext_PerModuleGenericClassInfo_RemoveGenericClassInfo(
                    self,
                    canonicalTypeId,
                )
            }
            #[inline]
            pub unsafe fn RegisterSerializeContext(
                &mut self,
                serializeContext: *mut root::AZ::SerializeContext,
            ) {
                SerializeContext_PerModuleGenericClassInfo_RegisterSerializeContext(
                    self,
                    serializeContext,
                )
            }
            #[inline]
            pub unsafe fn UnregisterSerializeContext(
                &mut self,
                serializeContext: *mut root::AZ::SerializeContext,
            ) {
                SerializeContext_PerModuleGenericClassInfo_UnregisterSerializeContext(
                    self,
                    serializeContext,
                )
            }
            #[inline]
            pub unsafe fn FindGenericClassInfo(
                &self,
                genericTypeId: *const root::AZ::TypeId,
            ) -> *mut root::AZ::GenericClassInfo {
                SerializeContext_PerModuleGenericClassInfo_FindGenericClassInfo(self, genericTypeId)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                SerializeContext_PerModuleGenericClassInfo_PerModuleGenericClassInfo(
                    __bindgen_tmp.as_mut_ptr(),
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                SerializeContext_PerModuleGenericClassInfo_PerModuleGenericClassInfo_destructor(
                    self,
                )
            }
        }
        pub mod VariantSerializationInternal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug)]
            pub struct AZStdVariantContainer {
                pub _base: root::AZ::SerializeContext_IDataContainer,
                pub m_alternativeClassElements: *mut root::AZ::SerializeContext_ClassElement,
            }
            pub type AZStdVariantContainer_VariantType = root::AZStd::variant;
        }
        extern "C" {
            #[link_name = "\u{1}?GetAssetClassId@AZ@@YAAEBUUuid@1@XZ"]
            pub fn GetAssetClassId() -> *const root::AZ::Uuid;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetSerializer {
            pub _base: root::AZ::SerializeContext_IDataSerializer,
        }
        extern "C" {
            #[link_name = "\u{1}?s_serializer@AssetSerializer@AZ@@2V12@A"]
            pub static mut AssetSerializer_s_serializer: root::AZ::AssetSerializer;
        }
        extern "C" {
            #[link_name = "\u{1}?LoadWithFilter@AssetSerializer@AZ@@QEAA_NPEAXAEAVGenericStream@IO@2@IAEBV?$function@$$A6A_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@AZ@@@Z@AZStd@@_N@Z"]
            pub fn AssetSerializer_LoadWithFilter(
                this: *mut root::AZ::AssetSerializer,
                classPtr: *mut ::std::os::raw::c_void,
                stream: *mut root::AZ::IO::GenericStream,
                version: ::std::os::raw::c_uint,
                assetFilterCallback: *const root::AZ::Data::AssetFilterCB,
                isDataBigEndian: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Clone@AssetSerializer@AZ@@QEAAXPEBXPEAX@Z"]
            pub fn AssetSerializer_Clone(
                this: *mut root::AZ::AssetSerializer,
                sourcePtr: *const ::std::os::raw::c_void,
                destPtr: *mut ::std::os::raw::c_void,
            );
        }
        impl AssetSerializer {
            #[inline]
            pub unsafe fn LoadWithFilter(
                &mut self,
                classPtr: *mut ::std::os::raw::c_void,
                stream: *mut root::AZ::IO::GenericStream,
                version: ::std::os::raw::c_uint,
                assetFilterCallback: *const root::AZ::Data::AssetFilterCB,
                isDataBigEndian: bool,
            ) -> bool {
                AssetSerializer_LoadWithFilter(
                    self,
                    classPtr,
                    stream,
                    version,
                    assetFilterCallback,
                    isDataBigEndian,
                )
            }
            #[inline]
            pub unsafe fn Clone(
                &mut self,
                sourcePtr: *const ::std::os::raw::c_void,
                destPtr: *mut ::std::os::raw::c_void,
            ) {
                AssetSerializer_Clone(self, sourcePtr, destPtr)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?Save@AssetSerializer@AZ@@UEAA_KPEBXAEAVGenericStream@IO@2@_N@Z"]
            pub fn AssetSerializer_Save(
                this: *mut ::std::os::raw::c_void,
                classPtr: *const ::std::os::raw::c_void,
                stream: *mut root::AZ::IO::GenericStream,
                isDataBigEndian: bool,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?DataToText@AssetSerializer@AZ@@UEAA_KAEAVGenericStream@IO@2@0_N@Z"]
            pub fn AssetSerializer_DataToText(
                this: *mut ::std::os::raw::c_void,
                in_: *mut root::AZ::IO::GenericStream,
                out: *mut root::AZ::IO::GenericStream,
                isDataBigEndian: bool,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?TextToData@AssetSerializer@AZ@@UEAA_KPEBDIAEAVGenericStream@IO@2@_N@Z"]
            pub fn AssetSerializer_TextToData(
                this: *mut ::std::os::raw::c_void,
                text: *const ::std::os::raw::c_char,
                textVersion: ::std::os::raw::c_uint,
                stream: *mut root::AZ::IO::GenericStream,
                isDataBigEndian: bool,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?Load@AssetSerializer@AZ@@UEAA_NPEAXAEAVGenericStream@IO@2@I_N@Z"]
            pub fn AssetSerializer_Load(
                this: *mut ::std::os::raw::c_void,
                classPtr: *mut ::std::os::raw::c_void,
                stream: *mut root::AZ::IO::GenericStream,
                version: ::std::os::raw::c_uint,
                isDataBigEndian: bool,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?CompareValueData@AssetSerializer@AZ@@UEAA_NPEBX0@Z"]
            pub fn AssetSerializer_CompareValueData(
                this: *mut ::std::os::raw::c_void,
                lhs: *const ::std::os::raw::c_void,
                rhs: *const ::std::os::raw::c_void,
            ) -> bool;
        }
        pub type OSString =
            root::AZStd::basic_string<::std::os::raw::c_char, root::AZ::OSStdAllocator>;
        pub mod SerializeContextAttributes {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        pub type ObjectStreamWriteOverrideCB = root::AZStd::function;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct DataStream {
            pub m_type: root::AZ::DataStream_StreamType,
        }
        pub const DataStream_StreamType_ST_XML: root::AZ::DataStream_StreamType = 0;
        pub const DataStream_StreamType_ST_JSON: root::AZ::DataStream_StreamType = 1;
        pub const DataStream_StreamType_ST_BINARY: root::AZ::DataStream_StreamType = 2;
        pub const DataStream_StreamType_ST_MAX: root::AZ::DataStream_StreamType = 3;
        pub type DataStream_StreamType = i32;
        #[repr(C)]
        pub struct ObjectStream__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ObjectStream {
            pub vtable_: *const ObjectStream__bindgen_vtable,
            pub _base: root::AZ::DataStream,
            pub m_sc: *mut root::AZ::SerializeContext,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectStream_Descriptor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ObjectStream_Handle {
            pub m_job: *mut root::AZ::ObjectStream,
        }
        pub type ObjectStream_InplaceLoadRootInfoCB = [u64; 5usize];
        pub type ObjectStream_ClassReadyCB = root::AZStd::function;
        pub type ObjectStream_CompletionCB = root::AZStd::function;
        pub const ObjectStream_FilterFlags_FILTERFLAG_STRICT: root::AZ::ObjectStream_FilterFlags =
            1;
        pub const ObjectStream_FilterFlags_FILTERFLAG_IGNORE_UNKNOWN_CLASSES:
            root::AZ::ObjectStream_FilterFlags = 2;
        pub type ObjectStream_FilterFlags = i32;
        #[repr(C)]
        pub struct ObjectStream_FilterDescriptor {
            pub m_flags: root::AZ::u32,
            pub m_assetCB: root::AZ::Data::AssetFilterCB,
        }
        extern "C" {
            #[link_name = "\u{1}?LoadBlocking@ObjectStream@AZ@@SA_NPEAVGenericStream@IO@2@AEAVSerializeContext@2@AEBV?$function@$$A6AXPEAXAEBUUuid@AZ@@PEAVSerializeContext@2@@Z@AZStd@@AEBUFilterDescriptor@12@AEBV?$function@$$A6AXPEAPEAXPEAPEBVClassData@SerializeContext@AZ@@AEBUUuid@3@PEAV23@@Z@7@@Z"]
            pub fn ObjectStream_LoadBlocking(
                stream: *mut root::AZ::IO::GenericStream,
                sc: *mut root::AZ::SerializeContext,
                readyCB: *const root::AZ::ObjectStream_ClassReadyCB,
                filterDesc: *const root::AZ::ObjectStream_FilterDescriptor,
                inplaceRootInfo: *const root::AZ::ObjectStream_InplaceLoadRootInfoCB,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Create@ObjectStream@AZ@@SAPEAV12@PEAVGenericStream@IO@2@AEAVSerializeContext@2@W4StreamType@DataStream@2@@Z"]
            pub fn ObjectStream_Create(
                stream: *mut root::AZ::IO::GenericStream,
                sc: *mut root::AZ::SerializeContext,
                fmt: root::AZ::DataStream_StreamType,
            ) -> *mut root::AZ::ObjectStream;
        }
        extern "C" {
            #[link_name = "\u{1}?AssetFilterDefault@ObjectStream@AZ@@SA_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@2@@Z"]
            pub fn ObjectStream_AssetFilterDefault(asset: *const root::AZ::Data::Asset) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?AssetFilterSlicesOnly@ObjectStream@AZ@@SA_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@2@@Z"]
            pub fn ObjectStream_AssetFilterSlicesOnly(asset: *const root::AZ::Data::Asset) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Cancel@ObjectStream@AZ@@SA_NVHandle@12@@Z"]
            pub fn ObjectStream_Cancel(jobHandle: root::AZ::ObjectStream_Handle) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?AssetFilterNoAssetLoading@ObjectStream@AZ@@SA_NAEBV?$Asset@VAssetData@Data@AZ@@@Data@2@@Z"]
            pub fn ObjectStream_AssetFilterNoAssetLoading(
                asset: *const root::AZ::Data::Asset,
            ) -> bool;
        }
        impl ObjectStream {
            #[inline]
            pub unsafe fn LoadBlocking(
                stream: *mut root::AZ::IO::GenericStream,
                sc: *mut root::AZ::SerializeContext,
                readyCB: *const root::AZ::ObjectStream_ClassReadyCB,
                filterDesc: *const root::AZ::ObjectStream_FilterDescriptor,
                inplaceRootInfo: *const root::AZ::ObjectStream_InplaceLoadRootInfoCB,
            ) -> bool {
                ObjectStream_LoadBlocking(stream, sc, readyCB, filterDesc, inplaceRootInfo)
            }
            #[inline]
            pub unsafe fn Create(
                stream: *mut root::AZ::IO::GenericStream,
                sc: *mut root::AZ::SerializeContext,
                fmt: root::AZ::DataStream_StreamType,
            ) -> *mut root::AZ::ObjectStream {
                ObjectStream_Create(stream, sc, fmt)
            }
            #[inline]
            pub unsafe fn AssetFilterDefault(asset: *const root::AZ::Data::Asset) -> bool {
                ObjectStream_AssetFilterDefault(asset)
            }
            #[inline]
            pub unsafe fn AssetFilterSlicesOnly(asset: *const root::AZ::Data::Asset) -> bool {
                ObjectStream_AssetFilterSlicesOnly(asset)
            }
            #[inline]
            pub unsafe fn Cancel(jobHandle: root::AZ::ObjectStream_Handle) -> bool {
                ObjectStream_Cancel(jobHandle)
            }
            #[inline]
            pub unsafe fn AssetFilterNoAssetLoading(asset: *const root::AZ::Data::Asset) -> bool {
                ObjectStream_AssetFilterNoAssetLoading(asset)
            }
        }
        pub mod Utils {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type FilterDescriptor = root::AZ::ObjectStream_FilterDescriptor;
            extern "C" {
                #[link_name = "\u{1}?LoadObjectFromStream@Utils@AZ@@YAPEAXAEAVGenericStream@IO@2@PEAVSerializeContext@2@PEBUUuid@2@AEBUFilterDescriptor@ObjectStream@2@@Z"]
                pub fn LoadObjectFromStream(
                    stream: *mut root::AZ::IO::GenericStream,
                    context: *mut root::AZ::SerializeContext,
                    targetClassId: *const root::AZ::Uuid,
                    filterDesc: *const root::AZ::Utils::FilterDescriptor,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?LoadObjectFromStreamInPlace@Utils@AZ@@YA_NAEAVGenericStream@IO@2@PEAVSerializeContext@2@AEBUUuid@2@PEAXAEBUFilterDescriptor@ObjectStream@2@@Z"]
                pub fn LoadObjectFromStreamInPlace(
                    stream: *mut root::AZ::IO::GenericStream,
                    context: *mut root::AZ::SerializeContext,
                    targetClassId: *const root::AZ::Uuid,
                    targetPointer: *mut ::std::os::raw::c_void,
                    filterDesc: *const root::AZ::Utils::FilterDescriptor,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?LoadObjectFromStreamInPlace@Utils@AZ@@YA_NAEAVGenericStream@IO@2@PEAVSerializeContext@2@PEBVClassData@52@PEAXAEBUFilterDescriptor@ObjectStream@2@@Z"]
                pub fn LoadObjectFromStreamInPlace1(
                    stream: *mut root::AZ::IO::GenericStream,
                    context: *mut root::AZ::SerializeContext,
                    objectClassData: *const root::AZ::SerializeContext_ClassData,
                    targetPointer: *mut ::std::os::raw::c_void,
                    filterDesc: *const root::AZ::Utils::FilterDescriptor,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?LoadObjectFromFile@Utils@AZ@@YAPEAXAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@AEBUUuid@2@PEAVSerializeContext@2@AEBUFilterDescriptor@ObjectStream@2@H@Z"]
                pub fn LoadObjectFromFile(
                    filePath: *const root::AZStd::string,
                    targetClassId: *const root::AZ::Uuid,
                    context: *mut root::AZ::SerializeContext,
                    filterDesc: *const root::AZ::Utils::FilterDescriptor,
                    platformFlags: ::std::os::raw::c_int,
                ) -> *mut ::std::os::raw::c_void;
            }
            extern "C" {
                #[link_name = "\u{1}?SaveObjectToStream@Utils@AZ@@YA_NAEAVGenericStream@IO@2@W4StreamType@DataStream@2@PEBXAEBUUuid@2@PEAVSerializeContext@2@PEBVClassData@82@@Z"]
                pub fn SaveObjectToStream(
                    stream: *mut root::AZ::IO::GenericStream,
                    streamType: root::AZ::DataStream_StreamType,
                    classPtr: *const ::std::os::raw::c_void,
                    classId: *const root::AZ::Uuid,
                    context: *mut root::AZ::SerializeContext,
                    classData: *const root::AZ::SerializeContext_ClassData,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?SaveObjectToFile@Utils@AZ@@YA_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@W4StreamType@DataStream@2@PEBXAEBUUuid@2@PEAVSerializeContext@2@H@Z"]
                pub fn SaveObjectToFile(
                    filePath: *const root::AZStd::string,
                    fileType: root::AZ::DataStream_StreamType,
                    classPtr: *const ::std::os::raw::c_void,
                    classId: *const root::AZ::Uuid,
                    context: *mut root::AZ::SerializeContext,
                    platformFlags: ::std::os::raw::c_int,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?FindDescendantElements@Utils@AZ@@YA?AV?$vector@PEAVDataElementNode@SerializeContext@AZ@@Vallocator@AZStd@@@AZStd@@AEAVSerializeContext@2@AEAVDataElementNode@52@AEBV?$vector@VCrc32@AZ@@Vallocator@AZStd@@@4@@Z"]
                pub fn FindDescendantElements(
                    context: *mut root::AZ::SerializeContext,
                    classElement: *mut root::AZ::SerializeContext_DataElementNode,
                    elementCrcQueue: *const root::AZStd::vector<
                        root::AZ::Crc32,
                        root::AZStd::allocator,
                    >,
                ) -> root::AZStd::vector<
                    *mut root::AZ::SerializeContext_DataElementNode,
                    root::AZStd::allocator,
                >;
            }
            extern "C" {
                #[link_name = "\u{1}?FindDescendantElements@Utils@AZ@@YAXAEAVSerializeContext@2@AEAVDataElementNode@32@AEAV?$vector@PEAVDataElementNode@SerializeContext@AZ@@Vallocator@AZStd@@@AZStd@@PEBVCrc32@2@3@Z"]
                pub fn FindDescendantElements1(
                    context: *mut root::AZ::SerializeContext,
                    classElement: *mut root::AZ::SerializeContext_DataElementNode,
                    dataElementNodes: *mut root::AZStd::vector<
                        *mut root::AZ::SerializeContext_DataElementNode,
                        root::AZStd::allocator,
                    >,
                    first: root::const_iterator,
                    last: root::const_iterator,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?LoadObjectFromFileInPlace@Utils@AZ@@YA_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@AEBUUuid@2@PEAXPEAVSerializeContext@2@AEBUFilterDescriptor@ObjectStream@2@@Z"]
                pub fn LoadObjectFromFileInPlace(
                    filePath: *const root::AZStd::string,
                    targetClassId: *const root::AZ::Uuid,
                    destination: *mut ::std::os::raw::c_void,
                    context: *mut root::AZ::SerializeContext,
                    filterDesc: *const root::AZ::Utils::FilterDescriptor,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsVectorContainerType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsVectorContainerType(type_: *const root::AZ::Uuid) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsSetContainerType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsSetContainerType(type_: *const root::AZ::Uuid) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsMapContainerType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsMapContainerType(type_: *const root::AZ::Uuid) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsContainerType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsContainerType(type_: *const root::AZ::Uuid) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?IsOutcomeType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsOutcomeType(type_: *const root::AZ::Uuid) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetGenericContainerType@Utils@AZ@@YA?AUUuid@2@AEBU32@@Z"]
                pub fn GetGenericContainerType(type_: *const root::AZ::TypeId) -> root::AZ::TypeId;
            }
            extern "C" {
                #[link_name = "\u{1}?IsGenericContainerType@Utils@AZ@@YA_NAEBUUuid@2@@Z"]
                pub fn IsGenericContainerType(type_: *const root::AZ::TypeId) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}?GetOutcomeTypes@Utils@AZ@@YA?AU?$pair@UUuid@AZ@@U12@@AZStd@@AEBUUuid@2@@Z"]
                pub fn GetOutcomeTypes(
                    type_: *const root::AZ::Uuid,
                ) -> root::AZStd::pair<root::AZ::Uuid, root::AZ::Uuid>;
            }
            extern "C" {
                #[link_name = "\u{1}?GetContainedTypes@Utils@AZ@@YA?AV?$vector@UUuid@AZ@@Vallocator@AZStd@@@AZStd@@AEBUUuid@2@@Z"]
                pub fn GetContainedTypes(
                    type_: *const root::AZ::Uuid,
                ) -> root::AZStd::vector<root::AZ::Uuid, root::AZStd::allocator>;
            }
        }
    }
    pub type va_list = *mut ::std::os::raw::c_char;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type integral_constant_value_type<_Ty> = _Ty;
        pub type integral_constant_type = u8;
        pub type bool_constant = u8;
        pub type true_type = u8;
        pub type false_type = u8;
        pub type conditional_type<_Ty2> = _Ty2;
        pub type conditional_t = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_const {
            pub _address: u8,
        }
        pub type remove_const_type<_Ty> = _Ty;
        pub type remove_const_t = root::std::remove_const;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cv {
            pub _address: u8,
        }
        pub type remove_cv_type<_Ty> = _Ty;
        pub type remove_cv_t = root::std::remove_cv;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_reference {
            pub _address: u8,
        }
        pub type remove_reference_type<_Ty> = _Ty;
        pub type remove_reference_t = root::std::remove_reference;
        pub mod tr1 {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Add_reference {
            pub _address: u8,
        }
        pub type _Add_reference__Lvalue<_Ty> = _Ty;
        pub type _Add_reference__Rvalue<_Ty> = _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_lvalue_reference {
            pub _address: u8,
        }
        pub type add_lvalue_reference_type = root::std::_Add_reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_rvalue_reference {
            pub _address: u8,
        }
        pub type add_rvalue_reference_type = root::std::_Add_reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_pointer {
            pub _address: u8,
        }
        pub type remove_pointer_type<_Ty> = _Ty;
        pub type remove_pointer_t = root::std::remove_pointer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Add_pointer {
            pub _address: u8,
        }
        pub type _Add_pointer_type<_Ty> = _Ty;
        pub type add_pointer_t = root::std::_Add_pointer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_empty {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Change_sign {
            pub _address: u8,
        }
        pub type _Change_sign__Signed = root::std::conditional_t;
        pub type _Change_sign__Unsigned = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_unsigned {
            pub _address: u8,
        }
        pub type make_unsigned_type = root::std::_Change_sign;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct underlying_type {
            pub _address: u8,
        }
        pub type underlying_type_type<_Ty> = _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct decay {
            pub _address: u8,
        }
        pub type decay__Ty1 = root::std::remove_reference_t;
        pub type decay_type = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct tuple_size {
            pub _address: u8,
        }
        pub type _Compressed_pair__Mybase<_Ty1> = _Ty1;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Ignore {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Replace_first_parameter {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_element_type {
            pub _address: u8,
        }
        pub type _Get_element_type_type = root::std::_Get_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_ptr_difference_type {
            pub _address: u8,
        }
        pub type _Get_ptr_difference_type_type = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_rebind_alias {
            pub _address: u8,
        }
        pub type _Get_rebind_alias_type = root::std::_Replace_first_parameter;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pointer_traits {
            pub _address: u8,
        }
        pub type pointer_traits_element_type = root::std::_Get_element_type;
        pub type pointer_traits_pointer<_Ty> = _Ty;
        pub type pointer_traits_difference_type = root::std::_Get_ptr_difference_type;
        pub type pointer_traits_rebind = root::std::_Get_rebind_alias;
        pub type pointer_traits__Reftype = root::std::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Get_deleter_pointer_type {
            pub _address: u8,
        }
        pub type _Get_deleter_pointer_type_type<_Ty> = *mut _Ty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Unique_ptr_base {
            pub _Mypair: u8,
        }
        pub type _Unique_ptr_base__Dx_noref = root::std::remove_reference_t;
        pub type _Unique_ptr_base_pointer = root::std::_Get_deleter_pointer_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_ptr {
            pub _base: root::std::_Unique_ptr_base,
        }
        pub type unique_ptr__Mybase = root::std::_Unique_ptr_base;
        pub type unique_ptr_pointer = root::std::unique_ptr__Mybase;
        pub type unique_ptr_element_type<_Ty> = _Ty;
        pub type unique_ptr_deleter_type<_Dx> = _Dx;
        pub type _Uint1_t = ::std::os::raw::c_uchar;
        pub type _Atomic_impl__My_int = root::std::_Uint1_t;
        pub type _Atomic_base__Mybase = u8;
        pub type _Atomic_base__My_int = root::std::_Atomic_base__Mybase;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct atomic {
            pub _address: u8,
        }
        pub type atomic__My_base = u8;
        pub type atomic_value_type<_Ty> = _Ty;
        pub type atomic_bool = root::std::atomic;
    }
    pub mod AZStd {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type size_type = root::AZStd::allocator_size_type;
        pub type sys_time_t = root::AZ::s64;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<Arg> = Arg;
        pub type unary_function_result_type<Result> = Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<Arg1> = Arg1;
        pub type binary_function_second_argument_type<Arg2> = Arg2;
        pub type binary_function_result_type<Result> = Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct plus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct minus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct multiplies {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct divides {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct modulus {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct negate {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct not_equal_to {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct greater_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct less_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct logical_not {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_negate<Functor> {
            pub m_functor: Functor,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Functor>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_negate<Functor> {
            pub m_functor: Functor,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Functor>>,
        }
        pub type bool_constant = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_void {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_integral {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_floating_point {
            pub _base: u8,
        }
        pub mod type_traits {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const ice_or_value: bool = true;
            pub const ice_and_value: bool = false;
            pub const ice_not_value: bool = true;
            pub type yes_type = ::std::os::raw::c_char;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct no_type {
                pub padding: [::std::os::raw::c_char; 8usize],
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ice_eq_value: bool;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ice_ne_value: bool;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct wrap {
                pub _address: u8,
            }
        }
        pub mod Internal {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_arithmetic_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_member_pointer_helper {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_scalar_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_pod_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct alignment_of_hack {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static alignment_logic_value: usize;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct alignment_of_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Copy, Clone)]
            pub union aligned_storage__bindgen_ty_1 {
                pub _bindgen_opaque_blob: u64,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_abstract_imp {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_basic_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl {
                pub _address: u8,
            }
            pub type is_convertible_impl_ref_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_select_rebind {
                pub _address: u8,
            }
            pub type is_convertible_impl_select_rebind_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_dispatch_base {
                pub _address: u8,
            }
            pub type is_convertible_impl_dispatch_base_selector = u8;
            pub type is_convertible_impl_dispatch_base_isc_binder = u8;
            pub type is_convertible_impl_dispatch_base_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_convertible_impl_dispatch {
                pub _address: u8,
            }
            extern "C" {
                #[link_name = "\u{1}?is_lvalue_reference_helper1@Internal@AZStd@@YADZZ"]
                pub fn is_lvalue_reference_helper1() -> ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}?is_lvalue_reference_helper2@Internal@AZStd@@YADZZ"]
                pub fn is_lvalue_reference_helper2() -> root::AZStd::type_traits::yes_type;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_lvalue_reference_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct are_pair_args_comparable {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct addr_impl_ref {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct addressof_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_in_place_index {
                pub _address: u8,
            }
            pub type is_in_place_index_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_base_and_derived_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_class_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_function_pointer_tester {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_member_function_pointer_tester {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct nat {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct param_any {
                pub _bindgen_opaque_blob: u8,
            }
            extern "C" {
                #[link_name = "\u{1}??0param_any@Internal@AZStd@@QEAA@ZZ"]
                pub fn param_any_param_any(this: *mut root::AZStd::Internal::param_any, ...);
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct check_complete_type {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct member_pointer_class_type {
                pub _address: u8,
            }
            pub type member_pointer_class_type_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct invocable_r {
                pub _address: u8,
            }
            pub type invocable_r_result_type = u8;
            pub type invocable_r_type = u8;
            pub type invocable = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_dtor_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_ctor_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_assign_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_trivial_copy_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct destroy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct construct {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_copy_helper {
                pub _address: u8,
            }
            pub type is_fast_copy_helper_value_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_copy {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_fill_helper {
                pub _address: u8,
            }
            pub type is_fast_fill_helper_value_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_fast_fill {
                pub _address: u8,
            }
            pub mod function_util {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct X {
                    _unused: [u8; 0],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Copy, Clone)]
                pub union function_buffer {
                    pub _bindgen_opaque_blob: [u64; 4usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_type_t {
                    pub _bindgen_opaque_blob: [u64; 2usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_bound_memfunc_ptr_t {
                    pub _bindgen_opaque_blob: [u64; 4usize],
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_buffer_obj_ref_t {
                    pub _bindgen_opaque_blob: [u64; 2usize],
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct unusable {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct function_return_type {
                    pub _address: u8,
                }
                pub type function_return_type_type = u8;
                pub const functor_manager_operation_type_clone_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 0;
                pub const functor_manager_operation_type_move_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 1;
                pub const functor_manager_operation_type_destroy_functor_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 2;
                pub const functor_manager_operation_type_check_functor_type_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 3;
                pub const functor_manager_operation_type_get_functor_type_tag:
                    root::AZStd::Internal::function_util::functor_manager_operation_type = 4;
                pub type functor_manager_operation_type = i32;
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_ptr_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_obj_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct member_ptr_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct function_obj_ref_tag {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct get_function_tag {
                    pub _address: u8,
                }
                pub type get_function_tag_ptr_or_obj_tag = u8;
                pub type get_function_tag_ptr_or_obj_or_mem_tag = u8;
                pub type get_function_tag_or_ref_tag = u8;
                pub type get_function_tag_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct reference_manager {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct function_allows_small_object_optimization {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_wrapper {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager_common {
                    pub _address: u8,
                }
                pub type functor_manager_common_functor_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager {
                    pub _address: u8,
                }
                pub type functor_manager_functor_type = u8;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct functor_manager_a {
                    pub _address: u8,
                }
                pub type functor_manager_a_functor_type = u8;
                #[repr(C)]
                #[repr(align(1))]
                #[derive(Debug, Copy, Clone)]
                pub struct useless_clear_type {
                    pub _bindgen_opaque_blob: u8,
                }
                #[repr(C)]
                #[repr(align(8))]
                #[derive(Debug, Copy, Clone)]
                pub struct vtable_base {
                    pub _bindgen_opaque_blob: u64,
                }
                pub type vtable_base_type = [u32; 0usize];
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct invoke_void_return_wrapper {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct get_invoker {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct basic_vtable {
                    pub _address: u8,
                }
                pub type basic_vtable_invoker_type = u8;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_gcd_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_lcm_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_abs_value: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static static_sign_value: root::AZ::s64;
            }
            pub const ll_mul_nan: root::AZ::s64 = -9223372036854775808;
            extern "C" {
                #[link_name = "\u{1}min"]
                pub static ll_mul_min: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}max"]
                pub static ll_mul_max: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}a_x"]
                pub static ll_mul_a_x: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}a_y"]
                pub static ll_mul_a_y: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}test1"]
                pub static mut ll_mul_test1: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test2"]
                pub static mut ll_mul_test2: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test"]
                pub static mut ll_mul_test: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ll_mul_value: root::AZ::s64;
            }
            pub const ll_div_nan: root::AZ::s64 = -9223372036854775808;
            extern "C" {
                #[link_name = "\u{1}min"]
                pub static ll_div_min: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}max"]
                pub static ll_div_max: root::AZ::s64;
            }
            extern "C" {
                #[link_name = "\u{1}test1"]
                pub static mut ll_div_test1: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test2"]
                pub static mut ll_div_test2: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}test3"]
                pub static mut ll_div_test3: *mut ::std::os::raw::c_char;
            }
            extern "C" {
                #[link_name = "\u{1}value"]
                pub static ll_div_value: root::AZ::s64;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ratio_gcd {
                pub _address: u8,
            }
            pub type ratio_gcd_type = u8;
            pub type common_ternary_t = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_2_default {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_2_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct common_type_multi_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_move_t {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_info {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct thread_info_impl {}
            extern "C" {
                #[link_name = "\u{1}?create_thread@Internal@AZStd@@YAPEAXPEBUthread_desc@2@PEAVthread_info@12@PEAI@Z"]
                pub fn create_thread(
                    desc: *const root::AZStd::thread_desc,
                    ti: *mut root::AZStd::Internal::thread_info,
                    id: *mut ::std::os::raw::c_uint,
                ) -> root::HANDLE;
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_convertible {
                pub _address: u8,
            }
            pub type sp_convertible_yes = u8;
            pub type sp_convertible_no = [u8; 2usize];
            pub const sp_convertible__vt_value: root::AZStd::Internal::sp_convertible__vt = 0;
            pub type sp_convertible__vt = i32;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_empty {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_enable_if_convertible {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Copy, Clone)]
            pub union OptionalDestructBase__bindgen_ty_1 {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct OptionalImplBase {
                pub _address: u8,
            }
            pub type OptionalImplBase_base = u8;
            pub type OptionalCopyBase_base = u8;
            pub type OptionalMoveBase_base = u8;
            pub type OptionalCopyAssignBase_base = u8;
            pub type OptionalMoveAssignBase_base = u8;
            pub type OptionalSFINAECtorBase_t = u8;
            pub type OptionalSFINAEAssignBase_t = u8;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct list_node_base {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct list_node {
                pub _address: u8,
            }
            pub type hash_table_storage_this_type = u8;
            pub type hash_table_storage_allocator_type = u8;
            pub type hash_table_storage_list_type = u8;
            pub type hash_table_storage_size_type = u8;
            pub type hash_table_storage_vector_value_type = u8;
            pub type hash_table_storage_vector_type = u8;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct rbtree_node_base {
                pub _bindgen_opaque_blob: [u64; 3usize],
            }
            pub type rbtree_node_base_color_type = u32;
            pub type rbtree_node_base_BaseNodePtr = u64;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct rbtree_node {
                pub _address: u8,
            }
            pub type UnorderedMapTableTraits_key_type = u8;
            pub type UnorderedMapTableTraits_key_eq = u8;
            pub type UnorderedMapTableTraits_hasher = u8;
            pub type UnorderedMapTableTraits_value_type = u8;
            pub type UnorderedMapTableTraits_allocator_type = u8;
            pub const UnorderedMapTableTraits_max_load_factor:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_min_buckets:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_has_multi_elements:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_is_dynamic:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_fixed_num_buckets:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedMapTableTraits_fixed_num_elements:
                root::AZStd::Internal::UnorderedMapTableTraits__bindgen_ty_1 = 0;
            pub type UnorderedMapTableTraits__bindgen_ty_1 = i32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct ConvertKeyType {
                pub _address: u8,
            }
            pub type ConvertKeyType_key_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pack_traits_arg_sequence {
                pub _address: u8,
            }
            pub type pack_traits_get_arg_t = u8;
            pub const qualifier_flags_default_: root::AZStd::Internal::qualifier_flags = 0;
            pub const qualifier_flags_const_: root::AZStd::Internal::qualifier_flags = 1;
            pub const qualifier_flags_volatile_: root::AZStd::Internal::qualifier_flags = 2;
            pub const qualifier_flags_lvalue_ref: root::AZStd::Internal::qualifier_flags = 4;
            pub const qualifier_flags_rvalue_ref: root::AZStd::Internal::qualifier_flags = 8;
            pub const qualifier_flags_const_volatile: root::AZStd::Internal::qualifier_flags = 3;
            pub const qualifier_flags_const_lvalue_ref: root::AZStd::Internal::qualifier_flags = 5;
            pub const qualifier_flags_const_rvalue_ref: root::AZStd::Internal::qualifier_flags = 9;
            pub const qualifier_flags_volatile_lvalue_ref: root::AZStd::Internal::qualifier_flags =
                6;
            pub const qualifier_flags_volatile_rvalue_ref: root::AZStd::Internal::qualifier_flags =
                10;
            pub const qualifier_flags_const_volatile_lvalue_ref:
                root::AZStd::Internal::qualifier_flags = 7;
            pub const qualifier_flags_const_volatile_rvalue_ref:
                root::AZStd::Internal::qualifier_flags = 11;
            pub type qualifier_flags = u32;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct error_type {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct has_call_operator {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct default_traits {
                pub _address: u8,
            }
            pub type default_traits_type = u8;
            pub type default_traits_class_type = u8;
            pub type default_traits_invoke_type = u8;
            pub type default_traits_return_type = u8;
            pub type default_traits_arg_types = u8;
            pub type default_traits_non_invoke_arg_types = u8;
            pub type default_traits_function_object_signature = u8;
            pub type default_traits_function_type = u8;
            pub type default_traits_expand_args = u8;
            pub type default_traits_class_fp_type = u8;
            pub type default_traits_raw_fp_type = u8;
            pub type default_traits_result_type = u8;
            pub type default_traits_get_arg_t = u8;
            pub type default_traits_arg_sequence = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pointer_to_member_function {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct pointer_to_member_data {
                pub _address: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct raw_function {
                pub _address: u8,
            }
            pub type callable_traits = u8;
            pub type UnorderedSetTableTraits_key_type = u8;
            pub type UnorderedSetTableTraits_key_eq = u8;
            pub type UnorderedSetTableTraits_hasher = u8;
            pub type UnorderedSetTableTraits_value_type = u8;
            pub type UnorderedSetTableTraits_allocator_type = u8;
            pub const UnorderedSetTableTraits_max_load_factor:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_min_buckets:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_has_multi_elements:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_is_dynamic:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_fixed_num_buckets:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub const UnorderedSetTableTraits_fixed_num_elements:
                root::AZStd::Internal::UnorderedSetTableTraits__bindgen_ty_1 = 0;
            pub type UnorderedSetTableTraits__bindgen_ty_1 = i32;
            pub type sp_typeinfo = u64;
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_counted_base {
                pub _bindgen_opaque_blob: [u64; 2usize],
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_counted_impl_pa {}
            pub type sp_counted_impl_pa_this_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_counted_impl_pda {}
            pub type sp_counted_impl_pda_this_type = u8;
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_nothrow_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct sp_inplace_tag {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct shared_count {
                pub _bindgen_opaque_blob: u64,
            }
            extern "C" {
                #[link_name = "\u{1}??0shared_count@Internal@AZStd@@QEAA@AEBVweak_count@12@@Z"]
                pub fn shared_count_shared_count(
                    this: *mut root::AZStd::Internal::shared_count,
                    r: *const root::AZStd::Internal::weak_count,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0shared_count@Internal@AZStd@@QEAA@AEBVweak_count@12@Usp_nothrow_tag@12@@Z"]
                pub fn shared_count_shared_count1(
                    this: *mut root::AZStd::Internal::shared_count,
                    r: *const root::AZStd::Internal::weak_count,
                    arg1: root::AZStd::Internal::sp_nothrow_tag,
                );
            }
            impl shared_count {
                #[inline]
                pub unsafe fn new(r: *const root::AZStd::Internal::weak_count) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    shared_count_shared_count(__bindgen_tmp.as_mut_ptr(), r);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    r: *const root::AZStd::Internal::weak_count,
                    arg1: root::AZStd::Internal::sp_nothrow_tag,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    shared_count_shared_count1(__bindgen_tmp.as_mut_ptr(), r, arg1);
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct weak_count {
                pub _bindgen_opaque_blob: u64,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct static_cast_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct const_cast_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct dynamic_cast_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct reinterpret_cast_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[repr(align(1))]
            #[derive(Debug, Copy, Clone)]
            pub struct rtti_cast_tag {
                pub _bindgen_opaque_blob: u8,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct shared_ptr_traits {
                pub _address: u8,
            }
            pub type shared_ptr_traits_reference = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct is_object_impl {
                pub _address: u8,
            }
            #[repr(C)]
            #[repr(align(8))]
            #[derive(Debug, Copy, Clone)]
            pub struct ErrorSink {
                pub _bindgen_opaque_blob: u64,
            }
            pub const Internal_ANY_SBO_BUF_SIZE: root::AZStd::Internal::_bindgen_ty_1 = 32;
            pub type _bindgen_ty_1 = i32;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct template_is_copy_constructible {
                pub _address: u8,
            }
            pub type template_is_copy_constructible_type = u8;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_arithmetic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_same {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_reference {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_enum {
            pub _address: u8,
        }
        pub type remove_cv_t = root::std::remove_cv_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_scalar {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_pod {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct alignment_of {
            pub _address: u8,
        }
        pub type aligned_storage_type = u8;
        pub type aligned_storage_t = u8;
        pub type aligned_storage_for_t = root::AZStd::aligned_storage_t;
        pub mod Utils {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub type if_c_type<T1> = T1;
        }
        pub type conditional_type<T2> = T2;
        pub type conditional_t = u8;
        pub type enable_if_t = u8;
        pub type remove_reference_t = root::std::remove_reference;
        pub type remove_const_t = root::std::remove_const_t;
        pub type add_lvalue_reference_t = root::std::add_lvalue_reference;
        pub type add_rvalue_reference_t = root::std::add_rvalue_reference;
        pub type decay_t = root::std::decay;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_reference_wrapper {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unwrap_reference {
            pub _address: u8,
        }
        pub type unwrap_reference_type = root::std::decay;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_array {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_abstract {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_convertible {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_lvalue_reference {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_delete {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_delete {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}size"]
            pub static index_sequence_size: usize;
        }
        pub type make_index_sequence = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct piecewise_construct_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<T1, T2> {
            pub first: T1,
            pub second: T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<T2>>,
        }
        pub type pair_this_type<T1, T2> = root::AZStd::pair<T1, T2>;
        pub type pair_first_type<T1> = T1;
        pub type pair_second_type<T2> = T2;
        pub type pair_TT1 = root::std::remove_reference;
        pub type pair_TT2 = root::std::remove_reference;
        pub type RemoveEnum_type = root::std::underlying_type;
        pub type RemoveEnumT = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HandleLambdaPointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RemoveFunctionConst {
            pub _address: u8,
        }
        pub type RemoveFunctionConst_type = root::AZStd::HandleLambdaPointer;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sequence_and {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sequence_or {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct in_place_type_t {
            pub _address: u8,
        }
        pub type native_mutex_data_type = [u64; 5usize];
        pub type native_mutex_handle_type = *mut root::CRITICAL_SECTION;
        pub type native_recursive_mutex_data_type = root::AZStd::native_mutex_data_type;
        pub type native_recursive_mutex_handle_type = *mut root::CRITICAL_SECTION;
        pub type native_cond_var_data_type = u8;
        pub type native_cond_var_handle_type = *mut root::CONDITION_VARIABLE;
        pub type native_semaphore_data_type = root::HANDLE;
        pub type native_semaphore_handle_type = root::HANDLE;
        pub type native_thread_id_type = ::std::os::raw::c_uint;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct native_thread_data_type {
            pub m_handle: root::HANDLE,
            pub m_id: root::AZStd::native_thread_id_type,
        }
        pub type native_thread_handle_type = root::HANDLE;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_id {
            pub m_id: root::AZStd::native_thread_id_type,
        }
        pub type atomic_char = root::std::atomic;
        pub type atomic_uchar = root::std::atomic;
        pub type atomic_wchar_t = root::std::atomic;
        pub type atomic_short = root::std::atomic;
        pub type atomic_ushort = root::std::atomic;
        pub type atomic_int = root::std::atomic;
        pub type atomic_uint = root::std::atomic;
        pub type atomic_long = root::std::atomic;
        pub type atomic_ulong = root::std::atomic;
        pub type atomic_llong = root::std::atomic;
        pub type atomic_ullong = root::std::atomic;
        pub type atomic_size_t = root::std::atomic;
        pub type atomic_ptrdiff_t = root::std::atomic;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct default_destruct {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_destruct {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct static_storage {
            pub m_storage: u8,
            pub m_object: root::std::atomic,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_base_and_derived {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_base_of {
            pub _address: u8,
        }
        pub type remove_pointer_t = root::std::remove_pointer_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_class {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_function_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_member_object_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_invocable_r {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct invoke_result {
            pub _address: u8,
        }
        pub type invoke_result_t = root::AZStd::invoke_result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash {
            pub _address: u8,
        }
        pub type hash_argument_type<T> = T;
        pub type hash_result_type = usize;
        pub type DefaultHashResultType_type = root::std::true_type;
        pub type HasDefaultHash_Yes = ::std::os::raw::c_char;
        pub type HasDefaultHash_No = ::std::os::raw::c_long;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasDefaultHash_Helper {
            pub _address: u8,
        }
        pub type HasDefaultHash_Helper_mfp = ::std::option::Option<unsafe extern "C" fn() -> bool>;
        pub type HasDefaultHash_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct HasSpecializedHasher {
            pub _address: u8,
        }
        pub type HasSpecializedHasher_type = u8;
        extern "C" {
            #[link_name = "\u{1}?hash_next_bucket_size@AZStd@@YA_K_K@Z"]
            pub fn hash_next_bucket_size(n: usize) -> usize;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct random_access_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct continuous_random_access_iterator_tag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_value_type<T> = T;
        pub type iterator_difference_type<Distance> = Distance;
        pub type iterator_pointer<Pointer> = Pointer;
        pub type iterator_reference<Reference> = Reference;
        pub type iterator_iterator_category<Category> = Category;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        pub type iterator_traits_iterator_category = [u8; 0usize];
        pub type iterator_traits_value_type = [u8; 0usize];
        pub type iterator_traits_difference_type = [u8; 0usize];
        pub type iterator_traits_pointer = [u8; 0usize];
        pub type iterator_traits_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<Iterator> {
            pub m_current: Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub type reverse_iterator_this_type<Iterator> = root::AZStd::reverse_iterator<Iterator>;
        pub type reverse_iterator_iterator_type<Iterator> = Iterator;
        pub type reverse_iterator_reference = root::AZStd::iterator_traits;
        pub type reverse_iterator_pointer = root::AZStd::iterator_traits;
        pub type reverse_iterator_difference_type = root::AZStd::iterator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct move_iterator<Iterator> {
            pub m_current: root::AZStd::move_iterator_iterator_type<Iterator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub type move_iterator_iterator_base = root::AZStd::iterator;
        pub type move_iterator_reference = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_pointer = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_difference_type = root::AZStd::move_iterator_iterator_base;
        pub type move_iterator_this_type<Iterator> = root::AZStd::move_iterator<Iterator>;
        pub type move_iterator_iterator_type<Iterator> = Iterator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct back_insert_iterator<Container> {
            pub m_container: *mut Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type back_insert_iterator_this_type<Container> =
            root::AZStd::back_insert_iterator<Container>;
        pub type back_insert_iterator_container_type<Container> = Container;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct front_insert_iterator<Container> {
            pub m_container: *mut Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type front_insert_iterator_this_type<Container> =
            root::AZStd::front_insert_iterator<Container>;
        pub type front_insert_iterator_container_type<Container> = Container;
        #[repr(C)]
        pub struct insert_iterator<Container> {
            pub m_container: *mut Container,
            pub m_iterator: root::AZStd::insert_iterator_container_iterator_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub type insert_iterator_this_type<Container> = root::AZStd::insert_iterator<Container>;
        pub type insert_iterator_container_type<Container> = Container;
        pub type insert_iterator_container_iterator_type = [u8; 0usize];
        pub const iterator_status_flag_isf_none: root::AZStd::iterator_status_flag = 0;
        pub const iterator_status_flag_isf_valid: root::AZStd::iterator_status_flag = 1;
        pub const iterator_status_flag_isf_can_dereference: root::AZStd::iterator_status_flag = 2;
        pub const iterator_status_flag_isf_current: root::AZStd::iterator_status_flag = 4;
        pub type iterator_status_flag = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_continuous_random_access_iterator_cat {
            pub _base: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string_view<Element> {
            pub m_begin: root::AZStd::basic_string_view_const_pointer<Element>,
            pub m_end: root::AZStd::basic_string_view_const_pointer<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type basic_string_view_traits_type<Traits> = Traits;
        pub type basic_string_view_value_type<Element> = Element;
        pub type basic_string_view_pointer<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_pointer<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reference<Element> =
            *mut root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_reference<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_size_type = usize;
        pub type basic_string_view_difference_type = isize;
        pub type basic_string_view_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_const_iterator<Element> =
            *const root::AZStd::basic_string_view_value_type<Element>;
        pub type basic_string_view_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_iterator<Element>>;
        pub type basic_string_view_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_view_const_iterator<Element>>;
        pub type string_view = root::AZStd::basic_string_view<::std::os::raw::c_char>;
        pub type wstring_view = root::AZStd::basic_string_view<u16>;
        pub type basic_const_string<Element> = root::AZStd::basic_string_view<Element>;
        pub type const_string = root::AZStd::string_view;
        pub type const_wstring = root::AZStd::wstring_view;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_list {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator {
            pub m_name: *const ::std::os::raw::c_char,
        }
        pub type allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type allocator_size_type = usize;
        pub type allocator_difference_type = isize;
        pub type allocator_allow_memory_leaks = root::std::false_type;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@allocator@AZStd@@QEAAXXZ"]
            pub fn allocator_TYPEINFO_Enable(this: *mut root::AZStd::allocator);
        }
        extern "C" {
            #[link_name = "\u{1}?allocate@allocator@AZStd@@QEAAPEAX_K0H@Z"]
            pub fn allocator_allocate(
                this: *mut root::AZStd::allocator,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type;
        }
        extern "C" {
            #[link_name = "\u{1}?deallocate@allocator@AZStd@@QEAAXPEAX_K1@Z"]
            pub fn allocator_deallocate(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?resize@allocator@AZStd@@QEAA_KPEAX_K@Z"]
            pub fn allocator_resize(
                this: *mut root::AZStd::allocator,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_max_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_max_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        extern "C" {
            #[link_name = "\u{1}?get_allocated_size@allocator@AZStd@@QEBA_KXZ"]
            pub fn allocator_get_allocated_size(
                this: *const root::AZStd::allocator,
            ) -> root::AZStd::allocator_size_type;
        }
        impl allocator {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                allocator_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn allocate(
                &mut self,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
                flags: ::std::os::raw::c_int,
            ) -> root::AZStd::allocator_pointer_type {
                allocator_allocate(self, byteSize, alignment, flags)
            }
            #[inline]
            pub unsafe fn deallocate(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                byteSize: root::AZStd::allocator_size_type,
                alignment: root::AZStd::allocator_size_type,
            ) {
                allocator_deallocate(self, ptr, byteSize, alignment)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                ptr: root::AZStd::allocator_pointer_type,
                newSize: root::AZStd::allocator_size_type,
            ) -> root::AZStd::allocator_size_type {
                allocator_resize(self, ptr, newSize)
            }
            #[inline]
            pub unsafe fn get_max_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_max_size(self)
            }
            #[inline]
            pub unsafe fn get_allocated_size(&self) -> root::AZStd::allocator_size_type {
                allocator_get_allocated_size(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct no_default_allocator {
            pub _address: u8,
        }
        pub type no_default_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type no_default_allocator_size_type = usize;
        pub type no_default_allocator_difference_type = isize;
        pub type no_default_allocator_allow_memory_leaks = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bad_function_call {
            _unused: [u8; 0],
        }
        pub type type_id = *mut ::std::os::raw::c_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct type_id_holder {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_cvref {
            pub _address: u8,
        }
        pub type remove_cvref_type = root::AZStd::remove_cv_t;
        pub type remove_cvref_t = root::AZStd::remove_cvref;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_destructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_constructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_default_constructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_assign {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_trivial_copy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function_base {
            pub vtable: *mut root::AZStd::Internal::function_util::vtable_base,
            pub functor: root::AZStd::Internal::function_util::function_buffer,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct function_intermediate {
            pub _base: root::AZStd::function_base,
        }
        pub type function_intermediate_result_type<R> = R;
        pub type function_intermediate_vtable_type = u8;
        pub type function_intermediate_self_type = root::AZStd::function_intermediate;
        pub type atto = u8;
        pub type femto = u8;
        pub type pico = u8;
        pub type nano = u8;
        pub type micro = u8;
        pub type milli = u8;
        pub type centi = u8;
        pub type deci = u8;
        pub type deca = u8;
        pub type hecto = u8;
        pub type kilo = u8;
        pub type mega = u8;
        pub type giga = u8;
        pub type tera = u8;
        pub type peta = u8;
        pub type exa = u8;
        extern "C" {
            #[link_name = "\u{1}test1"]
            pub static mut ratio_test1: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}test2"]
            pub static mut ratio_test2: *mut ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}m_na"]
            pub static ratio_m_na: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_da"]
            pub static ratio_m_da: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_s"]
            pub static ratio_m_s: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}m_gcd"]
            pub static ratio_m_gcd: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}num"]
            pub static ratio_num: root::AZ::s64;
        }
        extern "C" {
            #[link_name = "\u{1}den"]
            pub static ratio_den: root::AZ::s64;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_add {
            pub _address: u8,
        }
        pub type ratio_add_type = root::AZStd::ratio_multiply;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_subtract {
            pub _address: u8,
        }
        pub type ratio_subtract_type = root::AZStd::ratio_multiply;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_multiply {
            pub _address: u8,
        }
        pub type ratio_multiply_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_divide {
            pub _address: u8,
        }
        pub type ratio_divide_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_not_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_less {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_less_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_greater {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ratio_greater_equal {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct make_void {
            pub _address: u8,
        }
        pub type make_void_type = ::std::os::raw::c_void;
        pub type void_t = root::AZStd::make_void;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct common_type {
            pub _address: u8,
        }
        pub type common_type_t = root::AZStd::common_type;
        pub mod chrono {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub mod Internal {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_value {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct is_duration {
                    pub _base: root::std::false_type,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_eq {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct duration_lt {
                    pub _address: u8,
                }
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct treat_as_floating_point {
                pub _base: root::AZStd::is_floating_point,
            }
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct duration<Rep> {
                pub m_rep: root::AZStd::chrono::duration_rep<Rep>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Rep>>,
            }
            pub type duration_rep<Rep> = Rep;
            pub type duration_period<Period> = Period;
            pub type nanoseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type microseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type milliseconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type seconds = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type minutes = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            pub type hours = root::AZStd::chrono::duration<root::AZStd::sys_time_t>;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct time_point<Duration> {
                pub m_d: root::AZStd::chrono::time_point_duration<Duration>,
                pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Duration>>,
            }
            pub type time_point_clock<Clock> = Clock;
            pub type time_point_duration<Duration> = Duration;
            pub type time_point_rep = [u8; 0usize];
            pub type time_point_period = [u8; 0usize];
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct system_clock {
                pub _address: u8,
            }
            pub type system_clock_duration = root::AZStd::chrono::microseconds;
            pub type system_clock_rep = root::rep;
            pub type system_clock_period = u8;
            pub type system_clock_time_point = root::AZStd::chrono::time_point<
                root::AZStd::chrono::duration<::std::os::raw::c_longlong>,
            >;
            pub const system_clock_is_monotonic: bool = true;
            pub type monotonic_clock = root::AZStd::chrono::system_clock;
            pub type high_resolution_clock = root::AZStd::chrono::monotonic_clock;
            extern "C" {
                #[link_name = "\u{1}?system_clock_now@chrono@AZStd@@YA?AV?$time_point@Vsystem_clock@chrono@AZStd@@V?$duration@_JV?$ratio@$00$0PECEA@@AZStd@@@23@@12@XZ"]
                pub fn system_clock_now() -> root::AZStd::chrono::system_clock_time_point;
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct thread_desc {
            pub m_stack: *mut ::std::os::raw::c_void,
            pub m_stackSize: ::std::os::raw::c_int,
            pub m_priority: ::std::os::raw::c_int,
            pub m_cpuId: ::std::os::raw::c_int,
            pub m_isJoinable: bool,
            pub m_name: *const ::std::os::raw::c_char,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct thread {
            pub m_thread: root::AZStd::native_thread_data_type,
        }
        pub type thread_native_handle_type = root::AZStd::native_thread_handle_type;
        extern "C" {
            #[link_name = "\u{1}?joinable@thread@AZStd@@QEBA_NXZ"]
            pub fn thread_joinable(this: *const root::AZStd::thread) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?join@thread@AZStd@@QEAAXXZ"]
            pub fn thread_join(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}?detach@thread@AZStd@@QEAAXXZ"]
            pub fn thread_detach(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}?get_id@thread@AZStd@@QEBA?AUthread_id@2@XZ"]
            pub fn thread_get_id(this: *const root::AZStd::thread) -> root::AZStd::thread_id;
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@thread@AZStd@@QEAAPEAXXZ"]
            pub fn thread_native_handle(
                this: *mut root::AZStd::thread,
            ) -> root::AZStd::thread_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}?hardware_concurrency@thread@AZStd@@SAIXZ"]
            pub fn thread_hardware_concurrency() -> ::std::os::raw::c_uint;
        }
        extern "C" {
            #[link_name = "\u{1}??0thread@AZStd@@QEAA@XZ"]
            pub fn thread_thread(this: *mut root::AZStd::thread);
        }
        extern "C" {
            #[link_name = "\u{1}??0thread@AZStd@@QEAA@U?$thread_move_t@Vthread@AZStd@@@Internal@1@@Z"]
            pub fn thread_thread1(this: *mut root::AZStd::thread, rhs: u64);
        }
        extern "C" {
            #[link_name = "\u{1}??_Dthread@AZStd@@QEAAXXZ"]
            pub fn thread_thread_destructor(this: *mut root::AZStd::thread);
        }
        impl thread {
            #[inline]
            pub unsafe fn joinable(&self) -> bool {
                thread_joinable(self)
            }
            #[inline]
            pub unsafe fn join(&mut self) {
                thread_join(self)
            }
            #[inline]
            pub unsafe fn detach(&mut self) {
                thread_detach(self)
            }
            #[inline]
            pub unsafe fn get_id(&self) -> root::AZStd::thread_id {
                thread_get_id(self)
            }
            #[inline]
            pub unsafe fn native_handle(&mut self) -> root::AZStd::thread_native_handle_type {
                thread_native_handle(self)
            }
            #[inline]
            pub unsafe fn hardware_concurrency() -> ::std::os::raw::c_uint {
                thread_hardware_concurrency()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(rhs: u64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                thread_thread1(__bindgen_tmp.as_mut_ptr(), rhs);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                thread_thread_destructor(self)
            }
        }
        pub mod this_thread {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            extern "C" {
                #[link_name = "\u{1}?get_id@this_thread@AZStd@@YA?AUthread_id@2@XZ"]
                pub fn get_id() -> root::AZStd::thread_id;
            }
            extern "C" {
                #[link_name = "\u{1}?yield@this_thread@AZStd@@YAXXZ"]
                pub fn yield_();
            }
            extern "C" {
                #[link_name = "\u{1}?pause@this_thread@AZStd@@YAXH@Z"]
                pub fn pause(numLoops: ::std::os::raw::c_int);
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct IntrusivePtrCountPolicy {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct intrusive_ptr<T> {
            pub px: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_ptr_this_type<T> = root::AZStd::intrusive_ptr<T>;
        pub type intrusive_ptr_CountPolicy = root::AZStd::IntrusivePtrCountPolicy;
        pub type intrusive_ptr_element_type<T> = T;
        pub type intrusive_ptr_value_type<T> = T;
        pub type intrusive_ptr_unspecified_bool_type<T> = *mut *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct upgrade_lock {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct defer_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct try_to_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct adopt_lock_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct lock_guard<Mutex> {
            pub m_mutex: *mut root::AZStd::lock_guard_mutex_type<Mutex>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type lock_guard_mutex_type<Mutex> = Mutex;
        #[repr(C)]
        #[derive(Debug)]
        pub struct unique_lock<Mutex> {
            pub m_mutex: *mut root::AZStd::unique_lock_mutex_type<Mutex>,
            pub m_owns: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type unique_lock_mutex_type<Mutex> = Mutex;
        #[repr(C)]
        #[derive(Debug)]
        pub struct shared_lock<Mutex> {
            pub m_mutex: *mut root::AZStd::shared_lock_mutex_type<Mutex>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Mutex>>,
        }
        pub type shared_lock_mutex_type<Mutex> = Mutex;
        pub const deque_block_num_elements: root::AZStd::deque_block__bindgen_ty_1 = 0;
        pub type deque_block__bindgen_ty_1 = i32;
        pub const deque_CONTAINER_VERSION: root::AZStd::deque__bindgen_ty_1 = 0;
        pub type deque__bindgen_ty_1 = i32;
        pub type deque_this_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct deque_block_node {
            pub m_data: u8,
        }
        pub type deque_pointer<T> = *mut T;
        pub type deque_const_pointer<T> = *const T;
        pub type deque_reference<T> = *mut T;
        pub type deque_const_reference<T> = *const T;
        pub type deque_difference_type = [u8; 0usize];
        pub type deque_size_type = [u8; 0usize];
        pub type deque_allocator_type<Allocator> = Allocator;
        pub type deque_value_type<T> = T;
        pub type deque_block_node_type = root::AZStd::deque_block_node;
        pub type deque_map_node_type<T> = root::AZStd::deque_pointer<T>;
        pub type deque_map_node_ptr_type<T> = *mut root::AZStd::deque_map_node_type<T>;
        #[repr(C)]
        pub struct deque_const_iterator_impl {
            pub m_offset: root::AZStd::deque_size_type,
            pub m_container: *const root::AZStd::deque_const_iterator_impl_container_type,
        }
        pub const deque_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::deque_const_iterator_impl__bindgen_ty_1 = 0;
        pub type deque_const_iterator_impl__bindgen_ty_1 = i32;
        pub type deque_const_iterator_impl_this_type = root::AZStd::deque_const_iterator_impl;
        pub type deque_const_iterator_impl_container_type = u8;
        pub type deque_const_iterator_impl_value_type<T> = T;
        pub type deque_const_iterator_impl_difference_type = isize;
        pub type deque_const_iterator_impl_pointer<T> = *const T;
        pub type deque_const_iterator_impl_reference<T> = *const T;
        pub type deque_const_iterator_impl_iterator_category =
            root::AZStd::random_access_iterator_tag;
        #[repr(C)]
        pub struct deque_iterator_impl {
            pub _base: root::AZStd::deque_const_iterator_impl,
        }
        pub type deque_iterator_impl_this_type = root::AZStd::deque_iterator_impl;
        pub type deque_iterator_impl_base_type = root::AZStd::deque_const_iterator_impl;
        pub type deque_iterator_impl_container_type = u8;
        pub type deque_iterator_impl_pointer<T> = *mut T;
        pub type deque_iterator_impl_reference<T> = *mut T;
        pub type deque_iterator_impl_difference_type = isize;
        pub type deque_iterator = root::AZStd::deque_iterator_impl;
        pub type deque_const_iterator = root::AZStd::deque_const_iterator_impl;
        pub type deque_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::deque_iterator>;
        pub type deque_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::deque_const_iterator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct vector<T, Allocator> {
            pub m_start: root::AZStd::vector_pointer<T>,
            pub m_last: root::AZStd::vector_pointer<T>,
            pub m_end: root::AZStd::vector_pointer<T>,
            pub m_allocator: root::AZStd::vector_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub const vector_CONTAINER_VERSION: root::AZStd::vector__bindgen_ty_1 = 0;
        pub type vector__bindgen_ty_1 = i32;
        pub type vector_this_type<T, Allocator> = root::AZStd::vector<T, Allocator>;
        pub type vector_pointer<T> = *mut T;
        pub type vector_const_pointer<T> = *const T;
        pub type vector_reference<T> = *mut T;
        pub type vector_const_reference<T> = *const T;
        pub type vector_difference_type = [u8; 0usize];
        pub type vector_size_type = [u8; 0usize];
        pub type vector_iterator_impl<T> = root::AZStd::vector_pointer<T>;
        pub type vector_const_iterator_impl<T> = root::AZStd::vector_const_pointer<T>;
        pub type vector_iterator<T> = root::AZStd::vector_iterator_impl<T>;
        pub type vector_const_iterator<T> = root::AZStd::vector_const_iterator_impl<T>;
        pub type vector_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_iterator<T>>;
        pub type vector_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::vector_const_iterator<T>>;
        pub type vector_value_type<T> = T;
        pub type vector_allocator_type<Allocator> = Allocator;
        pub type vector_node_type<T> = root::AZStd::vector_value_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct queue<Container> {
            pub m_container: Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub const queue_CONTAINER_VERSION: root::AZStd::queue__bindgen_ty_1 = 0;
        pub type queue__bindgen_ty_1 = i32;
        pub type queue_this_type<Container> = root::AZStd::queue<Container>;
        pub type queue_container_type<Container> = Container;
        pub type queue_value_type = [u8; 0usize];
        pub type queue_size_type = [u8; 0usize];
        pub type queue_reference = [u8; 0usize];
        pub type queue_const_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct priority_queue<Container, Predicate> {
            pub m_container: Container,
            pub m_comp: Predicate,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Predicate>>,
        }
        pub const priority_queue_CONTAINER_VERSION: root::AZStd::priority_queue__bindgen_ty_1 = 0;
        pub type priority_queue__bindgen_ty_1 = i32;
        pub type priority_queue_this_type<Container, Predicate> =
            root::AZStd::priority_queue<Container, Predicate>;
        pub type priority_queue_container_type<Container> = Container;
        pub type priority_queue_value_type = [u8; 0usize];
        pub type priority_queue_size_type = [u8; 0usize];
        pub type priority_queue_reference = [u8; 0usize];
        pub type priority_queue_const_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_node<T> {
            pub m_children: [*mut T; 2usize],
            pub m_neighbours: [*mut T; 2usize],
            pub m_parentColorSide: *mut T,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_multiset_node_ColorType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_SideType = ::std::os::raw::c_int;
        pub type intrusive_multiset_node_this_type<T> = root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_node_node_ptr_type<T> = *mut T;
        pub const intrusive_multiset_node_Bits_BIT_COLOR:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_PARENT_SIDE:
            root::AZStd::intrusive_multiset_node_Bits = 0;
        pub const intrusive_multiset_node_Bits_BIT_MASK: root::AZStd::intrusive_multiset_node_Bits =
            0;
        pub type intrusive_multiset_node_Bits = i32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_base_hook {
            pub _address: u8,
        }
        pub type intrusive_multiset_base_hook_pointer<T> = *mut T;
        pub type intrusive_multiset_base_hook_const_pointer<T> = *const T;
        pub type intrusive_multiset_base_hook_node_type<T> =
            root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_base_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_base_hook_node_type<T>;
        pub type intrusive_multiset_base_hook_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_base_hook_node_type<T>;
        pub type intrusive_multiset_member_hook_pointer<T> = *mut T;
        pub type intrusive_multiset_member_hook_const_pointer<T> = *const T;
        pub type intrusive_multiset_member_hook_node_type<T> =
            root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_member_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_member_hook_node_type<T>;
        pub type intrusive_multiset_member_hook_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_member_hook_node_type<T>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct intrusive_multiset<Compare> {
            pub m_head: u8,
            pub m_numElements: usize,
            pub m_keyCompare: root::AZStd::intrusive_multiset_KeyCompare<Compare>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Compare>>,
        }
        pub const intrusive_multiset_CONTAINER_VERSION:
            root::AZStd::intrusive_multiset__bindgen_ty_1 = 0;
        pub type intrusive_multiset__bindgen_ty_1 = i32;
        pub type intrusive_multiset_this_type<Compare> = root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_SideType = ::std::os::raw::c_int;
        pub type intrusive_multiset_pointer<T> = *mut T;
        pub type intrusive_multiset_const_pointer<T> = *const T;
        pub type intrusive_multiset_reference<T> = *mut T;
        pub type intrusive_multiset_const_reference<T> = *const T;
        pub type intrusive_multiset_difference_type = usize;
        pub type intrusive_multiset_size_type = usize;
        pub type intrusive_multiset_KeyType = [u8; 0usize];
        pub type intrusive_multiset_KeyCompare<Compare> = Compare;
        pub type intrusive_multiset_value_type<T> = T;
        pub type intrusive_multiset_node_type<T> = T;
        pub type intrusive_multiset_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_node_type<T>;
        pub type intrusive_multiset_const_node_ptr_type<T> =
            *const root::AZStd::intrusive_multiset_node_type<T>;
        pub type intrusive_multiset_hook_node_type<T> = root::AZStd::intrusive_multiset_node<T>;
        pub type intrusive_multiset_hook_node_ptr_type<T> =
            *mut root::AZStd::intrusive_multiset_hook_node_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_const_iterator_impl<T> {
            pub m_node: root::AZStd::intrusive_multiset_node_ptr_type<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub const intrusive_multiset_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::intrusive_multiset_const_iterator_impl__bindgen_ty_1 = 0;
        pub type intrusive_multiset_const_iterator_impl__bindgen_ty_1 = i32;
        pub type intrusive_multiset_const_iterator_impl_this_type<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_const_iterator_impl_tree_type<Compare> =
            root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_const_iterator_impl_value_type<T> = T;
        pub type intrusive_multiset_const_iterator_impl_difference_type = isize;
        pub type intrusive_multiset_const_iterator_impl_pointer<T> = *const T;
        pub type intrusive_multiset_const_iterator_impl_reference<T> = *const T;
        pub type intrusive_multiset_const_iterator_impl_iterator_category =
            root::AZStd::bidirectional_iterator_tag;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_iterator_impl<T> {
            pub _base: root::AZStd::intrusive_multiset_const_iterator_impl<T>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type intrusive_multiset_iterator_impl_this_type<T> =
            root::AZStd::intrusive_multiset_iterator_impl<T>;
        pub type intrusive_multiset_iterator_impl_base_type<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_iterator_impl_value_type<T> = T;
        pub type intrusive_multiset_iterator_impl_pointer<T> = *mut T;
        pub type intrusive_multiset_iterator_impl_reference<T> = *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_multiset_reverse_iterator_impl {
            pub m_node: root::AZStd::intrusive_multiset_reverse_iterator_impl_pointer,
            pub m_headNode: *const root::AZStd::intrusive_multiset_reverse_iterator_impl_value_type,
        }
        pub type intrusive_multiset_reverse_iterator_impl_this_type =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        pub type intrusive_multiset_reverse_iterator_impl_tree_type<Compare> =
            root::AZStd::intrusive_multiset<Compare>;
        pub type intrusive_multiset_reverse_iterator_impl_value_type = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_difference_type =
            root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_pointer = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_reference = root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_iterator_category =
            root::AZStd::iterator_traits;
        pub type intrusive_multiset_reverse_iterator_impl_iterator_type<Iter> = Iter;
        pub type intrusive_multiset_iterator<T> = root::AZStd::intrusive_multiset_iterator_impl<T>;
        pub type intrusive_multiset_const_iterator<T> =
            root::AZStd::intrusive_multiset_const_iterator_impl<T>;
        pub type intrusive_multiset_reverse_iterator =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        pub type intrusive_multiset_const_reverse_iterator =
            root::AZStd::intrusive_multiset_reverse_iterator_impl;
        #[repr(C)]
        #[derive(Debug)]
        pub struct mutex {
            pub m_mutex: root::AZStd::native_mutex_data_type,
        }
        pub type mutex_native_handle_type = root::AZStd::native_mutex_handle_type;
        extern "C" {
            #[link_name = "\u{1}?lock@mutex@AZStd@@QEAAXXZ"]
            pub fn mutex_lock(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@mutex@AZStd@@QEAA_NXZ"]
            pub fn mutex_try_lock(this: *mut root::AZStd::mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@mutex@AZStd@@QEAAXXZ"]
            pub fn mutex_unlock(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@mutex@AZStd@@QEAAPEAU_RTL_CRITICAL_SECTION@@XZ"]
            pub fn mutex_native_handle(
                this: *mut root::AZStd::mutex,
            ) -> root::AZStd::mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0mutex@AZStd@@QEAA@XZ"]
            pub fn mutex_mutex(this: *mut root::AZStd::mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0mutex@AZStd@@QEAA@PEBD@Z"]
            pub fn mutex_mutex1(this: *mut root::AZStd::mutex, name: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}??_Dmutex@AZStd@@QEAAXXZ"]
            pub fn mutex_mutex_destructor(this: *mut root::AZStd::mutex);
        }
        impl mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(&mut self) -> root::AZStd::mutex_native_handle_type {
                mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                mutex_mutex(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                mutex_mutex1(__bindgen_tmp.as_mut_ptr(), name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                mutex_mutex_destructor(self)
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct recursive_mutex {
            pub m_mutex: root::AZStd::native_recursive_mutex_data_type,
        }
        pub type recursive_mutex_native_handle_type =
            root::AZStd::native_recursive_mutex_handle_type;
        extern "C" {
            #[link_name = "\u{1}?lock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_lock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?try_lock@recursive_mutex@AZStd@@QEAA_NXZ"]
            pub fn recursive_mutex_try_lock(this: *mut root::AZStd::recursive_mutex) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?unlock@recursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_unlock(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}?native_handle@recursive_mutex@AZStd@@QEAAPEAU_RTL_CRITICAL_SECTION@@XZ"]
            pub fn recursive_mutex_native_handle(
                this: *mut root::AZStd::recursive_mutex,
            ) -> root::AZStd::recursive_mutex_native_handle_type;
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@XZ"]
            pub fn recursive_mutex_recursive_mutex(this: *mut root::AZStd::recursive_mutex);
        }
        extern "C" {
            #[link_name = "\u{1}??0recursive_mutex@AZStd@@QEAA@PEBD@Z"]
            pub fn recursive_mutex_recursive_mutex1(
                this: *mut root::AZStd::recursive_mutex,
                name: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??_Drecursive_mutex@AZStd@@QEAAXXZ"]
            pub fn recursive_mutex_recursive_mutex_destructor(
                this: *mut root::AZStd::recursive_mutex,
            );
        }
        impl recursive_mutex {
            #[inline]
            pub unsafe fn lock(&mut self) {
                recursive_mutex_lock(self)
            }
            #[inline]
            pub unsafe fn try_lock(&mut self) -> bool {
                recursive_mutex_try_lock(self)
            }
            #[inline]
            pub unsafe fn unlock(&mut self) {
                recursive_mutex_unlock(self)
            }
            #[inline]
            pub unsafe fn native_handle(
                &mut self,
            ) -> root::AZStd::recursive_mutex_native_handle_type {
                recursive_mutex_native_handle(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                recursive_mutex_recursive_mutex(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(name: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                recursive_mutex_recursive_mutex1(__bindgen_tmp.as_mut_ptr(), name);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                recursive_mutex_recursive_mutex_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeTicksPerSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeTicksPerSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowTicks@AZStd@@YA_JXZ"]
            pub fn GetTimeNowTicks() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowMicroSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeNowMicroSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeNowSecond@AZStd@@YA_JXZ"]
            pub fn GetTimeNowSecond() -> root::AZStd::sys_time_t;
        }
        extern "C" {
            #[link_name = "\u{1}?GetTimeUTCMilliSecond@AZStd@@YA_KXZ"]
            pub fn GetTimeUTCMilliSecond() -> root::AZ::u64;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct exponential_backoff {
            pub m_count: ::std::os::raw::c_int,
        }
        pub const exponential_backoff_MAX_PAUSE_LOOPS: ::std::os::raw::c_int = 32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct spin_mutex {
            pub m_flag: root::std::atomic,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_virtual_destructor {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct nullopt_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct nullopt_t_UniqueTag {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct optional {
            pub _address: u8,
        }
        pub type optional_base = u8;
        pub type optional_value_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_value_type {
            pub _address: u8,
        }
        pub type get_value_type_type = u8;
        pub type get_pointer_type_type<ValueType> = *mut ValueType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_pointer_type {
            pub _address: u8,
        }
        pub type get_const_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_void_pointer_type {
            pub _address: u8,
        }
        pub type get_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_const_void_pointer_type {
            pub _address: u8,
        }
        pub type get_const_void_pointer_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_difference_type {
            pub _address: u8,
        }
        pub type get_difference_type_type = root::std::pointer_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_size_type {
            pub _address: u8,
        }
        pub type get_size_type_type = root::std::make_unsigned;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_copy_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_copy_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_move_assignment_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_move_assignment_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_propagate_on_container_swap_type {
            pub _address: u8,
        }
        pub type get_propagate_on_container_swap_type_type = root::std::false_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct get_is_always_equal_type {
            pub _address: u8,
        }
        pub type get_is_always_equal_type_type = root::std::is_empty;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct has_rebind {
            pub _base: root::std::false_type,
        }
        pub type get_rebind_type_type<Allocator> = Allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<Alloc> = Alloc;
        pub type allocator_traits_value_type = root::AZStd::get_value_type;
        pub type allocator_traits_pointer = u8;
        pub type allocator_traits_const_pointer = root::AZStd::get_const_pointer_type;
        pub type allocator_traits_void_pointer = root::AZStd::get_void_pointer_type;
        pub type allocator_traits_const_void_pointer = root::AZStd::get_const_void_pointer_type;
        pub type allocator_traits_difference_type = root::AZStd::get_difference_type;
        pub type allocator_traits_size_type = root::AZStd::get_size_type;
        pub type allocator_traits_propagate_on_container_move_assignment =
            root::AZStd::get_propagate_on_container_move_assignment_type;
        pub type allocator_traits_propagate_on_container_copy_assignment =
            root::AZStd::get_propagate_on_container_copy_assignment_type;
        pub type allocator_traits_propagate_on_container_swap =
            root::AZStd::get_propagate_on_container_swap_type;
        pub type allocator_traits_is_always_equal = root::AZStd::get_is_always_equal_type;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set_node_traits {
            pub _address: u8,
        }
        pub type set_node_traits_value_type<ValueType> = ValueType;
        pub type set_node_traits_allocator_type<AllocatorType> = AllocatorType;
        pub type set_node_traits_node_type<NodeType> = NodeType;
        pub type set_node_traits_node_deleter_type<NodeDeleterType> = NodeDeleterType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_node_traits {
            pub _address: u8,
        }
        pub type map_node_traits_key_type<KeyType> = KeyType;
        pub type map_node_traits_mapped_type<MappedType> = MappedType;
        pub type map_node_traits_allocator_type<AllocatorType> = AllocatorType;
        pub type map_node_traits_node_type<NodeType> = NodeType;
        pub type map_node_traits_node_deleter_type<NodeDeleterType> = NodeDeleterType;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct insert_return_type<Iterator, NodeType> {
            pub position: Iterator,
            pub inserted: bool,
            pub node: NodeType,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<NodeType>>,
        }
        #[repr(C)]
        pub struct node_handle {
            pub m_node: root::AZStd::node_handle_node_pointer_type,
            pub m_allocator: root::AZStd::optional,
        }
        pub type node_handle_allocator_type = [u8; 0usize];
        pub type node_handle_allocator_traits = root::AZStd::allocator_traits;
        pub type node_handle_node_pointer_type = *mut [u8; 0usize];
        pub type node_handle_node_allocator_type = [u8; 0usize];
        pub type node_handle_node_deleter_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct set_node_base {
            pub _address: u8,
        }
        pub type set_node_base_value_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_node_base {
            pub _address: u8,
        }
        pub type map_node_base_key_type = [u8; 0usize];
        pub type map_node_base_mapped_type = [u8; 0usize];
        pub type set_node_handle = root::AZStd::node_handle;
        pub type map_node_handle = root::AZStd::node_handle;
        pub const fixed_vector_CONTAINER_VERSION: root::AZStd::fixed_vector__bindgen_ty_1 = 0;
        pub type fixed_vector__bindgen_ty_1 = i32;
        pub type fixed_vector_this_type = u8;
        pub type fixed_vector_pointer<T> = *mut T;
        pub type fixed_vector_const_pointer<T> = *const T;
        pub type fixed_vector_reference<T> = *mut T;
        pub type fixed_vector_const_reference<T> = *const T;
        pub type fixed_vector_difference_type = isize;
        pub type fixed_vector_size_type = usize;
        pub type fixed_vector_iterator<T> = root::AZStd::fixed_vector_pointer<T>;
        pub type fixed_vector_const_iterator<T> = root::AZStd::fixed_vector_const_pointer<T>;
        pub type fixed_vector_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::fixed_vector_iterator<T>>;
        pub type fixed_vector_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::fixed_vector_const_iterator<T>>;
        pub type fixed_vector_value_type<T> = T;
        pub type fixed_vector_node_type<T> = root::AZStd::fixed_vector_value_type<T>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_const_iterator {
            pub m_node: root::AZStd::list_const_iterator_base_node_ptr_type,
        }
        pub const list_const_iterator_ITERATOR_VERSION:
            root::AZStd::list_const_iterator__bindgen_ty_1 = 0;
        pub type list_const_iterator__bindgen_ty_1 = i32;
        pub type list_const_iterator_this_type = root::AZStd::list_const_iterator;
        pub type list_const_iterator_value_type<T> = T;
        pub type list_const_iterator_difference_type = isize;
        pub type list_const_iterator_pointer<T> = *const T;
        pub type list_const_iterator_reference<T> = *const T;
        pub type list_const_iterator_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type list_const_iterator_node_type = u8;
        pub type list_const_iterator_node_ptr_type =
            *mut root::AZStd::list_const_iterator_node_type;
        pub type list_const_iterator_base_node_type = root::AZStd::Internal::list_node_base;
        pub type list_const_iterator_base_node_ptr_type =
            *mut root::AZStd::list_const_iterator_base_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_iterator {
            pub _base: root::AZStd::list_const_iterator,
        }
        pub type list_iterator_this_type = root::AZStd::list_iterator;
        pub type list_iterator_base_type = root::AZStd::list_const_iterator;
        pub type list_iterator_pointer<T> = *mut T;
        pub type list_iterator_reference<T> = *mut T;
        pub type list_iterator_node_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_node_ptr_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_base_node_type = root::AZStd::list_iterator_base_type;
        pub type list_iterator_base_node_ptr_type = root::AZStd::list_iterator_base_type;
        #[repr(C)]
        pub struct list<Allocator> {
            pub m_head: root::AZStd::list_base_node_type,
            pub m_numElements: root::AZStd::list_size_type,
            pub m_allocator: root::AZStd::list_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub const list_CONTAINER_VERSION: root::AZStd::list__bindgen_ty_1 = 0;
        pub type list__bindgen_ty_1 = i32;
        pub type list_this_type<Allocator> = root::AZStd::list<Allocator>;
        pub type list_pointer<T> = *mut T;
        pub type list_const_pointer<T> = *const T;
        pub type list_reference<T> = *mut T;
        pub type list_const_reference<T> = *const T;
        pub type list_difference_type = [u8; 0usize];
        pub type list_size_type = [u8; 0usize];
        pub type list_allocator_type<Allocator> = Allocator;
        pub type list_value_type<T> = T;
        pub type list_node_type = u8;
        pub type list_node_ptr_type = *mut root::AZStd::list_node_type;
        pub type list_base_node_type = root::AZStd::Internal::list_node_base;
        pub type list_base_node_ptr_type = *mut root::AZStd::list_base_node_type;
        pub type list_const_iterator_impl = root::AZStd::list_const_iterator;
        pub type list_iterator_impl = root::AZStd::list_iterator;
        pub type list_reverse_iterator = root::AZStd::reverse_iterator<root::AZStd::list_iterator>;
        pub type list_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::list_const_iterator>;
        pub type static_buffer_allocator_this_type = u8;
        pub type static_buffer_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type static_buffer_allocator_size_type = usize;
        pub type static_buffer_allocator_difference_type = isize;
        pub type static_buffer_allocator_allow_memory_leaks = root::std::true_type;
        pub type static_pool_allocator_this_type = u8;
        pub type static_pool_allocator_index_type = i32;
        #[repr(C)]
        pub union static_pool_allocator_pool_node {
            pub m_node: u8,
            pub m_index: root::AZStd::static_pool_allocator_index_type,
            _bindgen_union_align: u32,
        }
        pub type static_pool_allocator_pointer_type = *mut ::std::os::raw::c_void;
        pub type static_pool_allocator_size_type = usize;
        pub type static_pool_allocator_difference_type = isize;
        pub type static_pool_allocator_allow_memory_leaks = root::std::false_type;
        pub const fixed_list_CONTAINER_VERSION: root::AZStd::fixed_list__bindgen_ty_1 = 0;
        pub type fixed_list__bindgen_ty_1 = i32;
        pub type fixed_list_this_type = u8;
        pub type fixed_list_base_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_ref<Allocator> {
            pub m_name: *const ::std::os::raw::c_char,
            pub m_allocator: root::AZStd::allocator_ref_allocator_pointer<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type allocator_ref_this_type<Allocator> = root::AZStd::allocator_ref<Allocator>;
        pub type allocator_ref_pointer_type = [u8; 0usize];
        pub type allocator_ref_size_type = [u8; 0usize];
        pub type allocator_ref_difference_type = [u8; 0usize];
        pub type allocator_ref_allow_memory_leaks = [u8; 0usize];
        pub type allocator_ref_allocator_pointer<Allocator> = *mut Allocator;
        pub type allocator_ref_allocator_reference<Allocator> = *mut Allocator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_node_destructor {
            pub m_allocator: *mut root::AZStd::hash_node_destructor_allocator_type,
        }
        pub type hash_node_destructor_allocator_type = root::AZStd::allocator_traits;
        pub type hash_node_destructor_allocator_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table {
            pub _address: u8,
        }
        pub type hash_table_this_type = u8;
        pub type hash_table_is_dynamic = u8;
        pub type hash_table_storage_type = u8;
        pub type hash_table_traits_type = u8;
        pub type hash_table_key_type = u8;
        pub type hash_table_key_eq = u8;
        pub type hash_table_hasher = u8;
        pub type hash_table_allocator_type = u8;
        pub type hash_table_list_type = u8;
        pub type hash_table_size_type = u8;
        pub type hash_table_difference_type = u8;
        pub type hash_table_pointer = u8;
        pub type hash_table_const_pointer = u8;
        pub type hash_table_reference = u8;
        pub type hash_table_const_reference = u8;
        pub type hash_table_iterator = u8;
        pub type hash_table_const_iterator = u8;
        pub type hash_table_reverse_iterator = u8;
        pub type hash_table_const_reverse_iterator = u8;
        pub type hash_table_value_type = u8;
        pub type hash_table_local_iterator = u8;
        pub type hash_table_const_local_iterator = u8;
        pub type hash_table_vector_value_type = u8;
        pub type hash_table_vector_type = u8;
        pub type hash_table_pair_iter_bool = u8;
        pub type hash_table_pair_iter_iter = u8;
        pub type hash_table_pair_citer_citer = u8;
        pub type hash_table_list_node_type = u8;
        pub type hash_table_vector_node_type = u8;
        pub type hash_table_node_deleter = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct hash_table_ConvertFromValue {
            pub _address: u8,
        }
        pub type hash_table_ConvertFromValue_key_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_const_iterator {
            pub m_node: root::AZStd::rbtree_const_iterator_node_ptr_type,
        }
        pub const rbtree_const_iterator_ITERATOR_VERSION:
            root::AZStd::rbtree_const_iterator__bindgen_ty_1 = 0;
        pub type rbtree_const_iterator__bindgen_ty_1 = i32;
        pub type rbtree_const_iterator_this_type = root::AZStd::rbtree_const_iterator;
        pub type rbtree_const_iterator_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type rbtree_const_iterator_difference_type = isize;
        pub type rbtree_const_iterator_value_type<T> = T;
        pub type rbtree_const_iterator_pointer<T> = *const T;
        pub type rbtree_const_iterator_reference<T> = *const T;
        pub type rbtree_const_iterator_base_node_ptr_type =
            *mut root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_iterator_const_base_node_ptr_type =
            *const root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_iterator_node_type = u8;
        pub type rbtree_const_iterator_node_ptr_type =
            *mut root::AZStd::rbtree_const_iterator_node_type;
        pub type rbtree_const_iterator_const_node_ptr_type =
            *const root::AZStd::rbtree_const_iterator_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_iterator {
            pub _base: root::AZStd::rbtree_const_iterator,
        }
        pub type rbtree_iterator_this_type = root::AZStd::rbtree_iterator;
        pub type rbtree_iterator_base_type = root::AZStd::rbtree_const_iterator;
        pub type rbtree_iterator_pointer<T> = *mut T;
        pub type rbtree_iterator_reference<T> = *mut T;
        pub type rbtree_iterator_base_node_ptr_type = root::AZStd::rbtree_iterator_base_type;
        pub type rbtree_iterator_node_ptr_type = root::AZStd::rbtree_iterator_base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct rbtree_node_destructor {
            pub m_allocator: *mut root::AZStd::rbtree_node_destructor_allocator_type,
        }
        pub type rbtree_node_destructor_allocator_type = root::AZStd::allocator_traits;
        pub type rbtree_node_destructor_allocator_traits = root::AZStd::allocator_traits;
        #[repr(C)]
        pub struct rbtree {
            pub m_head: root::AZStd::Internal::rbtree_node_base,
            pub m_numElements: root::AZStd::rbtree_size_type,
            pub m_keyEq: root::AZStd::rbtree_key_eq,
            pub m_allocator: root::AZStd::rbtree_allocator_type,
        }
        pub type rbtree_this_type = root::AZStd::rbtree;
        pub type rbtree_base_node_ptr_type = *mut root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_const_base_node_ptr_type = *const root::AZStd::Internal::rbtree_node_base;
        pub type rbtree_traits_type<Traits> = Traits;
        pub type rbtree_key_type = [u8; 0usize];
        pub type rbtree_key_eq = [u8; 0usize];
        pub type rbtree_allocator_type = [u8; 0usize];
        pub type rbtree_size_type = [u8; 0usize];
        pub type rbtree_difference_type = [u8; 0usize];
        pub type rbtree_value_type = [u8; 0usize];
        pub type rbtree_pointer = *mut root::AZStd::rbtree_value_type;
        pub type rbtree_const_pointer = *const root::AZStd::rbtree_value_type;
        pub type rbtree_reference = *mut root::AZStd::rbtree_value_type;
        pub type rbtree_const_reference = *const root::AZStd::rbtree_value_type;
        pub type rbtree_iterator_category = root::AZStd::bidirectional_iterator_tag;
        pub type rbtree_node_type = u8;
        pub type rbtree_node_ptr_type = *mut root::AZStd::rbtree_node_type;
        pub type rbtree_const_node_ptr_type = *const root::AZStd::rbtree_node_type;
        pub type rbtree_const_iterator_impl = root::AZStd::rbtree_const_iterator;
        pub type rbtree_iterator_impl = root::AZStd::rbtree_iterator;
        pub type rbtree_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::rbtree_iterator>;
        pub type rbtree_const_reverse_iterator =
            root::AZStd::reverse_iterator<root::AZStd::rbtree_const_iterator>;
        pub type rbtree_node_deleter = root::AZStd::rbtree_node_destructor;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_node {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct list_base_hook {
            pub _address: u8,
        }
        pub type list_base_hook_pointer<T> = *mut T;
        pub type list_base_hook_const_pointer<T> = *const T;
        pub type list_base_hook_node_type = u8;
        pub type list_base_hook_node_ptr_type = *mut root::AZStd::list_base_hook_node_type;
        pub type list_base_hook_const_node_ptr_type = *const root::AZStd::list_base_hook_node_type;
        pub type list_member_hook_pointer<T> = *mut T;
        pub type list_member_hook_const_pointer<T> = *const T;
        pub type list_member_hook_node_type = u8;
        pub type list_member_hook_node_ptr_type = *mut root::AZStd::list_member_hook_node_type;
        pub type list_member_hook_const_node_ptr_type =
            *const root::AZStd::list_member_hook_node_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list {
            pub _address: u8,
        }
        pub const intrusive_list_CONTAINER_VERSION: root::AZStd::intrusive_list__bindgen_ty_1 = 0;
        pub type intrusive_list__bindgen_ty_1 = i32;
        pub type intrusive_list_this_type = u8;
        pub type intrusive_list_pointer = u8;
        pub type intrusive_list_const_pointer = u8;
        pub type intrusive_list_reference = u8;
        pub type intrusive_list_const_reference = u8;
        pub type intrusive_list_difference_type = u64;
        pub type intrusive_list_size_type = u64;
        pub type intrusive_list_value_type = u8;
        pub type intrusive_list_node_type = u8;
        pub type intrusive_list_node_ptr_type = u8;
        pub type intrusive_list_const_node_ptr_type = u8;
        pub type intrusive_list_hook_node_type = u8;
        pub type intrusive_list_hook_node_ptr_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_const_iterator_impl {
            pub _address: u8,
        }
        pub const intrusive_list_const_iterator_impl_ITERATOR_VERSION:
            root::AZStd::intrusive_list_const_iterator_impl__bindgen_ty_1 = 0;
        pub type intrusive_list_const_iterator_impl__bindgen_ty_1 = i32;
        pub type intrusive_list_const_iterator_impl_this_type = u8;
        pub type intrusive_list_const_iterator_impl_value_type = u8;
        pub type intrusive_list_const_iterator_impl_difference_type = u64;
        pub type intrusive_list_const_iterator_impl_pointer = u8;
        pub type intrusive_list_const_iterator_impl_reference = u8;
        pub type intrusive_list_const_iterator_impl_iterator_category = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_iterator_impl {
            pub _address: u8,
        }
        pub type intrusive_list_iterator_impl_this_type = u8;
        pub type intrusive_list_iterator_impl_base_type = u8;
        pub type intrusive_list_iterator_impl_pointer = u8;
        pub type intrusive_list_iterator_impl_reference = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct intrusive_list_reverse_iterator_impl {
            pub _address: u8,
        }
        pub type intrusive_list_reverse_iterator_impl_this_type = u8;
        pub type intrusive_list_reverse_iterator_impl_value_type = u8;
        pub type intrusive_list_reverse_iterator_impl_difference_type = u8;
        pub type intrusive_list_reverse_iterator_impl_pointer = u8;
        pub type intrusive_list_reverse_iterator_impl_reference = u8;
        pub type intrusive_list_reverse_iterator_impl_iterator_category = u8;
        pub type intrusive_list_reverse_iterator_impl_iterator_type = u8;
        pub type intrusive_list_iterator = u8;
        pub type intrusive_list_const_iterator = u8;
        pub type intrusive_list_reverse_iterator = u8;
        pub type intrusive_list_const_reverse_iterator = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_map {
            pub _address: u8,
        }
        pub const unordered_map_CONTAINER_VERSION: root::AZStd::unordered_map__bindgen_ty_1 = 0;
        pub type unordered_map__bindgen_ty_1 = i32;
        pub type unordered_map_this_type = root::AZStd::unordered_map;
        pub type unordered_map_base_type = u8;
        pub type unordered_map_traits_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_key_eq = root::AZStd::unordered_map_base_type;
        pub type unordered_map_hasher = root::AZStd::unordered_map_base_type;
        pub type unordered_map_mapped_type<MappedType> = MappedType;
        pub type unordered_map_allocator_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_size_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_difference_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_pointer = root::AZStd::unordered_map_base_type;
        pub type unordered_map_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_reference = root::AZStd::unordered_map_base_type;
        pub type unordered_map_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_value_type = root::AZStd::unordered_map_base_type;
        pub type unordered_map_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_const_local_iterator = root::AZStd::unordered_map_base_type;
        pub type unordered_map_pair_iter_bool = root::AZStd::unordered_map_base_type;
        pub type unordered_map_node_type = root::AZStd::map_node_handle;
        pub type unordered_map_insert_return_type = root::AZStd::insert_return_type<
            root::AZStd::unordered_map_iterator,
            root::AZStd::unordered_map_node_type,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_multimap {
            pub _address: u8,
        }
        pub const unordered_multimap_CONTAINER_VERSION:
            root::AZStd::unordered_multimap__bindgen_ty_1 = 0;
        pub type unordered_multimap__bindgen_ty_1 = i32;
        pub type unordered_multimap_this_type = root::AZStd::unordered_multimap;
        pub type unordered_multimap_base_type = u8;
        pub type unordered_multimap_traits_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_key_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_key_eq = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_hasher = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_mapped_type<MappedType> = MappedType;
        pub type unordered_multimap_allocator_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_size_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_difference_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_pointer = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_pointer = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_reference = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_reference = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_value_type = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_local_iterator = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_const_local_iterator =
            root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_pair_iter_bool = root::AZStd::unordered_multimap_base_type;
        pub type unordered_multimap_node_type = root::AZStd::map_node_handle;
        pub type array_this_type = u8;
        pub type array_pointer<T> = *mut T;
        pub type array_const_pointer<T> = *const T;
        pub type array_reference<T> = *mut T;
        pub type array_const_reference<T> = *const T;
        pub type array_difference_type = isize;
        pub type array_size_type = usize;
        pub type array_iterator<T> = root::AZStd::array_pointer<T>;
        pub type array_const_iterator<T> = root::AZStd::array_const_pointer<T>;
        pub type array_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::array_iterator<T>>;
        pub type array_const_reverse_iterator<T> =
            root::AZStd::reverse_iterator<root::AZStd::array_const_iterator<T>>;
        pub type array_value_type<T> = T;
        pub type array_node_type<T> = root::AZStd::array_value_type<T>;
        pub const array_array_size: root::AZStd::array__bindgen_ty_1 = 0;
        pub type array__bindgen_ty_1 = i32;
        pub type tuple = root::std::tuple;
        pub type tuple_size = root::std::tuple_size;
        pub type tuple_element = u8;
        pub type tuple_element_t = u8;
        pub type ignore_t = root::std::_Ignore;
        #[repr(C)]
        #[derive(Debug)]
        pub struct scoped_lock {
            pub m_mutexes: root::AZStd::tuple,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct disjunction {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct function_traits {
            pub _address: u8,
        }
        pub type function_traits_get_result_t = root::AZStd::function_traits;
        pub type function_traits_get_arg_t = root::AZStd::function_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct remove_extent {
            pub _address: u8,
        }
        pub type remove_extent_type<T> = T;
        pub type unique_ptr = root::std::unique_ptr;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_set {
            pub _address: u8,
        }
        pub const unordered_set_CONTAINER_VERSION: root::AZStd::unordered_set__bindgen_ty_1 = 0;
        pub type unordered_set__bindgen_ty_1 = i32;
        pub type unordered_set_this_type = root::AZStd::unordered_set;
        pub type unordered_set_base_type = u8;
        pub type unordered_set_traits_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_key_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_key_eq = root::AZStd::unordered_set_base_type;
        pub type unordered_set_hasher = root::AZStd::unordered_set_base_type;
        pub type unordered_set_allocator_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_size_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_difference_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_pointer = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_pointer = root::AZStd::unordered_set_base_type;
        pub type unordered_set_reference = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_reference = root::AZStd::unordered_set_base_type;
        pub type unordered_set_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_value_type = root::AZStd::unordered_set_base_type;
        pub type unordered_set_local_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_const_local_iterator = root::AZStd::unordered_set_base_type;
        pub type unordered_set_node_type = root::AZStd::set_node_handle;
        pub type unordered_set_insert_return_type = root::AZStd::insert_return_type<
            root::AZStd::unordered_set_iterator,
            root::AZStd::unordered_set_node_type,
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unordered_multiset {
            pub _address: u8,
        }
        pub const unordered_multiset_CONTAINER_VERSION:
            root::AZStd::unordered_multiset__bindgen_ty_1 = 0;
        pub type unordered_multiset__bindgen_ty_1 = i32;
        pub type unordered_multiset_this_type = root::AZStd::unordered_multiset;
        pub type unordered_multiset_base_type = u8;
        pub type unordered_multiset_traits_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_key_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_key_eq = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_hasher = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_allocator_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_size_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_difference_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_pointer = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_pointer = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_reference = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_reference = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_value_type = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_local_iterator = root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_const_local_iterator =
            root::AZStd::unordered_multiset_base_type;
        pub type unordered_multiset_node_type = root::AZStd::set_node_handle;
        #[repr(C)]
        pub struct shared_mutex {
            pub m_value: root::std::atomic,
        }
        pub const shared_mutex_m_exclusiveLockBit: root::AZ::u32 = 2147483648;
        #[repr(C)]
        pub struct basic_string<Element, Allocator> {
            pub __bindgen_anon_1: root::AZStd::basic_string__bindgen_ty_3<Element>,
            pub m_size: root::AZStd::basic_string_size_type,
            pub m_capacity: root::AZStd::basic_string_size_type,
            pub m_allocator: root::AZStd::basic_string_allocator_type<Allocator>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type basic_string_this_type<Element, Allocator> =
            root::AZStd::basic_string<Element, Allocator>;
        pub type basic_string_pointer<Element> = *mut Element;
        pub type basic_string_const_pointer<Element> = *const Element;
        pub type basic_string_reference<Element> = *mut Element;
        pub type basic_string_const_reference<Element> = *const Element;
        pub type basic_string_difference_type = [u8; 0usize];
        pub type basic_string_size_type = [u8; 0usize];
        pub type basic_string_iterator_impl<Element> = root::AZStd::basic_string_pointer<Element>;
        pub type basic_string_const_iterator_impl<Element> =
            root::AZStd::basic_string_const_pointer<Element>;
        pub type basic_string_iterator<Element> = root::AZStd::basic_string_iterator_impl<Element>;
        pub type basic_string_const_iterator<Element> =
            root::AZStd::basic_string_const_iterator_impl<Element>;
        pub type basic_string_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_iterator<Element>>;
        pub type basic_string_const_reverse_iterator<Element> =
            root::AZStd::reverse_iterator<root::AZStd::basic_string_const_iterator<Element>>;
        pub type basic_string_value_type<Element> = Element;
        pub type basic_string_traits_type<Traits> = Traits;
        pub type basic_string_allocator_type<Allocator> = Allocator;
        pub type basic_string_node_type<Element> = root::AZStd::basic_string_value_type<Element>;
        pub const basic_string_SSO_BUF_SIZE: root::AZStd::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        pub const basic_string__ALLOC_MASK: root::AZStd::basic_string__bindgen_ty_2 = 0;
        pub type basic_string__bindgen_ty_2 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_3<Element> {
            pub m_buffer: *mut Element,
            pub m_data: root::AZStd::basic_string_pointer<Element>,
            _bindgen_union_align: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        pub type string = root::AZStd::basic_string<::std::os::raw::c_char, root::AZStd::allocator>;
        pub type wstring = root::AZStd::basic_string<u16, root::AZStd::allocator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct checked_deleter {
            pub _address: u8,
        }
        pub type checked_deleter_result_type = ::std::os::raw::c_void;
        pub type checked_deleter_argument_type<T> = *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct checked_array_deleter {
            pub _address: u8,
        }
        pub type checked_array_deleter_result_type = ::std::os::raw::c_void;
        pub type checked_array_deleter_argument_type<T> = *mut T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct enable_shared_from_this {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct enable_shared_from_this2 {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct shared_ptr<T> {
            pub px: *mut T,
            pub pn: root::AZStd::Internal::shared_count,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type shared_ptr_this_type<T> = root::AZStd::shared_ptr<T>;
        pub type shared_ptr_element_type<T> = T;
        pub type shared_ptr_value_type<T> = T;
        pub type shared_ptr_reference = u8;
        pub type shared_ptr_unspecified_bool_type<T> = *mut *mut T;
        #[repr(C)]
        #[derive(Debug)]
        pub struct weak_ptr<T> {
            pub px: *mut T,
            pub pn: root::AZStd::Internal::weak_count,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
        }
        pub type weak_ptr_this_type<T> = root::AZStd::weak_ptr<T>;
        pub type weak_ptr_element_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_function {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_function_pointer {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_object {
            pub _address: u8,
        }
        pub const MetaType_Meta_lpar: root::AZStd::MetaType = 40;
        pub const MetaType_Meta_rpar: root::AZStd::MetaType = 41;
        pub const MetaType_Meta_dlr: root::AZStd::MetaType = 36;
        pub const MetaType_Meta_caret: root::AZStd::MetaType = 94;
        pub const MetaType_Meta_dot: root::AZStd::MetaType = 46;
        pub const MetaType_Meta_star: root::AZStd::MetaType = 42;
        pub const MetaType_Meta_plus: root::AZStd::MetaType = 43;
        pub const MetaType_Meta_query: root::AZStd::MetaType = 63;
        pub const MetaType_Meta_lsq: root::AZStd::MetaType = 91;
        pub const MetaType_Meta_rsq: root::AZStd::MetaType = 93;
        pub const MetaType_Meta_bar: root::AZStd::MetaType = 124;
        pub const MetaType_Meta_esc: root::AZStd::MetaType = 92;
        pub const MetaType_Meta_dash: root::AZStd::MetaType = 45;
        pub const MetaType_Meta_lbr: root::AZStd::MetaType = 123;
        pub const MetaType_Meta_rbr: root::AZStd::MetaType = 125;
        pub const MetaType_Meta_comma: root::AZStd::MetaType = 44;
        pub const MetaType_Meta_colon: root::AZStd::MetaType = 58;
        pub const MetaType_Meta_equal: root::AZStd::MetaType = 61;
        pub const MetaType_Meta_exc: root::AZStd::MetaType = 33;
        pub const MetaType_Meta_eos: root::AZStd::MetaType = -1;
        pub const MetaType_Meta_nl: root::AZStd::MetaType = 10;
        pub const MetaType_Meta_cr: root::AZStd::MetaType = 13;
        pub const MetaType_Meta_bsp: root::AZStd::MetaType = 8;
        pub const MetaType_Meta_chr: root::AZStd::MetaType = 0;
        pub const MetaType_Esc_bsl: root::AZStd::MetaType = 92;
        pub const MetaType_Esc_word: root::AZStd::MetaType = 98;
        pub const MetaType_Esc_not_word: root::AZStd::MetaType = 66;
        pub const MetaType_Esc_ctrl_a: root::AZStd::MetaType = 97;
        pub const MetaType_Esc_ctrl_b: root::AZStd::MetaType = 98;
        pub const MetaType_Esc_ctrl_f: root::AZStd::MetaType = 102;
        pub const MetaType_Esc_ctrl_n: root::AZStd::MetaType = 110;
        pub const MetaType_Esc_ctrl_r: root::AZStd::MetaType = 114;
        pub const MetaType_Esc_ctrl_t: root::AZStd::MetaType = 116;
        pub const MetaType_Esc_ctrl_v: root::AZStd::MetaType = 118;
        pub const MetaType_Esc_ctrl: root::AZStd::MetaType = 99;
        pub const MetaType_Esc_hex: root::AZStd::MetaType = 120;
        pub const MetaType_Esc_uni: root::AZStd::MetaType = 117;
        pub type MetaType = i32;
        pub mod regex_constants {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const syntax_option_type_ECMAScript:
                root::AZStd::regex_constants::syntax_option_type = 1;
            pub const syntax_option_type_basic: root::AZStd::regex_constants::syntax_option_type =
                2;
            pub const syntax_option_type_extended:
                root::AZStd::regex_constants::syntax_option_type = 4;
            pub const syntax_option_type_awk: root::AZStd::regex_constants::syntax_option_type = 8;
            pub const syntax_option_type_grep: root::AZStd::regex_constants::syntax_option_type =
                16;
            pub const syntax_option_type_egrep: root::AZStd::regex_constants::syntax_option_type =
                32;
            pub const syntax_option_type_gmask: root::AZStd::regex_constants::syntax_option_type =
                63;
            pub const syntax_option_type_icase: root::AZStd::regex_constants::syntax_option_type =
                256;
            pub const syntax_option_type_nosubs: root::AZStd::regex_constants::syntax_option_type =
                512;
            pub const syntax_option_type_optimize:
                root::AZStd::regex_constants::syntax_option_type = 1024;
            pub const syntax_option_type_collate: root::AZStd::regex_constants::syntax_option_type =
                2048;
            pub const syntax_option_type_invalid: root::AZStd::regex_constants::syntax_option_type =
                0;
            pub type syntax_option_type = i32;
            pub const match_flag_type_match_default: root::AZStd::regex_constants::match_flag_type =
                0;
            pub const match_flag_type_match_not_bol: root::AZStd::regex_constants::match_flag_type =
                1;
            pub const match_flag_type_match_not_eol: root::AZStd::regex_constants::match_flag_type =
                2;
            pub const match_flag_type_match_not_bow: root::AZStd::regex_constants::match_flag_type =
                4;
            pub const match_flag_type_match_not_eow: root::AZStd::regex_constants::match_flag_type =
                8;
            pub const match_flag_type_match_any: root::AZStd::regex_constants::match_flag_type = 16;
            pub const match_flag_type_match_not_null:
                root::AZStd::regex_constants::match_flag_type = 32;
            pub const match_flag_type_match_continuous:
                root::AZStd::regex_constants::match_flag_type = 64;
            pub const match_flag_type_match_partial: root::AZStd::regex_constants::match_flag_type =
                128;
            pub const match_flag_type_match_prev_avail:
                root::AZStd::regex_constants::match_flag_type = 256;
            pub const match_flag_type_format_default:
                root::AZStd::regex_constants::match_flag_type = 0;
            pub const match_flag_type_format_sed: root::AZStd::regex_constants::match_flag_type =
                1024;
            pub const match_flag_type_format_no_copy:
                root::AZStd::regex_constants::match_flag_type = 2048;
            pub const match_flag_type_format_first_only:
                root::AZStd::regex_constants::match_flag_type = 4096;
            pub const match_flag_type_match_not_null1:
                root::AZStd::regex_constants::match_flag_type = 8192;
            pub type match_flag_type = i32;
            pub const error_type_error_collate: root::AZStd::regex_constants::error_type = 0;
            pub const error_type_error_ctype: root::AZStd::regex_constants::error_type = 1;
            pub const error_type_error_escape: root::AZStd::regex_constants::error_type = 2;
            pub const error_type_error_backref: root::AZStd::regex_constants::error_type = 3;
            pub const error_type_error_brack: root::AZStd::regex_constants::error_type = 4;
            pub const error_type_error_paren: root::AZStd::regex_constants::error_type = 5;
            pub const error_type_error_brace: root::AZStd::regex_constants::error_type = 6;
            pub const error_type_error_badbrace: root::AZStd::regex_constants::error_type = 7;
            pub const error_type_error_range: root::AZStd::regex_constants::error_type = 8;
            pub const error_type_error_space: root::AZStd::regex_constants::error_type = 9;
            pub const error_type_error_badrepeat: root::AZStd::regex_constants::error_type = 10;
            pub const error_type_error_complexity: root::AZStd::regex_constants::error_type = 11;
            pub const error_type_error_stack: root::AZStd::regex_constants::error_type = 12;
            pub const error_type_error_parse: root::AZStd::regex_constants::error_type = 13;
            pub const error_type_error_syntax: root::AZStd::regex_constants::error_type = 14;
            pub type error_type = i32;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct regex_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CmpCS {
            pub _address: u8,
        }
        pub type CmpCS_Element = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CmpIcase<RegExTraits> {
            pub m_traits: *const RegExTraits,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
        }
        pub type CmpIcase_Element = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct CmpCollate<RegExTraits> {
            pub m_traits: *const RegExTraits,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
        }
        pub type CmpCollate_Element = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegexTraitsBase {
            pub _address: u8,
        }
        pub const RegexTraitsBase_CharClassType_Ch_none:
            root::AZStd::RegexTraitsBase_CharClassType = 0;
        pub const RegexTraitsBase_CharClassType_Ch_invalid:
            root::AZStd::RegexTraitsBase_CharClassType = 65535;
        pub const RegexTraitsBase_CharClassType_Ch_alnum:
            root::AZStd::RegexTraitsBase_CharClassType = 1;
        pub const RegexTraitsBase_CharClassType_Ch_alpha:
            root::AZStd::RegexTraitsBase_CharClassType = 2;
        pub const RegexTraitsBase_CharClassType_Ch_cntrl:
            root::AZStd::RegexTraitsBase_CharClassType = 4;
        pub const RegexTraitsBase_CharClassType_Ch_digit:
            root::AZStd::RegexTraitsBase_CharClassType = 8;
        pub const RegexTraitsBase_CharClassType_Ch_graph:
            root::AZStd::RegexTraitsBase_CharClassType = 16;
        pub const RegexTraitsBase_CharClassType_Ch_lower:
            root::AZStd::RegexTraitsBase_CharClassType = 32;
        pub const RegexTraitsBase_CharClassType_Ch_print:
            root::AZStd::RegexTraitsBase_CharClassType = 64;
        pub const RegexTraitsBase_CharClassType_Ch_punct:
            root::AZStd::RegexTraitsBase_CharClassType = 128;
        pub const RegexTraitsBase_CharClassType_Ch_space:
            root::AZStd::RegexTraitsBase_CharClassType = 256;
        pub const RegexTraitsBase_CharClassType_Ch_upper:
            root::AZStd::RegexTraitsBase_CharClassType = 512;
        pub const RegexTraitsBase_CharClassType_Ch_xdigit:
            root::AZStd::RegexTraitsBase_CharClassType = 1024;
        pub type RegexTraitsBase_CharClassType = i32;
        pub type RegexTraitsBase_char_class_type = ::std::os::raw::c_short;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ClassNames<Element> {
            pub m_element: *const Element,
            pub m_length: ::std::os::raw::c_uint,
            pub m_type: ::std::os::raw::c_int,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegexTraits {
            pub _address: u8,
        }
        pub type RegexTraits_this_type = root::AZStd::RegexTraits;
        pub type RegexTraits_char_type<Element> = Element;
        pub type RegexTraits_size_type = usize;
        pub type RegexTraits_string_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct sub_match<BidirectionalIterator> {
            pub _base: root::AZStd::pair<BidirectionalIterator, BidirectionalIterator>,
            pub matched: bool,
            pub _phantom_0:
                ::std::marker::PhantomData<::std::cell::UnsafeCell<BidirectionalIterator>>,
        }
        pub type sub_match_value_type = root::AZStd::iterator_traits;
        pub type sub_match_difference_type = root::AZStd::iterator_traits;
        pub type sub_match_iterator<BidirectionalIterator> = BidirectionalIterator;
        pub type sub_match_string_type = u8;
        pub type csub_match = root::AZStd::sub_match<*const ::std::os::raw::c_char>;
        pub type wcsub_match = root::AZStd::sub_match<*const u16>;
        pub type ssub_match = root::AZStd::sub_match<root::const_iterator>;
        pub type wssub_match = root::AZStd::sub_match<root::const_iterator>;
        #[repr(C)]
        #[derive(Debug)]
        pub struct match_results<BidirectionalIterator, Allocator> {
            pub m_original: BidirectionalIterator,
            pub m_isReady: bool,
            pub m_matches:
                root::AZStd::match_results_ContainerType<BidirectionalIterator, Allocator>,
            pub m_prefix: root::AZStd::match_results_Element<BidirectionalIterator>,
            pub m_suffix: root::AZStd::match_results_Element<BidirectionalIterator>,
            pub m_nullElement: root::AZStd::match_results_Element<BidirectionalIterator>,
            pub _phantom_0:
                ::std::marker::PhantomData<::std::cell::UnsafeCell<BidirectionalIterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Allocator>>,
        }
        pub type match_results_this_type<BidirectionalIterator, Allocator> =
            root::AZStd::match_results<BidirectionalIterator, Allocator>;
        pub type match_results_Element<BidirectionalIterator> =
            root::AZStd::sub_match<BidirectionalIterator>;
        pub type match_results_ContainerType<BidirectionalIterator, Allocator> =
            root::AZStd::vector<
                root::AZStd::match_results_Element<BidirectionalIterator>,
                Allocator,
            >;
        pub type match_results_value_type<BidirectionalIterator> =
            root::AZStd::match_results_Element<BidirectionalIterator>;
        pub type match_results_const_reference<BidirectionalIterator> =
            *const root::AZStd::match_results_value_type<BidirectionalIterator>;
        pub type match_results_reference<BidirectionalIterator> =
            root::AZStd::match_results_const_reference<BidirectionalIterator>;
        pub type match_results_const_iterator<BidirectionalIterator, Allocator> =
            root::AZStd::match_results_ContainerType<BidirectionalIterator, Allocator>;
        pub type match_results_iterator<BidirectionalIterator, Allocator> =
            root::AZStd::match_results_const_iterator<BidirectionalIterator, Allocator>;
        pub type match_results_difference_type = root::AZStd::iterator_traits;
        pub type match_results_size_type = [u8; 0usize];
        pub type match_results_allocator_type<Allocator> = Allocator;
        pub type match_results_char_type = root::AZStd::iterator_traits;
        pub type match_results_string_type = u8;
        pub const NodeFlags_NFLG_none: root::AZStd::NodeFlags = 0;
        pub const NodeFlags_NFLG_negate: root::AZStd::NodeFlags = 1;
        pub const NodeFlags_NFLG_greedy: root::AZStd::NodeFlags = 2;
        pub const NodeFlags_NFLG_final: root::AZStd::NodeFlags = 4;
        pub const NodeFlags_NFLG_longest: root::AZStd::NodeFlags = 8;
        pub type NodeFlags = i32;
        pub const NodeType_NT_none: root::AZStd::NodeType = 0;
        pub const NodeType_NT_nop: root::AZStd::NodeType = 1;
        pub const NodeType_NT_bol: root::AZStd::NodeType = 2;
        pub const NodeType_NT_eol: root::AZStd::NodeType = 3;
        pub const NodeType_NT_wbound: root::AZStd::NodeType = 4;
        pub const NodeType_NT_dot: root::AZStd::NodeType = 5;
        pub const NodeType_NT_str: root::AZStd::NodeType = 6;
        pub const NodeType_NT_class: root::AZStd::NodeType = 7;
        pub const NodeType_NT_group: root::AZStd::NodeType = 8;
        pub const NodeType_NT_end_group: root::AZStd::NodeType = 9;
        pub const NodeType_NT_assert: root::AZStd::NodeType = 10;
        pub const NodeType_NT_neg_assert: root::AZStd::NodeType = 11;
        pub const NodeType_NT_end_assert: root::AZStd::NodeType = 12;
        pub const NodeType_NT_capture: root::AZStd::NodeType = 13;
        pub const NodeType_NT_end_capture: root::AZStd::NodeType = 14;
        pub const NodeType_NT_back: root::AZStd::NodeType = 15;
        pub const NodeType_NT_if: root::AZStd::NodeType = 16;
        pub const NodeType_NT_endif: root::AZStd::NodeType = 17;
        pub const NodeType_NT_rep: root::AZStd::NodeType = 18;
        pub const NodeType_NT_end_rep: root::AZStd::NodeType = 19;
        pub const NodeType_NT_begin: root::AZStd::NodeType = 20;
        pub const NodeType_NT_end: root::AZStd::NodeType = 21;
        pub type NodeType = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct RegExBuffer<Element> {
            pub m_capacity: ::std::os::raw::c_uint,
            pub m_size: ::std::os::raw::c_uint,
            pub m_chars: *mut Element,
            pub m_allocator: root::AZStd::allocator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct RegExBitmap {
            pub m_chars: [::std::os::raw::c_uchar; 32usize],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RegExSequence<Element> {
            pub m_size: ::std::os::raw::c_uint,
            pub m_data: root::AZStd::RegExBuffer<Element>,
            pub m_next: *mut root::AZStd::RegExSequence<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        #[repr(C)]
        pub struct NodeBase__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeBase {
            pub vtable_: *const NodeBase__bindgen_vtable,
            pub m_kind: root::AZStd::NodeType,
            pub m_flags: root::AZStd::NodeFlags,
            pub m_next: *mut root::AZStd::NodeBase,
            pub m_previous: *mut root::AZStd::NodeBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct RootNode {
            pub _base: root::AZStd::NodeBase,
            pub flags: root::AZStd::regex_constants::syntax_option_type,
            pub m_loops: ::std::os::raw::c_uint,
            pub m_marks: ::std::os::raw::c_uint,
            pub m_refs: ::std::os::raw::c_uint,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeEndGroup {
            pub _base: root::AZStd::NodeBase,
            pub m_back: *mut root::AZStd::NodeBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeAssert {
            pub _base: root::AZStd::NodeBase,
            pub m_child: *mut root::AZStd::NodeBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeCapture {
            pub _base: root::AZStd::NodeBase,
            pub m_index: ::std::os::raw::c_uint,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeBack {
            pub _base: root::AZStd::NodeBase,
            pub m_index: ::std::os::raw::c_uint,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeString<Element> {
            pub _base: root::AZStd::NodeBase,
            pub m_data: root::AZStd::RegExBuffer<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        #[repr(C)]
        pub struct NodeClass<Element> {
            pub _base: root::AZStd::NodeBase,
            pub m_coll: *mut root::AZStd::RegExSequence<Element>,
            pub m_small: *mut root::AZStd::RegExBitmap,
            pub m_large: *mut root::AZStd::RegExBuffer<Element>,
            pub m_ranges: *mut root::AZStd::RegExBuffer<Element>,
            pub _Classes: [u8; 0usize],
            pub m_equiv: *mut root::AZStd::RegExSequence<Element>,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeEndif {
            pub _base: root::AZStd::NodeBase,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeIf {
            pub _base: root::AZStd::NodeBase,
            pub _Endif: *mut root::AZStd::NodeEndif,
            pub m_child: *mut root::AZStd::NodeIf,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct NodeEndRepetition {
            pub _base: root::AZStd::NodeBase,
            pub _Begin_rep: *mut root::AZStd::NodeRepetition,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct LoopValues {
            pub _Loop_idx: ::std::os::raw::c_int,
            pub _Loop_iter: *mut ::std::os::raw::c_void,
        }
        #[repr(C)]
        pub struct NodeRepetition {
            pub _base: root::AZStd::NodeBase,
            pub m_min: ::std::os::raw::c_int,
            pub m_max: ::std::os::raw::c_int,
            pub m_endRep: *mut root::AZStd::NodeEndRepetition,
            pub m_loopNumber: ::std::os::raw::c_uint,
            pub m_sampleLoop: ::std::os::raw::c_int,
        }
        #[repr(C)]
        pub struct Builder<RegExTraits> {
            pub m_root: *mut root::AZStd::RootNode,
            pub m_current: *mut root::AZStd::NodeBase,
            pub m_flags: root::AZStd::regex_constants::syntax_option_type,
            pub m_traits: *const RegExTraits,
            pub m_bitmapMax: ::std::os::raw::c_int,
            pub m_bitmapArrayMax: ::std::os::raw::c_int,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
        }
        pub type Builder_DiffType = root::AZStd::iterator_traits;
        #[repr(C)]
        #[derive(Debug)]
        pub struct BackTracingState<BidirectionalIterator> {
            pub m_current: BidirectionalIterator,
            pub m_groupValid: root::AZStd::vector<bool, root::AZStd::allocator>,
            pub _phantom_0:
                ::std::marker::PhantomData<::std::cell::UnsafeCell<BidirectionalIterator>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TgtState {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct TgtState_GroupType<BidirectionalIterator> {
            pub m_begin: BidirectionalIterator,
            pub m_end: BidirectionalIterator,
            pub _phantom_0:
                ::std::marker::PhantomData<::std::cell::UnsafeCell<BidirectionalIterator>>,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Matcher<RegExTraits, Iterator> {
            pub m_tgtState: u8,
            pub m_result: u8,
            pub m_loopVals: root::AZStd::vector<root::AZStd::LoopValues, root::AZStd::allocator>,
            pub m_begin: Iterator,
            pub m_end: Iterator,
            pub m_first: Iterator,
            pub m_rootNode: *mut root::AZStd::NodeBase,
            pub m_sflags: root::AZStd::regex_constants::syntax_option_type,
            pub m_mflags: root::AZStd::regex_constants::match_flag_type,
            pub m_isMatched: bool,
            pub _Cap: bool,
            pub _Ncap: ::std::os::raw::c_int,
            pub _Longest: bool,
            pub m_traits: *const RegExTraits,
            pub m_isFull: bool,
            pub _Max_complexity_count: ::std::os::raw::c_long,
            pub _Max_stack_count: ::std::os::raw::c_long,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Iterator>>,
        }
        pub const ParserClass__Prs_none: root::AZStd::ParserClass = 0;
        pub const ParserClass__Prs_chr: root::AZStd::ParserClass = 1;
        pub const ParserClass__Prs_set: root::AZStd::ParserClass = 2;
        pub type ParserClass = i32;
        #[repr(C)]
        pub struct Parser<ForwardIterator, Element, RegExTraits> {
            pub m_pat: ForwardIterator,
            pub m_begin: ForwardIterator,
            pub m_end: ForwardIterator,
            pub m_groupIndex: ::std::os::raw::c_int,
            pub m_disjointIndex: ::std::os::raw::c_int,
            pub m_finishedGroups: root::AZStd::vector<bool, root::AZStd::allocator>,
            pub m_builder: root::AZStd::Builder<RegExTraits>,
            pub m_traits: *const RegExTraits,
            pub m_flags: root::AZStd::regex_constants::syntax_option_type,
            pub m_value: ::std::os::raw::c_int,
            pub m_char: Element,
            pub m_metaChar: root::AZStd::MetaType,
            pub m_lflags: ::std::os::raw::c_uint,
            pub m_errors: *mut root::AZStd::Internal::ErrorSink,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<ForwardIterator>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<Element>>,
            pub _phantom_2: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
        }
        pub type Parser_char_class_type = [u8; 0usize];
        pub const LanguageFlags_LF_ext_rep: root::AZStd::LanguageFlags = 1;
        pub const LanguageFlags_LF_alt_pipe: root::AZStd::LanguageFlags = 2;
        pub const LanguageFlags_LF_alt_nl: root::AZStd::LanguageFlags = 4;
        pub const LanguageFlags_LF_nex_grp: root::AZStd::LanguageFlags = 8;
        pub const LanguageFlags_LF_nex_rep: root::AZStd::LanguageFlags = 16;
        pub const LanguageFlags_LF_nc_grp: root::AZStd::LanguageFlags = 32;
        pub const LanguageFlags_LF_asrt_gen: root::AZStd::LanguageFlags = 64;
        pub const LanguageFlags_LF_asrt_wrd: root::AZStd::LanguageFlags = 128;
        pub const LanguageFlags_LF_bckr: root::AZStd::LanguageFlags = 256;
        pub const LanguageFlags_LF_lim_bckr: root::AZStd::LanguageFlags = 512;
        pub const LanguageFlags_LF_ngr_rep: root::AZStd::LanguageFlags = 1024;
        pub const LanguageFlags_LF_esc_uni: root::AZStd::LanguageFlags = 2048;
        pub const LanguageFlags_LF_esc_hex: root::AZStd::LanguageFlags = 4096;
        pub const LanguageFlags_LF_esc_oct: root::AZStd::LanguageFlags = 8192;
        pub const LanguageFlags_LF_esc_bsl: root::AZStd::LanguageFlags = 16384;
        pub const LanguageFlags_LF_esc_ffnx: root::AZStd::LanguageFlags = 32768;
        pub const LanguageFlags_LF_esc_ffn: root::AZStd::LanguageFlags = 65536;
        pub const LanguageFlags_LF_esc_wsd: root::AZStd::LanguageFlags = 131072;
        pub const LanguageFlags_LF_esc_ctrl: root::AZStd::LanguageFlags = 262144;
        pub const LanguageFlags_LF_no_nl: root::AZStd::LanguageFlags = 524288;
        pub const LanguageFlags_LF_bzr_chr: root::AZStd::LanguageFlags = 1048576;
        pub const LanguageFlags_LF_grp_esc: root::AZStd::LanguageFlags = 2097152;
        pub const LanguageFlags_LF_ident_ECMA: root::AZStd::LanguageFlags = 4194304;
        pub const LanguageFlags_LF_ident_ERE: root::AZStd::LanguageFlags = 8388608;
        pub const LanguageFlags_LF_ident_awk: root::AZStd::LanguageFlags = 16777216;
        pub const LanguageFlags_LF_anch_rstr: root::AZStd::LanguageFlags = 33554432;
        pub const LanguageFlags_LF_star_beg: root::AZStd::LanguageFlags = 67108864;
        pub const LanguageFlags_LF_empty_grp: root::AZStd::LanguageFlags = 134217728;
        pub const LanguageFlags_LF_paren_bal: root::AZStd::LanguageFlags = 268435456;
        pub const LanguageFlags_LF_brk_rstr: root::AZStd::LanguageFlags = 536870912;
        pub const LanguageFlags_LF_mtch_long: root::AZStd::LanguageFlags = 1073741824;
        pub const LanguageFlags_LF_no_subs: root::AZStd::LanguageFlags = -2147483648;
        pub type LanguageFlags = i32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_regex<RegExTraits> {
            pub _base: root::AZStd::Internal::ErrorSink,
            pub m_rootNode: *mut root::AZStd::RootNode,
            pub m_traits: RegExTraits,
            pub m_error: *const ::std::os::raw::c_char,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<RegExTraits>>,
        }
        pub type basic_regex_this_type<RegExTraits> = root::AZStd::basic_regex<RegExTraits>;
        pub type basic_regex_value_type<Element> = Element;
        pub type basic_regex_traits_type<RegExTraits> = RegExTraits;
        pub type basic_regex_string_type = u8;
        pub use self::super::super::root::AZStd::regex_constants::syntax_option_type as basic_regex_flag_type;
        pub type regex = root::AZStd::basic_regex<root::AZStd::regex_traits>;
        pub type wregex = root::AZStd::basic_regex<root::AZStd::regex_traits>;
        pub type cmatch =
            root::AZStd::match_results<*const ::std::os::raw::c_char, root::AZStd::allocator>;
        pub type wcmatch = root::AZStd::match_results<*const u16, root::AZStd::allocator>;
        pub type smatch = root::AZStd::match_results<root::const_iterator, root::AZStd::allocator>;
        pub type wsmatch = root::AZStd::match_results<root::const_iterator, root::AZStd::allocator>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct regex_iterator {
            pub _address: u8,
        }
        pub type regex_iterator_this_type = u8;
        pub type regex_iterator_regex_type<RegExTraits> = root::AZStd::basic_regex<RegExTraits>;
        pub type regex_iterator_value_type = u8;
        pub type regex_iterator_difference_type = isize;
        pub type regex_iterator_pointer = *const root::AZStd::regex_iterator_value_type;
        pub type regex_iterator_reference = *const root::AZStd::regex_iterator_value_type;
        pub type regex_iterator_iterator_category = root::AZStd::forward_iterator_tag;
        #[repr(C)]
        #[derive(Debug)]
        pub struct regex_token_iterator<BidirectionalIterator> {
            pub m_position: root::AZStd::regex_token_iterator_PositionType,
            pub m_result:
                *const root::AZStd::regex_token_iterator_value_type<BidirectionalIterator>,
            pub m_suffix: root::AZStd::regex_token_iterator_value_type<BidirectionalIterator>,
            pub m_current: usize,
            pub m_subs: root::AZStd::vector<::std::os::raw::c_int, root::AZStd::allocator>,
            pub _phantom_0:
                ::std::marker::PhantomData<::std::cell::UnsafeCell<BidirectionalIterator>>,
        }
        pub type regex_token_iterator_PositionType = u8;
        pub type regex_token_iterator_this_type<BidirectionalIterator> =
            root::AZStd::regex_token_iterator<BidirectionalIterator>;
        pub type regex_token_iterator_regex_type<RegExTraits> =
            root::AZStd::basic_regex<RegExTraits>;
        pub type regex_token_iterator_value_type<BidirectionalIterator> =
            root::AZStd::sub_match<BidirectionalIterator>;
        pub type regex_token_iterator_difference_type = isize;
        pub type regex_token_iterator_pointer<BidirectionalIterator> =
            *const root::AZStd::regex_token_iterator_value_type<BidirectionalIterator>;
        pub type regex_token_iterator_reference<BidirectionalIterator> =
            *const root::AZStd::regex_token_iterator_value_type<BidirectionalIterator>;
        pub type regex_token_iterator_iterator_category = root::AZStd::forward_iterator_tag;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct negation {
            pub _address: u8,
        }
        pub type add_pointer_t = root::std::add_pointer_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct transfer_ownership_t {
            pub _address: u8,
        }
        #[repr(C)]
        #[repr(align(32))]
        pub struct any {
            pub __bindgen_anon_1: root::AZStd::any__bindgen_ty_1,
            pub m_typeInfo: root::AZStd::any_type_info,
            pub m_allocator: root::AZStd::allocator,
            pub __bindgen_padding_0: [u64; 3usize],
        }
        pub type any_type_id = root::AZ::Uuid;
        pub const any_Action_Reserve: root::AZStd::any_Action = 0;
        pub const any_Action_Copy: root::AZStd::any_Action = 1;
        pub const any_Action_Move: root::AZStd::any_Action = 2;
        pub const any_Action_Destroy: root::AZStd::any_Action = 3;
        pub type any_Action = i32;
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug, Copy, Clone)]
        pub struct any_type_info {
            pub m_id: root::AZStd::any_type_id,
            pub m_handler: root::AZStd::any_type_info_HandleFnT,
            pub m_isPointer: bool,
            pub m_useHeap: bool,
            pub __bindgen_padding_0: [u16; 3usize],
        }
        pub type any_type_info_HandleFnT = [u64; 5usize];
        #[repr(C)]
        #[repr(align(32))]
        #[derive(Copy, Clone)]
        pub union any__bindgen_ty_1 {
            pub m_buffer: [::std::os::raw::c_char; 32usize],
            pub m_pointer: *mut ::std::os::raw::c_void,
            _bindgen_union_align: [u8; 32usize],
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@any@AZStd@@QEAAXXZ"]
            pub fn any_TYPEINFO_Enable(this: *mut root::AZStd::any);
        }
        impl any {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                any_TYPEINFO_Enable(self)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct stack<Container> {
            pub m_container: Container,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Container>>,
        }
        pub const stack_CONTAINER_VERSION: root::AZStd::stack__bindgen_ty_1 = 0;
        pub type stack__bindgen_ty_1 = i32;
        pub type stack_this_type<Container> = root::AZStd::stack<Container>;
        pub type stack_container_type<Container> = Container;
        pub type stack_value_type = [u8; 0usize];
        pub type stack_size_type = [u8; 0usize];
        pub type stack_reference = [u8; 0usize];
        pub type stack_const_reference = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_cv {
            pub _address: u8,
        }
        pub type add_cv_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct add_volatile {
            pub _address: u8,
        }
        pub type add_volatile_type<T> = T;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct conjunction {
            pub _base: root::std::true_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct type_identity {
            pub _address: u8,
        }
        pub type type_identity_type<T> = T;
        pub type type_identity_t = root::AZStd::type_identity;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct variant_size {
            pub _address: u8,
        }
        pub type variant_alternative_t = u8;
        pub type variant_index_t = root::AZStd::conditional_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct find_exactly_one_variadic {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct find_exactly_one_alternative {
            pub _address: u8,
        }
        pub mod variant_detail {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct valueless_t {
                pub _address: u8,
            }
            pub const SpecialFunctionTraits_TriviallyAvailable:
                root::AZStd::variant_detail::SpecialFunctionTraits = 0;
            pub const SpecialFunctionTraits_Available:
                root::AZStd::variant_detail::SpecialFunctionTraits = 1;
            pub const SpecialFunctionTraits_Unavailable:
                root::AZStd::variant_detail::SpecialFunctionTraits = 2;
            pub type SpecialFunctionTraits = i32;
            pub mod get_alternative {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct union_ {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct impl_ {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct variant {
                    pub _address: u8,
                }
            }
            pub mod visitor {
                #[allow(unused_imports)]
                use self::super::super::super::super::root;
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct impl_ {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct variant {
                    pub _address: u8,
                }
                #[repr(C)]
                #[derive(Debug, Copy, Clone)]
                pub struct variant_value_visitor<Visitor> {
                    pub m_visitor: *mut Visitor,
                    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<Visitor>>,
                }
            }
            pub type alternative_impl_value_type<T> = T;
            #[repr(C)]
            #[derive(Copy, Clone)]
            pub struct variant_impl_base {
                pub m_union_data: u8,
                pub m_index: root::AZStd::variant_detail::variant_impl_base_index_t,
            }
            pub type variant_impl_base_index_t = root::AZStd::variant_index_t;
            pub type variant_impl_destructor_base_type =
                root::AZStd::variant_detail::variant_impl_base;
            #[repr(C)]
            #[derive(Debug)]
            pub struct variant_impl_constructor {
                pub _address: u8,
            }
            pub type variant_impl_constructor_base_type = u8;
            pub type variant_impl_move_constructor_base_type =
                root::AZStd::variant_detail::variant_impl_constructor;
            pub type variant_impl_copy_constructor_base_type = u8;
            #[repr(C)]
            #[derive(Debug)]
            pub struct variant_impl_assignment {
                pub _address: u8,
            }
            pub type variant_impl_assignment_base_type = u8;
            pub type variant_impl_move_assignment_base_type =
                root::AZStd::variant_detail::variant_impl_assignment;
            pub type variant_impl_copy_assignment_base_type = u8;
            #[repr(C)]
            #[derive(Debug)]
            pub struct impl_ {
                pub _address: u8,
            }
            pub type impl_base_type = u8;
            #[repr(C)]
            #[derive(Debug, Copy, Clone)]
            pub struct implicit_convertible_operators {
                pub _address: u8,
            }
            pub type best_alternative_t = root::AZStd::invoke_result_t;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_swappable_with_helper {
            pub _base: root::std::false_type,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_swappable_with {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct is_swappable {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct variant {
            pub m_impl: root::AZStd::variant_detail::impl_,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct monostate {
            pub _address: u8,
        }
        pub type has_hash_specialization = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct variant_hash_enabled_concept {
            pub _address: u8,
        }
        pub type bitset_this_type = u8;
        pub type bitset_word_t = ::std::os::raw::c_uint;
        pub type bitset_pointer = *mut root::AZStd::bitset_word_t;
        pub type bitset_const_pointer = *const root::AZStd::bitset_word_t;
        pub type bitset_size_type = usize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bitset_reference {
            pub m_bitSet: *mut u8,
            pub m_pos: usize,
        }
        pub const bitset_BitsPerWord: root::AZStd::bitset__bindgen_ty_1 = 0;
        pub const bitset_NumWords: root::AZStd::bitset__bindgen_ty_1 = 0;
        pub type bitset__bindgen_ty_1 = i32;
    }
    pub type HANDLE = *mut ::std::os::raw::c_void;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _RTL_CRITICAL_SECTION {
        _unused: [u8; 0],
    }
    pub type RTL_CRITICAL_SECTION = root::_RTL_CRITICAL_SECTION;
    pub type CRITICAL_SECTION = root::RTL_CRITICAL_SECTION;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _RTL_CONDITION_VARIABLE {
        _unused: [u8; 0],
    }
    pub type RTL_CONDITION_VARIABLE = root::_RTL_CONDITION_VARIABLE;
    pub type CONDITION_VARIABLE = root::RTL_CONDITION_VARIABLE;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _GUID {
        _unused: [u8; 0],
    }
    pub type GUID = root::_GUID;
    pub mod AzFramework {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct AssetCatalogEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetCatalogEvents {
            pub vtable_: *const AssetCatalogEvents__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetCatalogEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetCatalogEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type AssetCatalogEventBus = root::AZ::EBus;
        #[repr(C)]
        pub struct LegacyAssetEvents__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct LegacyAssetEvents {
            pub vtable_: *const LegacyAssetEvents__bindgen_vtable,
        }
        pub type LegacyAssetEvents_BusIdType = root::AZ::u32;
        pub const LegacyAssetEvents_EnableEventQueue: bool = true;
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@LegacyAssetEvents@AzFramework@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static LegacyAssetEvents_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@LegacyAssetEvents@AzFramework@@2W4EBusAddressPolicy@AZ@@B"]
            pub static LegacyAssetEvents_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        pub type LegacyAssetEventBus = root::AZ::EBus;
        #[repr(C)]
        pub struct AssetRegistry {
            pub m_assetIdToInfo: root::AzFramework::AssetRegistry_AssetIdToInfoMap,
            pub m_assetDependencies: root::AZStd::unordered_map,
            pub m_assetPathToId: root::AzFramework::AssetRegistry_AssetPathToIdMap,
            pub m_legacyAssetIdToRealAssetId:
                root::AzFramework::AssetRegistry_LegacyAssetIdToRealAssetIdMap,
        }
        pub type AssetRegistry_AssetIdToInfoMap = root::AZStd::unordered_map;
        pub type AssetRegistry_AssetPathToIdMap = root::AZStd::unordered_map;
        pub type AssetRegistry_LegacyAssetIdToRealAssetIdMap = root::AZStd::unordered_map;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@AssetRegistry@AzFramework@@QEAAXXZ"]
            pub fn AssetRegistry_TYPEINFO_Enable(this: *mut root::AzFramework::AssetRegistry);
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterAsset@AssetRegistry@AzFramework@@QEAAXUAssetId@Data@AZ@@AEBVAssetInfo@45@@Z"]
            pub fn AssetRegistry_RegisterAsset(
                this: *mut root::AzFramework::AssetRegistry,
                id: root::AZ::Data::AssetId,
                assetInfo: *const root::AZ::Data::AssetInfo,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?UnregisterAsset@AssetRegistry@AzFramework@@QEAAXUAssetId@Data@AZ@@@Z"]
            pub fn AssetRegistry_UnregisterAsset(
                this: *mut root::AzFramework::AssetRegistry,
                id: root::AZ::Data::AssetId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterLegacyAssetMapping@AssetRegistry@AzFramework@@QEAAXAEBUAssetId@Data@AZ@@0@Z"]
            pub fn AssetRegistry_RegisterLegacyAssetMapping(
                this: *mut root::AzFramework::AssetRegistry,
                legacyId: *const root::AZ::Data::AssetId,
                newId: *const root::AZ::Data::AssetId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?UnregisterLegacyAssetMapping@AssetRegistry@AzFramework@@QEAAXAEBUAssetId@Data@AZ@@@Z"]
            pub fn AssetRegistry_UnregisterLegacyAssetMapping(
                this: *mut root::AzFramework::AssetRegistry,
                legacyId: *const root::AZ::Data::AssetId,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?SetAssetDependencies@AssetRegistry@AzFramework@@QEAAXAEBUAssetId@Data@AZ@@AEBV?$vector@UProductDependency@Data@AZ@@Vallocator@AZStd@@@AZStd@@@Z"]
            pub fn AssetRegistry_SetAssetDependencies(
                this: *mut root::AzFramework::AssetRegistry,
                id: *const root::AZ::Data::AssetId,
                dependencies: *const root::AZStd::vector<
                    root::AZ::Data::ProductDependency,
                    root::AZStd::allocator,
                >,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RegisterAssetDependency@AssetRegistry@AzFramework@@QEAAXAEBUAssetId@Data@AZ@@AEBUProductDependency@45@@Z"]
            pub fn AssetRegistry_RegisterAssetDependency(
                this: *mut root::AzFramework::AssetRegistry,
                id: *const root::AZ::Data::AssetId,
                dependency: *const root::AZ::Data::ProductDependency,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetAssetIdByPath@AssetRegistry@AzFramework@@QEBA?AUAssetId@Data@AZ@@PEBD@Z"]
            pub fn AssetRegistry_GetAssetIdByPath(
                this: *const root::AzFramework::AssetRegistry,
                assetPath: *const ::std::os::raw::c_char,
            ) -> root::AZ::Data::AssetId;
        }
        extern "C" {
            #[link_name = "\u{1}?Clear@AssetRegistry@AzFramework@@QEAAXXZ"]
            pub fn AssetRegistry_Clear(this: *mut root::AzFramework::AssetRegistry);
        }
        extern "C" {
            #[link_name = "\u{1}?GetAssetIdByLegacyAssetId@AssetRegistry@AzFramework@@QEBA?AUAssetId@Data@AZ@@AEBU345@@Z"]
            pub fn AssetRegistry_GetAssetIdByLegacyAssetId(
                this: *const root::AzFramework::AssetRegistry,
                legacyAssetId: *const root::AZ::Data::AssetId,
            ) -> root::AZ::Data::AssetId;
        }
        extern "C" {
            #[link_name = "\u{1}?ReflectSerialize@AssetRegistry@AzFramework@@SAXPEAVSerializeContext@AZ@@@Z"]
            pub fn AssetRegistry_ReflectSerialize(
                serializeContext: *mut root::AZ::SerializeContext,
            );
        }
        impl AssetRegistry {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                AssetRegistry_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RegisterAsset(
                &mut self,
                id: root::AZ::Data::AssetId,
                assetInfo: *const root::AZ::Data::AssetInfo,
            ) {
                AssetRegistry_RegisterAsset(self, id, assetInfo)
            }
            #[inline]
            pub unsafe fn UnregisterAsset(&mut self, id: root::AZ::Data::AssetId) {
                AssetRegistry_UnregisterAsset(self, id)
            }
            #[inline]
            pub unsafe fn RegisterLegacyAssetMapping(
                &mut self,
                legacyId: *const root::AZ::Data::AssetId,
                newId: *const root::AZ::Data::AssetId,
            ) {
                AssetRegistry_RegisterLegacyAssetMapping(self, legacyId, newId)
            }
            #[inline]
            pub unsafe fn UnregisterLegacyAssetMapping(
                &mut self,
                legacyId: *const root::AZ::Data::AssetId,
            ) {
                AssetRegistry_UnregisterLegacyAssetMapping(self, legacyId)
            }
            #[inline]
            pub unsafe fn SetAssetDependencies(
                &mut self,
                id: *const root::AZ::Data::AssetId,
                dependencies: *const root::AZStd::vector<
                    root::AZ::Data::ProductDependency,
                    root::AZStd::allocator,
                >,
            ) {
                AssetRegistry_SetAssetDependencies(self, id, dependencies)
            }
            #[inline]
            pub unsafe fn RegisterAssetDependency(
                &mut self,
                id: *const root::AZ::Data::AssetId,
                dependency: *const root::AZ::Data::ProductDependency,
            ) {
                AssetRegistry_RegisterAssetDependency(self, id, dependency)
            }
            #[inline]
            pub unsafe fn GetAssetIdByPath(
                &self,
                assetPath: *const ::std::os::raw::c_char,
            ) -> root::AZ::Data::AssetId {
                AssetRegistry_GetAssetIdByPath(self, assetPath)
            }
            #[inline]
            pub unsafe fn Clear(&mut self) {
                AssetRegistry_Clear(self)
            }
            #[inline]
            pub unsafe fn GetAssetIdByLegacyAssetId(
                &self,
                legacyAssetId: *const root::AZ::Data::AssetId,
            ) -> root::AZ::Data::AssetId {
                AssetRegistry_GetAssetIdByLegacyAssetId(self, legacyAssetId)
            }
            #[inline]
            pub unsafe fn ReflectSerialize(serializeContext: *mut root::AZ::SerializeContext) {
                AssetRegistry_ReflectSerialize(serializeContext)
            }
        }
        pub mod AssetSystem {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            pub const AssetStatus_AssetStatus_Unknown: root::AzFramework::AssetSystem::AssetStatus =
                0;
            pub const AssetStatus_AssetStatus_Missing: root::AzFramework::AssetSystem::AssetStatus =
                1;
            pub const AssetStatus_AssetStatus_Queued: root::AzFramework::AssetSystem::AssetStatus =
                2;
            pub const AssetStatus_AssetStatus_Compiling:
                root::AzFramework::AssetSystem::AssetStatus = 3;
            pub const AssetStatus_AssetStatus_Compiled:
                root::AzFramework::AssetSystem::AssetStatus = 4;
            pub const AssetStatus_AssetStatus_Failed: root::AzFramework::AssetSystem::AssetStatus =
                5;
            pub type AssetStatus = i32;
            pub const NegotiationInfo_NegotiationInfo_ProcessId:
                root::AzFramework::AssetSystem::NegotiationInfo = 0;
            pub const NegotiationInfo_NegotiationInfo_Platform:
                root::AzFramework::AssetSystem::NegotiationInfo = 1;
            pub const NegotiationInfo_NegotiationInfo_BranchIndentifier:
                root::AzFramework::AssetSystem::NegotiationInfo = 2;
            pub type NegotiationInfo = i32;
            pub const AssetSystemErrors_ASSETSYSTEM_FAILED_TO_LAUNCH_ASSETPROCESSOR:
                root::AzFramework::AssetSystem::AssetSystemErrors = 0;
            pub const AssetSystemErrors_ASSETSYSTEM_FAILED_TO_CONNECT_TO_ASSETPROCESSOR:
                root::AzFramework::AssetSystem::AssetSystemErrors = 1;
            pub type AssetSystemErrors = i32;
            #[repr(C)]
            pub struct BaseAssetProcessorMessage__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct BaseAssetProcessorMessage {
                pub vtable_: *const BaseAssetProcessorMessage__bindgen_vtable,
                pub m_requireFencing: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@BaseAssetProcessorMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn BaseAssetProcessorMessage_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@BaseAssetProcessorMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn BaseAssetProcessorMessage_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@BaseAssetProcessorMessage@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn BaseAssetProcessorMessage_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?RequireFencing@BaseAssetProcessorMessage@AssetSystem@AzFramework@@QEBA_NXZ"]
                pub fn BaseAssetProcessorMessage_RequireFencing(
                    this: *const root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                ) -> bool;
            }
            extern "C" {
                #[link_name = "\u{1}??0BaseAssetProcessorMessage@AssetSystem@AzFramework@@QEAA@_N@Z"]
                pub fn BaseAssetProcessorMessage_BaseAssetProcessorMessage(
                    this: *mut root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                    requireFencing: bool,
                );
            }
            impl BaseAssetProcessorMessage {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    BaseAssetProcessorMessage_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    BaseAssetProcessorMessage_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    BaseAssetProcessorMessage_Reflect(context)
                }
                #[inline]
                pub unsafe fn RequireFencing(&self) -> bool {
                    BaseAssetProcessorMessage_RequireFencing(self)
                }
                #[inline]
                pub unsafe fn new(requireFencing: bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    BaseAssetProcessorMessage_BaseAssetProcessorMessage(
                        __bindgen_tmp.as_mut_ptr(),
                        requireFencing,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            #[repr(C)]
            pub struct NegotiationMessage {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_apiVersion: ::std::os::raw::c_int,
                pub m_identifier: root::AZ::OSString,
                pub m_negotiationInfoMap:
                    root::AzFramework::AssetSystem::NegotiationMessage_NegotiationInfoMap,
            }
            pub type NegotiationMessage_NegotiationInfoMap = root::AZStd::unordered_map;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@NegotiationMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn NegotiationMessage_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::NegotiationMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@NegotiationMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn NegotiationMessage_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::NegotiationMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@NegotiationMessage@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn NegotiationMessage_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@NegotiationMessage@AssetSystem@AzFramework@@SAIXZ"]
                pub fn NegotiationMessage_MessageType() -> ::std::os::raw::c_uint;
            }
            impl NegotiationMessage {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    NegotiationMessage_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    NegotiationMessage_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    NegotiationMessage_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    NegotiationMessage_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@NegotiationMessage@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn NegotiationMessage_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct RequestPing {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@RequestPing@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestPing_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestPing,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@RequestPing@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestPing_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestPing,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@RequestPing@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn RequestPing_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@RequestPing@AssetSystem@AzFramework@@SAIXZ"]
                pub fn RequestPing_MessageType() -> ::std::os::raw::c_uint;
            }
            impl RequestPing {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    RequestPing_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    RequestPing_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    RequestPing_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    RequestPing_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@RequestPing@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn RequestPing_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ResponsePing {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ResponsePing@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponsePing_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponsePing,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@ResponsePing@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponsePing_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponsePing,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@ResponsePing@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn ResponsePing_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@ResponsePing@AssetSystem@AzFramework@@SAIXZ"]
                pub fn ResponsePing_MessageType() -> ::std::os::raw::c_uint;
            }
            impl ResponsePing {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ResponsePing_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    ResponsePing_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    ResponsePing_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    ResponsePing_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@ResponsePing@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn ResponsePing_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct RequestAssetStatus {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_searchTerm: root::AZ::OSString,
                pub m_isStatusRequest: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@RequestAssetStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestAssetStatus_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@RequestAssetStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestAssetStatus_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@RequestAssetStatus@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn RequestAssetStatus_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@RequestAssetStatus@AssetSystem@AzFramework@@SAIXZ"]
                pub fn RequestAssetStatus_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0RequestAssetStatus@AssetSystem@AzFramework@@QEAA@_N@Z"]
                pub fn RequestAssetStatus_RequestAssetStatus(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetStatus,
                    requireFencing: bool,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0RequestAssetStatus@AssetSystem@AzFramework@@QEAA@PEBD_N1@Z"]
                pub fn RequestAssetStatus_RequestAssetStatus1(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetStatus,
                    sourceData: *const ::std::os::raw::c_char,
                    isStatusRequest: bool,
                    requireFencing: bool,
                );
            }
            impl RequestAssetStatus {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    RequestAssetStatus_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    RequestAssetStatus_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    RequestAssetStatus_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    RequestAssetStatus_MessageType()
                }
                #[inline]
                pub unsafe fn new(requireFencing: bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    RequestAssetStatus_RequestAssetStatus(
                        __bindgen_tmp.as_mut_ptr(),
                        requireFencing,
                    );
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(
                    sourceData: *const ::std::os::raw::c_char,
                    isStatusRequest: bool,
                    requireFencing: bool,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    RequestAssetStatus_RequestAssetStatus1(
                        __bindgen_tmp.as_mut_ptr(),
                        sourceData,
                        isStatusRequest,
                        requireFencing,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@RequestAssetStatus@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn RequestAssetStatus_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ResponseAssetStatus {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetStatus: ::std::os::raw::c_int,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ResponseAssetStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponseAssetStatus_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponseAssetStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@ResponseAssetStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponseAssetStatus_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponseAssetStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@ResponseAssetStatus@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn ResponseAssetStatus_Reflect(context: *mut root::AZ::ReflectContext);
            }
            impl ResponseAssetStatus {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ResponseAssetStatus_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    ResponseAssetStatus_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    ResponseAssetStatus_Reflect(context)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@ResponseAssetStatus@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn ResponseAssetStatus_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct RequestAssetProcessorStatus {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_platform: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@RequestAssetProcessorStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestAssetProcessorStatus_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetProcessorStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@RequestAssetProcessorStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RequestAssetProcessorStatus_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::RequestAssetProcessorStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@RequestAssetProcessorStatus@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn RequestAssetProcessorStatus_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@RequestAssetProcessorStatus@AssetSystem@AzFramework@@SAIXZ"]
                pub fn RequestAssetProcessorStatus_MessageType() -> ::std::os::raw::c_uint;
            }
            impl RequestAssetProcessorStatus {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    RequestAssetProcessorStatus_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    RequestAssetProcessorStatus_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    RequestAssetProcessorStatus_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    RequestAssetProcessorStatus_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@RequestAssetProcessorStatus@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn RequestAssetProcessorStatus_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ResponseAssetProcessorStatus {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_numberOfPendingJobs: ::std::os::raw::c_int,
                pub m_isAssetProcessorReady: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ResponseAssetProcessorStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponseAssetProcessorStatus_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponseAssetProcessorStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@ResponseAssetProcessorStatus@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ResponseAssetProcessorStatus_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::ResponseAssetProcessorStatus,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@ResponseAssetProcessorStatus@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn ResponseAssetProcessorStatus_Reflect(context: *mut root::AZ::ReflectContext);
            }
            impl ResponseAssetProcessorStatus {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ResponseAssetProcessorStatus_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    ResponseAssetProcessorStatus_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    ResponseAssetProcessorStatus_Reflect(context)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@ResponseAssetProcessorStatus@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn ResponseAssetProcessorStatus_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct GetRelativeProductPathFromFullSourceOrProductPathRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_sourceOrProductPath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_TYPEINFO_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_RTTI_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_Reflect(
                    context: *mut root::AZ::ReflectContext,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_MessageType(
                ) -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_GetRelativeProductPathFromFullSourceOrProductPathRequest(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathRequest,
                    sourceOrProductPath: *const root::AZ::OSString,
                );
            }
            impl GetRelativeProductPathFromFullSourceOrProductPathRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    GetRelativeProductPathFromFullSourceOrProductPathRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    GetRelativeProductPathFromFullSourceOrProductPathRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    GetRelativeProductPathFromFullSourceOrProductPathRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    GetRelativeProductPathFromFullSourceOrProductPathRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(sourceOrProductPath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    GetRelativeProductPathFromFullSourceOrProductPathRequest_GetRelativeProductPathFromFullSourceOrProductPathRequest ( __bindgen_tmp . as_mut_ptr ( ) , sourceOrProductPath ) ;
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@GetRelativeProductPathFromFullSourceOrProductPathRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct GetRelativeProductPathFromFullSourceOrProductPathResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_relativeProductPath: root::AZ::OSString,
                pub m_resolved: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@GetRelativeProductPathFromFullSourceOrProductPathResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathResponse_TYPEINFO_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@GetRelativeProductPathFromFullSourceOrProductPathResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathResponse_RTTI_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@GetRelativeProductPathFromFullSourceOrProductPathResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathResponse_Reflect(
                    context: *mut root::AZ::ReflectContext,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0GetRelativeProductPathFromFullSourceOrProductPathResponse@AssetSystem@AzFramework@@QEAA@_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathResponse_GetRelativeProductPathFromFullSourceOrProductPathResponse(
                    this : * mut root :: AzFramework :: AssetSystem :: GetRelativeProductPathFromFullSourceOrProductPathResponse,
                    resolved: bool,
                    relativeProductPath: *const root::AZ::OSString,
                );
            }
            impl GetRelativeProductPathFromFullSourceOrProductPathResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    GetRelativeProductPathFromFullSourceOrProductPathResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    GetRelativeProductPathFromFullSourceOrProductPathResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    GetRelativeProductPathFromFullSourceOrProductPathResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    resolved: bool,
                    relativeProductPath: *const root::AZ::OSString,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    GetRelativeProductPathFromFullSourceOrProductPathResponse_GetRelativeProductPathFromFullSourceOrProductPathResponse ( __bindgen_tmp . as_mut_ptr ( ) , resolved , relativeProductPath ) ;
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@GetRelativeProductPathFromFullSourceOrProductPathResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn GetRelativeProductPathFromFullSourceOrProductPathResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct GetFullSourcePathFromRelativeProductPathRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_relativeProductPath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_TYPEINFO_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_RTTI_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_Reflect(
                    context: *mut root::AZ::ReflectContext,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_MessageType(
                ) -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_GetFullSourcePathFromRelativeProductPathRequest(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathRequest,
                    relativeProductPath: *const root::AZ::OSString,
                );
            }
            impl GetFullSourcePathFromRelativeProductPathRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    GetFullSourcePathFromRelativeProductPathRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    GetFullSourcePathFromRelativeProductPathRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    GetFullSourcePathFromRelativeProductPathRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    GetFullSourcePathFromRelativeProductPathRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(relativeProductPath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    GetFullSourcePathFromRelativeProductPathRequest_GetFullSourcePathFromRelativeProductPathRequest ( __bindgen_tmp . as_mut_ptr ( ) , relativeProductPath ) ;
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@GetFullSourcePathFromRelativeProductPathRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct GetFullSourcePathFromRelativeProductPathResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fullSourcePath: root::AZ::OSString,
                pub m_resolved: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@GetFullSourcePathFromRelativeProductPathResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathResponse_TYPEINFO_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@GetFullSourcePathFromRelativeProductPathResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathResponse_RTTI_Enable(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@GetFullSourcePathFromRelativeProductPathResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn GetFullSourcePathFromRelativeProductPathResponse_Reflect(
                    context: *mut root::AZ::ReflectContext,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0GetFullSourcePathFromRelativeProductPathResponse@AssetSystem@AzFramework@@QEAA@_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn GetFullSourcePathFromRelativeProductPathResponse_GetFullSourcePathFromRelativeProductPathResponse(
                    this : * mut root :: AzFramework :: AssetSystem :: GetFullSourcePathFromRelativeProductPathResponse,
                    resolved: bool,
                    fullProductPath: *const root::AZ::OSString,
                );
            }
            impl GetFullSourcePathFromRelativeProductPathResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    GetFullSourcePathFromRelativeProductPathResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    GetFullSourcePathFromRelativeProductPathResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    GetFullSourcePathFromRelativeProductPathResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    resolved: bool,
                    fullProductPath: *const root::AZ::OSString,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    GetFullSourcePathFromRelativeProductPathResponse_GetFullSourcePathFromRelativeProductPathResponse ( __bindgen_tmp . as_mut_ptr ( ) , resolved , fullProductPath ) ;
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@GetFullSourcePathFromRelativeProductPathResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn GetFullSourcePathFromRelativeProductPathResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct SourceAssetInfoRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetPath: root::AZ::OSString,
                pub __bindgen_padding_0: u64,
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_assetType: root::AZ::Data::AssetType,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@SourceAssetInfoRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SourceAssetInfoRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@SourceAssetInfoRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SourceAssetInfoRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@SourceAssetInfoRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn SourceAssetInfoRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@SourceAssetInfoRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn SourceAssetInfoRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0SourceAssetInfoRequest@AssetSystem@AzFramework@@QEAA@AEBUAssetId@Data@AZ@@AEBUUuid@5@@Z"]
                pub fn SourceAssetInfoRequest_SourceAssetInfoRequest(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoRequest,
                    assetId: *const root::AZ::Data::AssetId,
                    assetType: *const root::AZ::Data::AssetType,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0SourceAssetInfoRequest@AssetSystem@AzFramework@@QEAA@PEBD@Z"]
                pub fn SourceAssetInfoRequest_SourceAssetInfoRequest1(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoRequest,
                    assetPath: *const ::std::os::raw::c_char,
                );
            }
            impl SourceAssetInfoRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    SourceAssetInfoRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    SourceAssetInfoRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    SourceAssetInfoRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    SourceAssetInfoRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    assetId: *const root::AZ::Data::AssetId,
                    assetType: *const root::AZ::Data::AssetType,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SourceAssetInfoRequest_SourceAssetInfoRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        assetId,
                        assetType,
                    );
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(assetPath: *const ::std::os::raw::c_char) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SourceAssetInfoRequest_SourceAssetInfoRequest1(
                        __bindgen_tmp.as_mut_ptr(),
                        assetPath,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@SourceAssetInfoRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn SourceAssetInfoRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct SourceAssetInfoResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_found: bool,
                pub __bindgen_padding_0: u64,
                pub m_assetInfo: root::AZ::Data::AssetInfo,
                pub m_rootFolder: root::AZ::OSString,
                pub __bindgen_padding_1: u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@SourceAssetInfoResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SourceAssetInfoResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@SourceAssetInfoResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SourceAssetInfoResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@SourceAssetInfoResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn SourceAssetInfoResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0SourceAssetInfoResponse@AssetSystem@AzFramework@@QEAA@AEBVAssetInfo@Data@AZ@@PEBD@Z"]
                pub fn SourceAssetInfoResponse_SourceAssetInfoResponse(
                    this: *mut root::AzFramework::AssetSystem::SourceAssetInfoResponse,
                    assetInfo: *const root::AZ::Data::AssetInfo,
                    rootFolder: *const ::std::os::raw::c_char,
                );
            }
            impl SourceAssetInfoResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    SourceAssetInfoResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    SourceAssetInfoResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    SourceAssetInfoResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    assetInfo: *const root::AZ::Data::AssetInfo,
                    rootFolder: *const ::std::os::raw::c_char,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    SourceAssetInfoResponse_SourceAssetInfoResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        assetInfo,
                        rootFolder,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@SourceAssetInfoResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn SourceAssetInfoResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetInfoRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetPath: root::AZ::OSString,
                pub __bindgen_padding_0: u64,
                pub m_assetId: root::AZ::Data::AssetId,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetInfoRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetInfoRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetInfoRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetInfoRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@AssetInfoRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn AssetInfoRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@AssetInfoRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn AssetInfoRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetInfoRequest@AssetSystem@AzFramework@@QEAA@AEBUAssetId@Data@AZ@@@Z"]
                pub fn AssetInfoRequest_AssetInfoRequest(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoRequest,
                    assetId: *const root::AZ::Data::AssetId,
                );
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetInfoRequest@AssetSystem@AzFramework@@QEAA@PEBD@Z"]
                pub fn AssetInfoRequest_AssetInfoRequest1(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoRequest,
                    assetPath: *const ::std::os::raw::c_char,
                );
            }
            impl AssetInfoRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetInfoRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetInfoRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    AssetInfoRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    AssetInfoRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(assetId: *const root::AZ::Data::AssetId) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetInfoRequest_AssetInfoRequest(__bindgen_tmp.as_mut_ptr(), assetId);
                    __bindgen_tmp.assume_init()
                }
                #[inline]
                pub unsafe fn new1(assetPath: *const ::std::os::raw::c_char) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetInfoRequest_AssetInfoRequest1(__bindgen_tmp.as_mut_ptr(), assetPath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@AssetInfoRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn AssetInfoRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetInfoResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_found: bool,
                pub __bindgen_padding_0: u64,
                pub m_assetInfo: root::AZ::Data::AssetInfo,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetInfoResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetInfoResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetInfoResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetInfoResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@AssetInfoResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn AssetInfoResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetInfoResponse@AssetSystem@AzFramework@@QEAA@AEBVAssetInfo@Data@AZ@@@Z"]
                pub fn AssetInfoResponse_AssetInfoResponse(
                    this: *mut root::AzFramework::AssetSystem::AssetInfoResponse,
                    assetInfo: *const root::AZ::Data::AssetInfo,
                );
            }
            impl AssetInfoResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetInfoResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetInfoResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    AssetInfoResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(assetInfo: *const root::AZ::Data::AssetInfo) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetInfoResponse_AssetInfoResponse(__bindgen_tmp.as_mut_ptr(), assetInfo);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@AssetInfoResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn AssetInfoResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct RegisterSourceAssetRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_assetFileFilter: root::AZ::OSString,
                pub __bindgen_padding_0: u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@RegisterSourceAssetRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RegisterSourceAssetRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::RegisterSourceAssetRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@RegisterSourceAssetRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn RegisterSourceAssetRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::RegisterSourceAssetRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@RegisterSourceAssetRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn RegisterSourceAssetRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@RegisterSourceAssetRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn RegisterSourceAssetRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0RegisterSourceAssetRequest@AssetSystem@AzFramework@@QEAA@AEBUUuid@AZ@@PEBD@Z"]
                pub fn RegisterSourceAssetRequest_RegisterSourceAssetRequest(
                    this: *mut root::AzFramework::AssetSystem::RegisterSourceAssetRequest,
                    assetType: *const root::AZ::Data::AssetType,
                    assetFileFilter: *const ::std::os::raw::c_char,
                );
            }
            impl RegisterSourceAssetRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    RegisterSourceAssetRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    RegisterSourceAssetRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    RegisterSourceAssetRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    RegisterSourceAssetRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    assetType: *const root::AZ::Data::AssetType,
                    assetFileFilter: *const ::std::os::raw::c_char,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    RegisterSourceAssetRequest_RegisterSourceAssetRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        assetType,
                        assetFileFilter,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@RegisterSourceAssetRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn RegisterSourceAssetRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            #[derive(Debug)]
            pub struct UnregisterSourceAssetRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetType: root::AZ::Data::AssetType,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@UnregisterSourceAssetRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn UnregisterSourceAssetRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::UnregisterSourceAssetRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@UnregisterSourceAssetRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn UnregisterSourceAssetRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::UnregisterSourceAssetRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@UnregisterSourceAssetRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn UnregisterSourceAssetRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@UnregisterSourceAssetRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn UnregisterSourceAssetRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0UnregisterSourceAssetRequest@AssetSystem@AzFramework@@QEAA@AEBUUuid@AZ@@@Z"]
                pub fn UnregisterSourceAssetRequest_UnregisterSourceAssetRequest(
                    this: *mut root::AzFramework::AssetSystem::UnregisterSourceAssetRequest,
                    assetType: *const root::AZ::Data::AssetType,
                );
            }
            impl UnregisterSourceAssetRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    UnregisterSourceAssetRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    UnregisterSourceAssetRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    UnregisterSourceAssetRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    UnregisterSourceAssetRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(assetType: *const root::AZ::Data::AssetType) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    UnregisterSourceAssetRequest_UnregisterSourceAssetRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        assetType,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@UnregisterSourceAssetRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn UnregisterSourceAssetRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct ShowAssetProcessorRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ShowAssetProcessorRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ShowAssetProcessorRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::ShowAssetProcessorRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@ShowAssetProcessorRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ShowAssetProcessorRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::ShowAssetProcessorRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@ShowAssetProcessorRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn ShowAssetProcessorRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@ShowAssetProcessorRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn ShowAssetProcessorRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            impl ShowAssetProcessorRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ShowAssetProcessorRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    ShowAssetProcessorRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    ShowAssetProcessorRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    ShowAssetProcessorRequest_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@ShowAssetProcessorRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn ShowAssetProcessorRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct ShowAssetInAssetProcessorRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_assetPath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@ShowAssetInAssetProcessorRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ShowAssetInAssetProcessorRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::ShowAssetInAssetProcessorRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@ShowAssetInAssetProcessorRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn ShowAssetInAssetProcessorRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::ShowAssetInAssetProcessorRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@ShowAssetInAssetProcessorRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn ShowAssetInAssetProcessorRequest_Reflect(
                    context: *mut root::AZ::ReflectContext,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@ShowAssetInAssetProcessorRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn ShowAssetInAssetProcessorRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            impl ShowAssetInAssetProcessorRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    ShowAssetInAssetProcessorRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    ShowAssetInAssetProcessorRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    ShowAssetInAssetProcessorRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    ShowAssetInAssetProcessorRequest_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@ShowAssetInAssetProcessorRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn ShowAssetInAssetProcessorRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[repr(align(16))]
            pub struct AssetNotificationMessage {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_data: root::AZ::OSString,
                pub m_type:
                    root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType,
                pub m_sizeBytes: root::AZ::u64,
                pub __bindgen_padding_0: u64,
                pub m_assetId: root::AZ::Data::AssetId,
                pub m_legacyAssetIds:
                    root::AZStd::vector<root::AZ::Data::AssetId, root::AZStd::allocator>,
                pub m_assetType: root::AZ::Data::AssetType,
                pub m_dependencies:
                    root::AZStd::vector<root::AZ::Data::ProductDependency, root::AZStd::allocator>,
            }
            pub const AssetNotificationMessage_NotificationType_AssetChanged:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 0;
            pub const AssetNotificationMessage_NotificationType_AssetRemoved:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 1;
            pub const AssetNotificationMessage_NotificationType_JobFileClaimed:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 2;
            pub const AssetNotificationMessage_NotificationType_JobFileReleased:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 3;
            pub const AssetNotificationMessage_NotificationType_JobStarted:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 4;
            pub const AssetNotificationMessage_NotificationType_JobCompleted:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 5;
            pub const AssetNotificationMessage_NotificationType_JobFailed:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 6;
            pub const AssetNotificationMessage_NotificationType_JobCount:
                root::AzFramework::AssetSystem::AssetNotificationMessage_NotificationType = 7;
            pub type AssetNotificationMessage_NotificationType = u32;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@AssetNotificationMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetNotificationMessage_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetNotificationMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@AssetNotificationMessage@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn AssetNotificationMessage_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::AssetNotificationMessage,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@AssetNotificationMessage@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn AssetNotificationMessage_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@AssetNotificationMessage@AssetSystem@AzFramework@@SAIXZ"]
                pub fn AssetNotificationMessage_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0AssetNotificationMessage@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@W4NotificationType@012@AEBUUuid@AZ@@@Z"]
                pub fn AssetNotificationMessage_AssetNotificationMessage(
                    this: *mut root::AzFramework::AssetSystem::AssetNotificationMessage,
                    data: *const root::AZ::OSString,
                    type_ : root :: AzFramework :: AssetSystem :: AssetNotificationMessage_NotificationType,
                    assetType: *const root::AZ::Data::AssetType,
                );
            }
            impl AssetNotificationMessage {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    AssetNotificationMessage_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    AssetNotificationMessage_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    AssetNotificationMessage_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    AssetNotificationMessage_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    data: *const root::AZ::OSString,
                    type_ : root :: AzFramework :: AssetSystem :: AssetNotificationMessage_NotificationType,
                    assetType: *const root::AZ::Data::AssetType,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    AssetNotificationMessage_AssetNotificationMessage(
                        __bindgen_tmp.as_mut_ptr(),
                        data,
                        type_,
                        assetType,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@AssetNotificationMessage@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn AssetNotificationMessage_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct SaveAssetCatalogRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@SaveAssetCatalogRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SaveAssetCatalogRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::SaveAssetCatalogRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@SaveAssetCatalogRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SaveAssetCatalogRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::SaveAssetCatalogRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@SaveAssetCatalogRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn SaveAssetCatalogRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@SaveAssetCatalogRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn SaveAssetCatalogRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            impl SaveAssetCatalogRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    SaveAssetCatalogRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    SaveAssetCatalogRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    SaveAssetCatalogRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    SaveAssetCatalogRequest_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@SaveAssetCatalogRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn SaveAssetCatalogRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct SaveAssetCatalogResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_saved: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@SaveAssetCatalogResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SaveAssetCatalogResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::SaveAssetCatalogResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@SaveAssetCatalogResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn SaveAssetCatalogResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::SaveAssetCatalogResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@SaveAssetCatalogResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn SaveAssetCatalogResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            impl SaveAssetCatalogResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    SaveAssetCatalogResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    SaveAssetCatalogResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    SaveAssetCatalogResponse_Reflect(context)
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@SaveAssetCatalogResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn SaveAssetCatalogResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileOpenRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
                pub m_mode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileOpenRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileOpenRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileOpenRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileOpenRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileOpenRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileOpenRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileOpenRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileOpenRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileOpenRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileOpenRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileOpenRequest@AssetSystem@AzFramework@@QEAA@PEBDI@Z"]
                pub fn FileOpenRequest_FileOpenRequest(
                    this: *mut root::AzFramework::AssetSystem::FileOpenRequest,
                    filePath: *const ::std::os::raw::c_char,
                    mode: root::AZ::u32,
                );
            }
            impl FileOpenRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileOpenRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileOpenRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileOpenRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileOpenRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    filePath: *const ::std::os::raw::c_char,
                    mode: root::AZ::u32,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileOpenRequest_FileOpenRequest(__bindgen_tmp.as_mut_ptr(), filePath, mode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileOpenRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileOpenRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileOpenResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
                pub m_returnCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileOpenResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileOpenResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileOpenResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileOpenResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileOpenResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileOpenResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileOpenResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileOpenResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileOpenResponse@AssetSystem@AzFramework@@QEAA@II@Z"]
                pub fn FileOpenResponse_FileOpenResponse(
                    this: *mut root::AzFramework::AssetSystem::FileOpenResponse,
                    fileHandle: root::AZ::u32,
                    returnCode: root::AZ::u32,
                );
            }
            impl FileOpenResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileOpenResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileOpenResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileOpenResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(fileHandle: root::AZ::u32, returnCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileOpenResponse_FileOpenResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        fileHandle,
                        returnCode,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileOpenResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileOpenResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileCloseRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileCloseRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCloseRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCloseRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileCloseRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCloseRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCloseRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileCloseRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileCloseRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileCloseRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileCloseRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileCloseRequest@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileCloseRequest_FileCloseRequest(
                    this: *mut root::AzFramework::AssetSystem::FileCloseRequest,
                    fileHandle: root::AZ::u32,
                );
            }
            impl FileCloseRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileCloseRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileCloseRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileCloseRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileCloseRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(fileHandle: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileCloseRequest_FileCloseRequest(__bindgen_tmp.as_mut_ptr(), fileHandle);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileCloseRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileCloseRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileReadRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
                pub m_bytesToRead: root::AZ::u64,
                pub m_failOnFewerRead: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileReadRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileReadRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileReadRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileReadRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileReadRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileReadRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileReadRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileReadRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileReadRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileReadRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileReadRequest@AssetSystem@AzFramework@@QEAA@I_K_N@Z"]
                pub fn FileReadRequest_FileReadRequest(
                    this: *mut root::AzFramework::AssetSystem::FileReadRequest,
                    fileHandle: root::AZ::u32,
                    bytesToRead: root::AZ::u64,
                    failOnFewerRead: bool,
                );
            }
            impl FileReadRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileReadRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileReadRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileReadRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileReadRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    fileHandle: root::AZ::u32,
                    bytesToRead: root::AZ::u64,
                    failOnFewerRead: bool,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileReadRequest_FileReadRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        fileHandle,
                        bytesToRead,
                        failOnFewerRead,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileReadRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileReadRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileReadResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_data: root::AZStd::vector<root::AZ::u8, root::AZ::OSStdAllocator>,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileReadResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileReadResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileReadResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileReadResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileReadResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileReadResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileReadResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileReadResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileReadResponse@AssetSystem@AzFramework@@QEAA@IPEAX_K@Z"]
                pub fn FileReadResponse_FileReadResponse(
                    this: *mut root::AzFramework::AssetSystem::FileReadResponse,
                    resultCode: root::AZ::u32,
                    data: *mut ::std::os::raw::c_void,
                    dataLength: root::AZ::u64,
                );
            }
            impl FileReadResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileReadResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileReadResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileReadResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    resultCode: root::AZ::u32,
                    data: *mut ::std::os::raw::c_void,
                    dataLength: root::AZ::u64,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileReadResponse_FileReadResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        resultCode,
                        data,
                        dataLength,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileReadResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileReadResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileWriteRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
                pub m_data: root::AZStd::vector<root::AZ::u8, root::AZ::OSStdAllocator>,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileWriteRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileWriteRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileWriteRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileWriteRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileWriteRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileWriteRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileWriteRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileWriteRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileWriteRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileWriteRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileWriteRequest@AssetSystem@AzFramework@@QEAA@IPEBX_K@Z"]
                pub fn FileWriteRequest_FileWriteRequest(
                    this: *mut root::AzFramework::AssetSystem::FileWriteRequest,
                    fileHandle: root::AZ::u32,
                    data: *const ::std::os::raw::c_void,
                    dataLength: root::AZ::u64,
                );
            }
            impl FileWriteRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileWriteRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileWriteRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileWriteRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileWriteRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    fileHandle: root::AZ::u32,
                    data: *const ::std::os::raw::c_void,
                    dataLength: root::AZ::u64,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileWriteRequest_FileWriteRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        fileHandle,
                        data,
                        dataLength,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileWriteRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileWriteRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileWriteResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_bytesWritten: root::AZ::u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileWriteResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileWriteResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileWriteResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileWriteResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileWriteResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileWriteResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileWriteResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileWriteResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileWriteResponse@AssetSystem@AzFramework@@QEAA@I_K@Z"]
                pub fn FileWriteResponse_FileWriteResponse(
                    this: *mut root::AzFramework::AssetSystem::FileWriteResponse,
                    resultCode: root::AZ::u32,
                    bytesWritten: root::AZ::u64,
                );
            }
            impl FileWriteResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileWriteResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileWriteResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileWriteResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32, bytesWritten: root::AZ::u64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileWriteResponse_FileWriteResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        resultCode,
                        bytesWritten,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileWriteResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileWriteResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileTellRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileTellRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTellRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTellRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileTellRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTellRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTellRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileTellRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileTellRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileTellRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileTellRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileTellRequest@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileTellRequest_FileTellRequest(
                    this: *mut root::AzFramework::AssetSystem::FileTellRequest,
                    fileHandle: root::AZ::u32,
                );
            }
            impl FileTellRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileTellRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileTellRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileTellRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileTellRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(fileHandle: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileTellRequest_FileTellRequest(__bindgen_tmp.as_mut_ptr(), fileHandle);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileTellRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileTellRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileTellResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_offset: root::AZ::u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileTellResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTellResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTellResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileTellResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTellResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTellResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileTellResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileTellResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileTellResponse@AssetSystem@AzFramework@@QEAA@I_K@Z"]
                pub fn FileTellResponse_FileTellResponse(
                    this: *mut root::AzFramework::AssetSystem::FileTellResponse,
                    resultCode: root::AZ::u32,
                    offset: root::AZ::u64,
                );
            }
            impl FileTellResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileTellResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileTellResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileTellResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32, offset: root::AZ::u64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileTellResponse_FileTellResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        resultCode,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileTellResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileTellResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileSeekRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
                pub m_seekMode: root::AZ::u32,
                pub m_offset: root::AZ::s64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileSeekRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSeekRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSeekRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileSeekRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSeekRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSeekRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileSeekRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileSeekRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileSeekRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileSeekRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileSeekRequest@AssetSystem@AzFramework@@QEAA@II_J@Z"]
                pub fn FileSeekRequest_FileSeekRequest(
                    this: *mut root::AzFramework::AssetSystem::FileSeekRequest,
                    fileHandle: root::AZ::u32,
                    mode: root::AZ::u32,
                    offset: root::AZ::s64,
                );
            }
            impl FileSeekRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileSeekRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileSeekRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileSeekRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileSeekRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    fileHandle: root::AZ::u32,
                    mode: root::AZ::u32,
                    offset: root::AZ::s64,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileSeekRequest_FileSeekRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        fileHandle,
                        mode,
                        offset,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileSeekRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileSeekRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileSeekResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileSeekResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSeekResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSeekResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileSeekResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSeekResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSeekResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileSeekResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileSeekResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileSeekResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileSeekResponse_FileSeekResponse(
                    this: *mut root::AzFramework::AssetSystem::FileSeekResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl FileSeekResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileSeekResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileSeekResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileSeekResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileSeekResponse_FileSeekResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileSeekResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileSeekResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileIsReadOnlyRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileIsReadOnlyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileIsReadOnlyRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileIsReadOnlyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileIsReadOnlyRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileIsReadOnlyRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileIsReadOnlyRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileIsReadOnlyRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileIsReadOnlyRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileIsReadOnlyRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FileIsReadOnlyRequest_FileIsReadOnlyRequest(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyRequest,
                    filePath: *const root::AZ::OSString,
                );
            }
            impl FileIsReadOnlyRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileIsReadOnlyRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileIsReadOnlyRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileIsReadOnlyRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileIsReadOnlyRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(filePath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileIsReadOnlyRequest_FileIsReadOnlyRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        filePath,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileIsReadOnlyRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileIsReadOnlyRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FileIsReadOnlyResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_isReadOnly: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileIsReadOnlyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileIsReadOnlyResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileIsReadOnlyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileIsReadOnlyResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileIsReadOnlyResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileIsReadOnlyResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileIsReadOnlyResponse@AssetSystem@AzFramework@@QEAA@_N@Z"]
                pub fn FileIsReadOnlyResponse_FileIsReadOnlyResponse(
                    this: *mut root::AzFramework::AssetSystem::FileIsReadOnlyResponse,
                    isReadOnly: bool,
                );
            }
            impl FileIsReadOnlyResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileIsReadOnlyResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileIsReadOnlyResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileIsReadOnlyResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(isReadOnly: bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileIsReadOnlyResponse_FileIsReadOnlyResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        isReadOnly,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileIsReadOnlyResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileIsReadOnlyResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct PathIsDirectoryRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_path: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathIsDirectoryRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathIsDirectoryRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathIsDirectoryRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathIsDirectoryRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathIsDirectoryRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathIsDirectoryRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@PathIsDirectoryRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn PathIsDirectoryRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0PathIsDirectoryRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn PathIsDirectoryRequest_PathIsDirectoryRequest(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryRequest,
                    path: *const root::AZ::OSString,
                );
            }
            impl PathIsDirectoryRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathIsDirectoryRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathIsDirectoryRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathIsDirectoryRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    PathIsDirectoryRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(path: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathIsDirectoryRequest_PathIsDirectoryRequest(__bindgen_tmp.as_mut_ptr(), path);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathIsDirectoryRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathIsDirectoryRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct PathIsDirectoryResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_isDir: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathIsDirectoryResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathIsDirectoryResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathIsDirectoryResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathIsDirectoryResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathIsDirectoryResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathIsDirectoryResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0PathIsDirectoryResponse@AssetSystem@AzFramework@@QEAA@_N@Z"]
                pub fn PathIsDirectoryResponse_PathIsDirectoryResponse(
                    this: *mut root::AzFramework::AssetSystem::PathIsDirectoryResponse,
                    isDir: bool,
                );
            }
            impl PathIsDirectoryResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathIsDirectoryResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathIsDirectoryResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathIsDirectoryResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(isDir: bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathIsDirectoryResponse_PathIsDirectoryResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        isDir,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathIsDirectoryResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathIsDirectoryResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileSizeRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileSizeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSizeRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSizeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileSizeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSizeRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSizeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileSizeRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileSizeRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileSizeRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileSizeRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileSizeRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FileSizeRequest_FileSizeRequest(
                    this: *mut root::AzFramework::AssetSystem::FileSizeRequest,
                    filePath: *const root::AZ::OSString,
                );
            }
            impl FileSizeRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileSizeRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileSizeRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileSizeRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileSizeRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(filePath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileSizeRequest_FileSizeRequest(__bindgen_tmp.as_mut_ptr(), filePath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileSizeRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileSizeRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileSizeResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_size: root::AZ::u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileSizeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSizeResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSizeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileSizeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileSizeResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileSizeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileSizeResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileSizeResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileSizeResponse@AssetSystem@AzFramework@@QEAA@I_K@Z"]
                pub fn FileSizeResponse_FileSizeResponse(
                    this: *mut root::AzFramework::AssetSystem::FileSizeResponse,
                    resultCode: root::AZ::u32,
                    size: root::AZ::u64,
                );
            }
            impl FileSizeResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileSizeResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileSizeResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileSizeResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32, size: root::AZ::u64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileSizeResponse_FileSizeResponse(__bindgen_tmp.as_mut_ptr(), resultCode, size);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileSizeResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileSizeResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileModTimeRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileModTimeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileModTimeRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileModTimeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileModTimeRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileModTimeRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileModTimeRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileModTimeRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileModTimeRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileModTimeRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FileModTimeRequest_FileModTimeRequest(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeRequest,
                    filePath: *const root::AZ::OSString,
                );
            }
            impl FileModTimeRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileModTimeRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileModTimeRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileModTimeRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileModTimeRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(filePath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileModTimeRequest_FileModTimeRequest(__bindgen_tmp.as_mut_ptr(), filePath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileModTimeRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileModTimeRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileModTimeResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_modTime: root::AZ::u64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileModTimeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileModTimeResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileModTimeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileModTimeResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileModTimeResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileModTimeResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileModTimeResponse@AssetSystem@AzFramework@@QEAA@_K@Z"]
                pub fn FileModTimeResponse_FileModTimeResponse(
                    this: *mut root::AzFramework::AssetSystem::FileModTimeResponse,
                    modTime: root::AZ::u64,
                );
            }
            impl FileModTimeResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileModTimeResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileModTimeResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileModTimeResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(modTime: root::AZ::u64) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileModTimeResponse_FileModTimeResponse(__bindgen_tmp.as_mut_ptr(), modTime);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileModTimeResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileModTimeResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileExistsRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileExistsRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileExistsRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileExistsRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileExistsRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileExistsRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileExistsRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileExistsRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileExistsRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileExistsRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileExistsRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileExistsRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FileExistsRequest_FileExistsRequest(
                    this: *mut root::AzFramework::AssetSystem::FileExistsRequest,
                    filePath: *const root::AZ::OSString,
                );
            }
            impl FileExistsRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileExistsRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileExistsRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileExistsRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileExistsRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(filePath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileExistsRequest_FileExistsRequest(__bindgen_tmp.as_mut_ptr(), filePath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileExistsRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileExistsRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FileExistsResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_exists: bool,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileExistsResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileExistsResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileExistsResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileExistsResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileExistsResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileExistsResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileExistsResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileExistsResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileExistsResponse@AssetSystem@AzFramework@@QEAA@_N@Z"]
                pub fn FileExistsResponse_FileExistsResponse(
                    this: *mut root::AzFramework::AssetSystem::FileExistsResponse,
                    exists: bool,
                );
            }
            impl FileExistsResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileExistsResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileExistsResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileExistsResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(exists: bool) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileExistsResponse_FileExistsResponse(__bindgen_tmp.as_mut_ptr(), exists);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileExistsResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileExistsResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileFlushRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_fileHandle: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileFlushRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileFlushRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileFlushRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileFlushRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileFlushRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileFlushRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileFlushRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileFlushRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileFlushRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileFlushRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileFlushRequest@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileFlushRequest_FileFlushRequest(
                    this: *mut root::AzFramework::AssetSystem::FileFlushRequest,
                    fileHandle: root::AZ::u32,
                );
            }
            impl FileFlushRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileFlushRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileFlushRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileFlushRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileFlushRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(fileHandle: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileFlushRequest_FileFlushRequest(__bindgen_tmp.as_mut_ptr(), fileHandle);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileFlushRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileFlushRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileFlushResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileFlushResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileFlushResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileFlushResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileFlushResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileFlushResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileFlushResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileFlushResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileFlushResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileFlushResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileFlushResponse_FileFlushResponse(
                    this: *mut root::AzFramework::AssetSystem::FileFlushResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl FileFlushResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileFlushResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileFlushResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileFlushResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileFlushResponse_FileFlushResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileFlushResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileFlushResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct PathCreateRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_path: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathCreateRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathCreateRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathCreateRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathCreateRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathCreateRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathCreateRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathCreateRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathCreateRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@PathCreateRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn PathCreateRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0PathCreateRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn PathCreateRequest_PathCreateRequest(
                    this: *mut root::AzFramework::AssetSystem::PathCreateRequest,
                    path: *const root::AZ::OSString,
                );
            }
            impl PathCreateRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathCreateRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathCreateRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathCreateRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    PathCreateRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(path: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathCreateRequest_PathCreateRequest(__bindgen_tmp.as_mut_ptr(), path);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathCreateRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathCreateRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct PathCreateResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathCreateResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathCreateResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathCreateResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathCreateResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathCreateResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathCreateResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathCreateResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathCreateResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0PathCreateResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn PathCreateResponse_PathCreateResponse(
                    this: *mut root::AzFramework::AssetSystem::PathCreateResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl PathCreateResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathCreateResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathCreateResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathCreateResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathCreateResponse_PathCreateResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathCreateResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathCreateResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct PathDestroyRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_path: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathDestroyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathDestroyRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathDestroyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathDestroyRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathDestroyRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathDestroyRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@PathDestroyRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn PathDestroyRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0PathDestroyRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn PathDestroyRequest_PathDestroyRequest(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyRequest,
                    path: *const root::AZ::OSString,
                );
            }
            impl PathDestroyRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathDestroyRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathDestroyRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathDestroyRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    PathDestroyRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(path: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathDestroyRequest_PathDestroyRequest(__bindgen_tmp.as_mut_ptr(), path);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathDestroyRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathDestroyRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct PathDestroyResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@PathDestroyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathDestroyResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@PathDestroyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn PathDestroyResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@PathDestroyResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn PathDestroyResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0PathDestroyResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn PathDestroyResponse_PathDestroyResponse(
                    this: *mut root::AzFramework::AssetSystem::PathDestroyResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl PathDestroyResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    PathDestroyResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    PathDestroyResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    PathDestroyResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    PathDestroyResponse_PathDestroyResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@PathDestroyResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn PathDestroyResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileRemoveRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_filePath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileRemoveRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRemoveRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileRemoveRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRemoveRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileRemoveRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileRemoveRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileRemoveRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileRemoveRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileRemoveRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FileRemoveRequest_FileRemoveRequest(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveRequest,
                    filePath: *const root::AZ::OSString,
                );
            }
            impl FileRemoveRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileRemoveRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileRemoveRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileRemoveRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileRemoveRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(filePath: *const root::AZ::OSString) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileRemoveRequest_FileRemoveRequest(__bindgen_tmp.as_mut_ptr(), filePath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileRemoveRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileRemoveRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileRemoveResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileRemoveResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRemoveResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileRemoveResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRemoveResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileRemoveResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileRemoveResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileRemoveResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileRemoveResponse_FileRemoveResponse(
                    this: *mut root::AzFramework::AssetSystem::FileRemoveResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl FileRemoveResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileRemoveResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileRemoveResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileRemoveResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileRemoveResponse_FileRemoveResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileRemoveResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileRemoveResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileCopyRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_srcPath: root::AZ::OSString,
                pub m_destPath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileCopyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCopyRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCopyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileCopyRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCopyRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCopyRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileCopyRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileCopyRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileCopyRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileCopyRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileCopyRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@0@Z"]
                pub fn FileCopyRequest_FileCopyRequest(
                    this: *mut root::AzFramework::AssetSystem::FileCopyRequest,
                    srcPath: *const root::AZ::OSString,
                    destPath: *const root::AZ::OSString,
                );
            }
            impl FileCopyRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileCopyRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileCopyRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileCopyRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileCopyRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    srcPath: *const root::AZ::OSString,
                    destPath: *const root::AZ::OSString,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileCopyRequest_FileCopyRequest(__bindgen_tmp.as_mut_ptr(), srcPath, destPath);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileCopyRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileCopyRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileCopyResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileCopyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCopyResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCopyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileCopyResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileCopyResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileCopyResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileCopyResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileCopyResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileCopyResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileCopyResponse_FileCopyResponse(
                    this: *mut root::AzFramework::AssetSystem::FileCopyResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl FileCopyResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileCopyResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileCopyResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileCopyResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileCopyResponse_FileCopyResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileCopyResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileCopyResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileRenameRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_srcPath: root::AZ::OSString,
                pub m_destPath: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileRenameRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRenameRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRenameRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileRenameRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRenameRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRenameRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileRenameRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileRenameRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileRenameRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileRenameRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FileRenameRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@0@Z"]
                pub fn FileRenameRequest_FileRenameRequest(
                    this: *mut root::AzFramework::AssetSystem::FileRenameRequest,
                    srcPath: *const root::AZ::OSString,
                    destPath: *const root::AZ::OSString,
                );
            }
            impl FileRenameRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileRenameRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileRenameRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileRenameRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileRenameRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    srcPath: *const root::AZ::OSString,
                    destPath: *const root::AZ::OSString,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileRenameRequest_FileRenameRequest(
                        __bindgen_tmp.as_mut_ptr(),
                        srcPath,
                        destPath,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileRenameRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileRenameRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileRenameResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileRenameResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRenameResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRenameResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileRenameResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileRenameResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileRenameResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileRenameResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileRenameResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileRenameResponse@AssetSystem@AzFramework@@QEAA@I@Z"]
                pub fn FileRenameResponse_FileRenameResponse(
                    this: *mut root::AzFramework::AssetSystem::FileRenameResponse,
                    resultCode: root::AZ::u32,
                );
            }
            impl FileRenameResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileRenameResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileRenameResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileRenameResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(resultCode: root::AZ::u32) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileRenameResponse_FileRenameResponse(__bindgen_tmp.as_mut_ptr(), resultCode);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileRenameResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileRenameResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FindFilesRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_path: root::AZ::OSString,
                pub m_filter: root::AZ::OSString,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FindFilesRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FindFilesRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FindFilesRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FindFilesRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FindFilesRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FindFilesRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FindFilesRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FindFilesRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FindFilesRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FindFilesRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            extern "C" {
                #[link_name = "\u{1}??0FindFilesRequest@AssetSystem@AzFramework@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@0@Z"]
                pub fn FindFilesRequest_FindFilesRequest(
                    this: *mut root::AzFramework::AssetSystem::FindFilesRequest,
                    path: *const root::AZ::OSString,
                    filter: *const root::AZ::OSString,
                );
            }
            impl FindFilesRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FindFilesRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FindFilesRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FindFilesRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FindFilesRequest_MessageType()
                }
                #[inline]
                pub unsafe fn new(
                    path: *const root::AZ::OSString,
                    filter: *const root::AZ::OSString,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FindFilesRequest_FindFilesRequest(__bindgen_tmp.as_mut_ptr(), path, filter);
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FindFilesRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FindFilesRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FindFilesResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_files: root::AzFramework::AssetSystem::FindFilesResponse_FileList,
            }
            pub type FindFilesResponse_FileList =
                root::AZStd::vector<root::AZ::OSString, root::AZ::OSStdAllocator>;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FindFilesResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FindFilesResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FindFilesResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FindFilesResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FindFilesResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FindFilesResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FindFilesResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FindFilesResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FindFilesResponse@AssetSystem@AzFramework@@QEAA@IAEBV?$vector@V?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@@Z"]
                pub fn FindFilesResponse_FindFilesResponse(
                    this: *mut root::AzFramework::AssetSystem::FindFilesResponse,
                    resultCode: root::AZ::u32,
                    files: *const root::AzFramework::AssetSystem::FindFilesResponse_FileList,
                );
            }
            impl FindFilesResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FindFilesResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FindFilesResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FindFilesResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    resultCode: root::AZ::u32,
                    files: *const root::AzFramework::AssetSystem::FindFilesResponse_FileList,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FindFilesResponse_FindFilesResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        resultCode,
                        files,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FindFilesResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FindFilesResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            #[derive(Debug)]
            pub struct FileTreeRequest {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileTreeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTreeRequest_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTreeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileTreeRequest@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTreeRequest_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTreeRequest,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileTreeRequest@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileTreeRequest_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}?MessageType@FileTreeRequest@AssetSystem@AzFramework@@SAIXZ"]
                pub fn FileTreeRequest_MessageType() -> ::std::os::raw::c_uint;
            }
            impl FileTreeRequest {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileTreeRequest_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileTreeRequest_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileTreeRequest_Reflect(context)
                }
                #[inline]
                pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                    FileTreeRequest_MessageType()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileTreeRequest@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileTreeRequest_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
            #[repr(C)]
            pub struct FileTreeResponse {
                pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
                pub m_resultCode: root::AZ::u32,
                pub m_fileList: root::AzFramework::AssetSystem::FileTreeResponse_FileList,
                pub m_folderList: root::AzFramework::AssetSystem::FileTreeResponse_FolderList,
            }
            pub type FileTreeResponse_FileList =
                root::AZStd::vector<root::AZ::OSString, root::AZ::OSStdAllocator>;
            pub type FileTreeResponse_FolderList =
                root::AZStd::vector<root::AZ::OSString, root::AZ::OSStdAllocator>;
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@FileTreeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTreeResponse_TYPEINFO_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTreeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?RTTI_Enable@FileTreeResponse@AssetSystem@AzFramework@@QEAAXXZ"]
                pub fn FileTreeResponse_RTTI_Enable(
                    this: *mut root::AzFramework::AssetSystem::FileTreeResponse,
                );
            }
            extern "C" {
                #[link_name = "\u{1}?Reflect@FileTreeResponse@AssetSystem@AzFramework@@SAXPEAVReflectContext@AZ@@@Z"]
                pub fn FileTreeResponse_Reflect(context: *mut root::AZ::ReflectContext);
            }
            extern "C" {
                #[link_name = "\u{1}??0FileTreeResponse@AssetSystem@AzFramework@@QEAA@IAEBV?$vector@V?$basic_string@DU?$char_traits@D@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@V?$AZStdAlloc@VOSAllocator@AZ@@@AZ@@@AZStd@@0@Z"]
                pub fn FileTreeResponse_FileTreeResponse(
                    this: *mut root::AzFramework::AssetSystem::FileTreeResponse,
                    resultCode: root::AZ::u32,
                    files: *const root::AzFramework::AssetSystem::FileTreeResponse_FileList,
                    folders: *const root::AzFramework::AssetSystem::FileTreeResponse_FolderList,
                );
            }
            impl FileTreeResponse {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    FileTreeResponse_TYPEINFO_Enable(self)
                }
                #[inline]
                pub unsafe fn RTTI_Enable(&mut self) {
                    FileTreeResponse_RTTI_Enable(self)
                }
                #[inline]
                pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                    FileTreeResponse_Reflect(context)
                }
                #[inline]
                pub unsafe fn new(
                    resultCode: root::AZ::u32,
                    files: *const root::AzFramework::AssetSystem::FileTreeResponse_FileList,
                    folders: *const root::AzFramework::AssetSystem::FileTreeResponse_FolderList,
                ) -> Self {
                    let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                    FileTreeResponse_FileTreeResponse(
                        __bindgen_tmp.as_mut_ptr(),
                        resultCode,
                        files,
                        folders,
                    );
                    __bindgen_tmp.assume_init()
                }
            }
            extern "C" {
                #[link_name = "\u{1}?GetMessageType@FileTreeResponse@AssetSystem@AzFramework@@UEBAIXZ"]
                pub fn FileTreeResponse_GetMessageType(
                    this: *mut ::std::os::raw::c_void,
                ) -> ::std::os::raw::c_uint;
            }
        }
    }
    pub mod AssetBuilderSDK {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        pub struct AssetBuilderCommandBusTraits__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetBuilderCommandBusTraits {
            pub vtable_: *const AssetBuilderCommandBusTraits__bindgen_vtable,
        }
        pub type AssetBuilderCommandBusTraits_BusIdType = root::AZ::Uuid;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@AssetBuilderCommandBusTraits@AssetBuilderSDK@@2W4EBusAddressPolicy@AZ@@B"]
            pub static AssetBuilderCommandBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetBuilderCommandBusTraits@AssetBuilderSDK@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetBuilderCommandBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type AssetBuilderCommandBus = root::AZ::EBus;
        #[repr(C)]
        pub struct AssetBuilderBusTraits__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetBuilderBusTraits {
            pub vtable_: *const AssetBuilderBusTraits__bindgen_vtable,
        }
        pub type AssetBuilderBusTraits_MutexType = root::AZStd::recursive_mutex;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@AssetBuilderBusTraits@AssetBuilderSDK@@2W4EBusAddressPolicy@AZ@@B"]
            pub static AssetBuilderBusTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetBuilderBusTraits@AssetBuilderSDK@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetBuilderBusTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type AssetBuilderBus = root::AZ::EBus;
        #[repr(C)]
        pub struct AssetBuilderTraceTraits__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct AssetBuilderTraceTraits {
            pub vtable_: *const AssetBuilderTraceTraits__bindgen_vtable,
        }
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@AssetBuilderTraceTraits@AssetBuilderSDK@@2W4EBusAddressPolicy@AZ@@B"]
            pub static AssetBuilderTraceTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@AssetBuilderTraceTraits@AssetBuilderSDK@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static AssetBuilderTraceTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type AssetBuilderTraceBus = root::AZ::EBus;
        #[repr(C)]
        pub struct JobCommandTraits__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobCommandTraits {
            pub vtable_: *const JobCommandTraits__bindgen_vtable,
        }
        pub type JobCommandTraits_MutexType = root::AZStd::recursive_mutex;
        pub type JobCommandTraits_BusIdType = root::AZ::s64;
        extern "C" {
            #[link_name = "\u{1}?AddressPolicy@JobCommandTraits@AssetBuilderSDK@@2W4EBusAddressPolicy@AZ@@B"]
            pub static JobCommandTraits_AddressPolicy: root::AZ::EBusAddressPolicy;
        }
        extern "C" {
            #[link_name = "\u{1}?HandlerPolicy@JobCommandTraits@AssetBuilderSDK@@2W4EBusHandlerPolicy@AZ@@B"]
            pub static JobCommandTraits_HandlerPolicy: root::AZ::EBusHandlerPolicy;
        }
        pub type JobCommandBus = root::AZ::EBus;
        pub const ProductPathDependencyType_SourceFile:
            root::AssetBuilderSDK::ProductPathDependencyType = 0;
        pub const ProductPathDependencyType_ProductFile:
            root::AssetBuilderSDK::ProductPathDependencyType = 1;
        pub type ProductPathDependencyType = u32;
        #[repr(C)]
        pub struct ProductPathDependency {
            pub m_dependencyPath: root::AZStd::string,
            pub m_dependencyType: root::AssetBuilderSDK::ProductPathDependencyType,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProductPathDependency@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProductPathDependency_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProductPathDependency,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProductPathDependency@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProductPathDependency_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0ProductPathDependency@AssetBuilderSDK@@QEAA@V?$basic_string_view@DU?$char_traits@D@AZStd@@@AZStd@@W4ProductPathDependencyType@1@@Z"]
            pub fn ProductPathDependency_ProductPathDependency(
                this: *mut root::AssetBuilderSDK::ProductPathDependency,
                dependencyPath: root::AZStd::string_view,
                dependencyType: root::AssetBuilderSDK::ProductPathDependencyType,
            );
        }
        impl ProductPathDependency {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProductPathDependency_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProductPathDependency_Reflect(context)
            }
            #[inline]
            pub unsafe fn new(
                dependencyPath: root::AZStd::string_view,
                dependencyType: root::AssetBuilderSDK::ProductPathDependencyType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ProductPathDependency_ProductPathDependency(
                    __bindgen_tmp.as_mut_ptr(),
                    dependencyPath,
                    dependencyType,
                );
                __bindgen_tmp.assume_init()
            }
        }
        pub mod ComponentTags {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSubID_ID@AssetBuilderSDK@@YAII@Z"]
            pub fn GetSubID_ID(packedSubId: root::AZ::u32) -> root::AZ::u32;
        }
        extern "C" {
            #[link_name = "\u{1}?GetSubID_LOD@AssetBuilderSDK@@YAII@Z"]
            pub fn GetSubID_LOD(packedSubId: root::AZ::u32) -> root::AZ::u32;
        }
        extern "C" {
            #[link_name = "\u{1}?ConstructSubID@AssetBuilderSDK@@YAIIII@Z"]
            pub fn ConstructSubID(
                subIndex: root::AZ::u32,
                lodLevel: root::AZ::u32,
                fromSubIndex: root::AZ::u32,
            ) -> root::AZ::u32;
        }
        extern "C" {
            #[link_name = "\u{1}?InitializeSerializationContext@AssetBuilderSDK@@YAXXZ"]
            pub fn InitializeSerializationContext();
        }
        extern "C" {
            #[link_name = "\u{1}?BuilderLog@AssetBuilderSDK@@YAXUUuid@AZ@@PEBDZZ"]
            pub fn BuilderLog(
                builderId: root::AZ::Uuid,
                message: *const ::std::os::raw::c_char,
                ...
            );
        }
        pub const Platform_Platform_NONE: root::AssetBuilderSDK::Platform = 0;
        pub const Platform_Platform_PC: root::AssetBuilderSDK::Platform = 1;
        pub const Platform_Platform_ES3: root::AssetBuilderSDK::Platform = 2;
        pub const Platform_Platform_IOS: root::AssetBuilderSDK::Platform = 4;
        pub const Platform_Platform_OSX: root::AssetBuilderSDK::Platform = 8;
        pub const Platform_Platform_XBOXONE: root::AssetBuilderSDK::Platform = 16;
        pub const Platform_Platform_PS4: root::AssetBuilderSDK::Platform = 32;
        pub const Platform_AllPlatforms: root::AssetBuilderSDK::Platform = 63;
        pub type Platform = u32;
        pub type JobParameterMap = root::AZStd::unordered_map;
        pub type CreateJobFunction = [u64; 5usize];
        pub type ProcessJobFunction = [u64; 5usize];
        #[repr(C)]
        pub struct AssetBuilderPattern {
            pub m_pattern: root::AZStd::string,
            pub m_type: root::AssetBuilderSDK::AssetBuilderPattern_PatternType,
        }
        pub const AssetBuilderPattern_PatternType_Wildcard:
            root::AssetBuilderSDK::AssetBuilderPattern_PatternType = 0;
        pub const AssetBuilderPattern_PatternType_Regex:
            root::AssetBuilderSDK::AssetBuilderPattern_PatternType = 1;
        pub type AssetBuilderPattern_PatternType = i32;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@AssetBuilderPattern@AssetBuilderSDK@@QEAAXXZ"]
            pub fn AssetBuilderPattern_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::AssetBuilderPattern,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@AssetBuilderPattern@AssetBuilderSDK@@QEBA?AV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@XZ"]
            pub fn AssetBuilderPattern_ToString(
                this: *const root::AssetBuilderSDK::AssetBuilderPattern,
            ) -> root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@AssetBuilderPattern@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn AssetBuilderPattern_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0AssetBuilderPattern@AssetBuilderSDK@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@W4PatternType@01@@Z"]
            pub fn AssetBuilderPattern_AssetBuilderPattern(
                this: *mut root::AssetBuilderSDK::AssetBuilderPattern,
                pattern: *const root::AZStd::string,
                type_: root::AssetBuilderSDK::AssetBuilderPattern_PatternType,
            );
        }
        impl AssetBuilderPattern {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                AssetBuilderPattern_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn ToString(&self) -> root::AZStd::string {
                AssetBuilderPattern_ToString(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                AssetBuilderPattern_Reflect(context)
            }
            #[inline]
            pub unsafe fn new(
                pattern: *const root::AZStd::string,
                type_: root::AssetBuilderSDK::AssetBuilderPattern_PatternType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AssetBuilderPattern_AssetBuilderPattern(__bindgen_tmp.as_mut_ptr(), pattern, type_);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct FilePatternMatcher {
            pub m_pattern: root::AssetBuilderSDK::AssetBuilderPattern,
            pub m_regex: root::AssetBuilderSDK::FilePatternMatcher_RegexType,
            pub m_errorString: root::AZStd::string,
            pub m_isRegex: bool,
            pub m_isValid: bool,
        }
        pub type FilePatternMatcher_RegexType = root::AZStd::regex;
        extern "C" {
            #[link_name = "\u{1}?MatchesPath@FilePatternMatcher@AssetBuilderSDK@@QEBA_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@Z"]
            pub fn FilePatternMatcher_MatchesPath(
                this: *const root::AssetBuilderSDK::FilePatternMatcher,
                assetPath: *const root::AZStd::string,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsValid@FilePatternMatcher@AssetBuilderSDK@@QEBA_NXZ"]
            pub fn FilePatternMatcher_IsValid(
                this: *const root::AssetBuilderSDK::FilePatternMatcher,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetErrorString@FilePatternMatcher@AssetBuilderSDK@@QEBA?AV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@XZ"]
            pub fn FilePatternMatcher_GetErrorString(
                this: *const root::AssetBuilderSDK::FilePatternMatcher,
            ) -> root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}?GetBuilderPattern@FilePatternMatcher@AssetBuilderSDK@@QEBAAEBUAssetBuilderPattern@2@XZ"]
            pub fn FilePatternMatcher_GetBuilderPattern(
                this: *const root::AssetBuilderSDK::FilePatternMatcher,
            ) -> *const root::AssetBuilderSDK::AssetBuilderPattern;
        }
        extern "C" {
            #[link_name = "\u{1}?ValidatePatternRegex@FilePatternMatcher@AssetBuilderSDK@@KA_NAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@AEAV34@@Z"]
            pub fn FilePatternMatcher_ValidatePatternRegex(
                pattern: *const root::AZStd::string,
                errorString: *mut root::AZStd::string,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0FilePatternMatcher@AssetBuilderSDK@@QEAA@AEBUAssetBuilderPattern@1@@Z"]
            pub fn FilePatternMatcher_FilePatternMatcher(
                this: *mut root::AssetBuilderSDK::FilePatternMatcher,
                pattern: *const root::AssetBuilderSDK::AssetBuilderPattern,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0FilePatternMatcher@AssetBuilderSDK@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@W4PatternType@AssetBuilderPattern@1@@Z"]
            pub fn FilePatternMatcher_FilePatternMatcher1(
                this: *mut root::AssetBuilderSDK::FilePatternMatcher,
                pattern: *const root::AZStd::string,
                type_: root::AssetBuilderSDK::AssetBuilderPattern_PatternType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0FilePatternMatcher@AssetBuilderSDK@@QEAA@AEBV01@@Z"]
            pub fn FilePatternMatcher_FilePatternMatcher2(
                this: *mut root::AssetBuilderSDK::FilePatternMatcher,
                copy: *const root::AssetBuilderSDK::FilePatternMatcher,
            );
        }
        impl FilePatternMatcher {
            #[inline]
            pub unsafe fn MatchesPath(&self, assetPath: *const root::AZStd::string) -> bool {
                FilePatternMatcher_MatchesPath(self, assetPath)
            }
            #[inline]
            pub unsafe fn IsValid(&self) -> bool {
                FilePatternMatcher_IsValid(self)
            }
            #[inline]
            pub unsafe fn GetErrorString(&self) -> root::AZStd::string {
                FilePatternMatcher_GetErrorString(self)
            }
            #[inline]
            pub unsafe fn GetBuilderPattern(
                &self,
            ) -> *const root::AssetBuilderSDK::AssetBuilderPattern {
                FilePatternMatcher_GetBuilderPattern(self)
            }
            #[inline]
            pub unsafe fn ValidatePatternRegex(
                pattern: *const root::AZStd::string,
                errorString: *mut root::AZStd::string,
            ) -> bool {
                FilePatternMatcher_ValidatePatternRegex(pattern, errorString)
            }
            #[inline]
            pub unsafe fn new(pattern: *const root::AssetBuilderSDK::AssetBuilderPattern) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                FilePatternMatcher_FilePatternMatcher(__bindgen_tmp.as_mut_ptr(), pattern);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                pattern: *const root::AZStd::string,
                type_: root::AssetBuilderSDK::AssetBuilderPattern_PatternType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                FilePatternMatcher_FilePatternMatcher1(__bindgen_tmp.as_mut_ptr(), pattern, type_);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(copy: *const root::AssetBuilderSDK::FilePatternMatcher) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                FilePatternMatcher_FilePatternMatcher2(__bindgen_tmp.as_mut_ptr(), copy);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct AssetBuilderDesc {
            pub m_name: root::AZStd::string,
            pub m_patterns: root::AZStd::vector<
                root::AssetBuilderSDK::AssetBuilderPattern,
                root::AZStd::allocator,
            >,
            pub __bindgen_padding_0: u64,
            pub m_busId: root::AZ::Uuid,
            pub m_version: ::std::os::raw::c_int,
            pub m_createJobFunction: root::AssetBuilderSDK::CreateJobFunction,
            pub m_processJobFunction: root::AssetBuilderSDK::ProcessJobFunction,
            pub m_builderType: root::AssetBuilderSDK::AssetBuilderDesc_AssetBuilderType,
            pub m_analysisFingerprint: root::AZStd::string,
            pub m_flags: root::AZ::u8,
            pub __bindgen_padding_1: [u8; 7usize],
        }
        pub const AssetBuilderDesc_AssetBuilderType_Internal:
            root::AssetBuilderSDK::AssetBuilderDesc_AssetBuilderType = 0;
        pub const AssetBuilderDesc_AssetBuilderType_External:
            root::AssetBuilderSDK::AssetBuilderDesc_AssetBuilderType = 1;
        pub type AssetBuilderDesc_AssetBuilderType = i32;
        pub const AssetBuilderDesc_BuilderFlags_BF_None:
            root::AssetBuilderSDK::AssetBuilderDesc_BuilderFlags = 0;
        pub const AssetBuilderDesc_BuilderFlags_BF_EmitsNoDependencies:
            root::AssetBuilderSDK::AssetBuilderDesc_BuilderFlags = 1;
        pub type AssetBuilderDesc_BuilderFlags = u8;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@AssetBuilderDesc@AssetBuilderSDK@@QEAAXXZ"]
            pub fn AssetBuilderDesc_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::AssetBuilderDesc,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?IsExternalBuilder@AssetBuilderDesc@AssetBuilderSDK@@QEBA_NXZ"]
            pub fn AssetBuilderDesc_IsExternalBuilder(
                this: *const root::AssetBuilderSDK::AssetBuilderDesc,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@AssetBuilderDesc@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn AssetBuilderDesc_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl AssetBuilderDesc {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                AssetBuilderDesc_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn IsExternalBuilder(&self) -> bool {
                AssetBuilderDesc_IsExternalBuilder(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                AssetBuilderDesc_Reflect(context)
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct SourceFileDependency {
            pub m_sourceFileDependencyPath: root::AZStd::string,
            pub __bindgen_padding_0: u64,
            pub m_sourceFileDependencyUUID: root::AZ::Uuid,
            pub m_sourceDependencyType:
                root::AssetBuilderSDK::SourceFileDependency_SourceFileDependencyType,
            pub __bindgen_padding_1: [u32; 3usize],
        }
        pub const SourceFileDependency_SourceFileDependencyType_Absolute:
            root::AssetBuilderSDK::SourceFileDependency_SourceFileDependencyType = 0;
        pub const SourceFileDependency_SourceFileDependencyType_Wildcards:
            root::AssetBuilderSDK::SourceFileDependency_SourceFileDependencyType = 1;
        pub type SourceFileDependency_SourceFileDependencyType = u32;
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@SourceFileDependency@AssetBuilderSDK@@QEAAXXZ"]
            pub fn SourceFileDependency_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::SourceFileDependency,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?ToString@SourceFileDependency@AssetBuilderSDK@@QEBA?AV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@XZ"]
            pub fn SourceFileDependency_ToString(
                this: *const root::AssetBuilderSDK::SourceFileDependency,
            ) -> root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@SourceFileDependency@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn SourceFileDependency_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl SourceFileDependency {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                SourceFileDependency_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn ToString(&self) -> root::AZStd::string {
                SourceFileDependency_ToString(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                SourceFileDependency_Reflect(context)
            }
        }
        pub const JobDependencyType_Fingerprint: root::AssetBuilderSDK::JobDependencyType = 0;
        pub const JobDependencyType_Order: root::AssetBuilderSDK::JobDependencyType = 1;
        pub type JobDependencyType = u32;
        #[repr(C)]
        #[repr(align(16))]
        pub struct JobDependency {
            pub m_sourceFile: root::AssetBuilderSDK::SourceFileDependency,
            pub m_jobKey: root::AZStd::string,
            pub m_platformIdentifier: root::AZStd::string,
            pub m_type: root::AssetBuilderSDK::JobDependencyType,
            pub __bindgen_padding_0: [u32; 3usize],
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@JobDependency@AssetBuilderSDK@@QEAAXXZ"]
            pub fn JobDependency_TYPEINFO_Enable(this: *mut root::AssetBuilderSDK::JobDependency);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@JobDependency@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn JobDependency_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0JobDependency@AssetBuilderSDK@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@0AEBW4JobDependencyType@1@AEBUSourceFileDependency@1@@Z"]
            pub fn JobDependency_JobDependency(
                this: *mut root::AssetBuilderSDK::JobDependency,
                jobKey: *const root::AZStd::string,
                platformIdentifier: *const root::AZStd::string,
                type_: *const root::AssetBuilderSDK::JobDependencyType,
                sourceFile: *const root::AssetBuilderSDK::SourceFileDependency,
            );
        }
        impl JobDependency {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                JobDependency_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                JobDependency_Reflect(context)
            }
            #[inline]
            pub unsafe fn new(
                jobKey: *const root::AZStd::string,
                platformIdentifier: *const root::AZStd::string,
                type_: *const root::AssetBuilderSDK::JobDependencyType,
                sourceFile: *const root::AssetBuilderSDK::SourceFileDependency,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobDependency_JobDependency(
                    __bindgen_tmp.as_mut_ptr(),
                    jobKey,
                    platformIdentifier,
                    type_,
                    sourceFile,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct JobDescriptor {
            pub m_jobParameters: root::AssetBuilderSDK::JobParameterMap,
            pub m_additionalFingerprintInfo: root::AZStd::string,
            pub m_jobKey: root::AZStd::string,
            pub m_platform: ::std::os::raw::c_int,
            pub m_priority: ::std::os::raw::c_int,
            pub m_critical: bool,
            pub m_checkExclusiveLock: bool,
            pub m_checkServer: bool,
            pub m_jobDependencyList:
                root::AZStd::vector<root::AssetBuilderSDK::JobDependency, root::AZStd::allocator>,
            pub m_failOnError: bool,
            pub m_platformIdentifier: root::AZStd::string,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@JobDescriptor@AssetBuilderSDK@@QEAAXXZ"]
            pub fn JobDescriptor_TYPEINFO_Enable(this: *mut root::AssetBuilderSDK::JobDescriptor);
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@JobDescriptor@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn JobDescriptor_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?SetPlatformIdentifier@JobDescriptor@AssetBuilderSDK@@QEAAXPEBD@Z"]
            pub fn JobDescriptor_SetPlatformIdentifier(
                this: *mut root::AssetBuilderSDK::JobDescriptor,
                platformIdentifier: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?GetPlatformIdentifier@JobDescriptor@AssetBuilderSDK@@QEBAAEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@XZ"]
            pub fn JobDescriptor_GetPlatformIdentifier(
                this: *const root::AssetBuilderSDK::JobDescriptor,
            ) -> *const root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}??0JobDescriptor@AssetBuilderSDK@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@V23@PEBD@Z"]
            pub fn JobDescriptor_JobDescriptor(
                this: *mut root::AssetBuilderSDK::JobDescriptor,
                additionalFingerprintInfo: *const root::AZStd::string,
                jobKey: root::AZStd::string,
                platformIdentifier: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0JobDescriptor@AssetBuilderSDK@@QEAA@V?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@HAEBV23@@Z"]
            pub fn JobDescriptor_JobDescriptor1(
                this: *mut root::AssetBuilderSDK::JobDescriptor,
                additionalFingerprintInfo: root::AZStd::string,
                platform: ::std::os::raw::c_int,
                jobKey: *const root::AZStd::string,
            );
        }
        impl JobDescriptor {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                JobDescriptor_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                JobDescriptor_Reflect(context)
            }
            #[inline]
            pub unsafe fn SetPlatformIdentifier(
                &mut self,
                platformIdentifier: *const ::std::os::raw::c_char,
            ) {
                JobDescriptor_SetPlatformIdentifier(self, platformIdentifier)
            }
            #[inline]
            pub unsafe fn GetPlatformIdentifier(&self) -> *const root::AZStd::string {
                JobDescriptor_GetPlatformIdentifier(self)
            }
            #[inline]
            pub unsafe fn new(
                additionalFingerprintInfo: *const root::AZStd::string,
                jobKey: root::AZStd::string,
                platformIdentifier: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobDescriptor_JobDescriptor(
                    __bindgen_tmp.as_mut_ptr(),
                    additionalFingerprintInfo,
                    jobKey,
                    platformIdentifier,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                additionalFingerprintInfo: root::AZStd::string,
                platform: ::std::os::raw::c_int,
                jobKey: *const root::AZStd::string,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobDescriptor_JobDescriptor1(
                    __bindgen_tmp.as_mut_ptr(),
                    additionalFingerprintInfo,
                    platform,
                    jobKey,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct RegisterBuilderRequest {
            pub m_filePath: root::AZStd::string,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@RegisterBuilderRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn RegisterBuilderRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::RegisterBuilderRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@RegisterBuilderRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn RegisterBuilderRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl RegisterBuilderRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                RegisterBuilderRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                RegisterBuilderRequest_Reflect(context)
            }
        }
        #[repr(C)]
        pub struct RegisterBuilderResponse {
            pub m_assetBuilderDescList: root::AZStd::vector<
                root::AssetBuilderSDK::AssetBuilderDesc,
                root::AZStd::allocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@RegisterBuilderResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn RegisterBuilderResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::RegisterBuilderResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@RegisterBuilderResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn RegisterBuilderResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl RegisterBuilderResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                RegisterBuilderResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                RegisterBuilderResponse_Reflect(context)
            }
        }
        #[repr(C)]
        pub struct PlatformInfo {
            pub m_identifier: root::AZStd::string,
            pub m_tags: root::AZStd::unordered_set,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@PlatformInfo@AssetBuilderSDK@@QEAAXXZ"]
            pub fn PlatformInfo_TYPEINFO_Enable(this: *mut root::AssetBuilderSDK::PlatformInfo);
        }
        extern "C" {
            #[link_name = "\u{1}?HasTag@PlatformInfo@AssetBuilderSDK@@QEBA_NPEBD@Z"]
            pub fn PlatformInfo_HasTag(
                this: *const root::AssetBuilderSDK::PlatformInfo,
                tag: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@PlatformInfo@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn PlatformInfo_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?PlatformVectorAsString@PlatformInfo@AssetBuilderSDK@@SA?AV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@AEBV?$vector@UPlatformInfo@AssetBuilderSDK@@Vallocator@AZStd@@@4@@Z"]
            pub fn PlatformInfo_PlatformVectorAsString(
                platforms: *const root::AZStd::vector<
                    root::AssetBuilderSDK::PlatformInfo,
                    root::AZStd::allocator,
                >,
            ) -> root::AZStd::string;
        }
        extern "C" {
            #[link_name = "\u{1}??0PlatformInfo@AssetBuilderSDK@@QEAA@PEBDAEBV?$unordered_set@V?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@U?$hash@V?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@2@U?$equal_to@V?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@@2@Vallocator@2@@AZStd@@@Z"]
            pub fn PlatformInfo_PlatformInfo(
                this: *mut root::AssetBuilderSDK::PlatformInfo,
                identifier: *const ::std::os::raw::c_char,
                tags: *const root::AZStd::unordered_set,
            );
        }
        impl PlatformInfo {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                PlatformInfo_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn HasTag(&self, tag: *const ::std::os::raw::c_char) -> bool {
                PlatformInfo_HasTag(self, tag)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                PlatformInfo_Reflect(context)
            }
            #[inline]
            pub unsafe fn PlatformVectorAsString(
                platforms: *const root::AZStd::vector<
                    root::AssetBuilderSDK::PlatformInfo,
                    root::AZStd::allocator,
                >,
            ) -> root::AZStd::string {
                PlatformInfo_PlatformVectorAsString(platforms)
            }
            #[inline]
            pub unsafe fn new(
                identifier: *const ::std::os::raw::c_char,
                tags: *const root::AZStd::unordered_set,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                PlatformInfo_PlatformInfo(__bindgen_tmp.as_mut_ptr(), identifier, tags);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct CreateJobsRequest {
            pub m_builderid: root::AZ::Uuid,
            pub m_watchFolder: root::AZStd::string,
            pub m_sourceFile: root::AZStd::string,
            pub m_sourceFileUUID: root::AZ::Uuid,
            pub m_enabledPlatforms:
                root::AZStd::vector<root::AssetBuilderSDK::PlatformInfo, root::AZStd::allocator>,
            pub m_platformFlags: ::std::os::raw::c_int,
            pub __bindgen_padding_0: [u32; 3usize],
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@CreateJobsRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?HasPlatform@CreateJobsRequest@AssetBuilderSDK@@QEBA_NPEBD@Z"]
            pub fn CreateJobsRequest_HasPlatform(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
                platformIdentifier: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?HasPlatformWithTag@CreateJobsRequest@AssetBuilderSDK@@QEBA_NPEBD@Z"]
            pub fn CreateJobsRequest_HasPlatformWithTag(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
                platformTag: *const ::std::os::raw::c_char,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?GetEnabledPlatformsCount@CreateJobsRequest@AssetBuilderSDK@@QEBA_KXZ"]
            pub fn CreateJobsRequest_GetEnabledPlatformsCount(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
            ) -> usize;
        }
        extern "C" {
            #[link_name = "\u{1}?GetEnabledPlatformAt@CreateJobsRequest@AssetBuilderSDK@@QEBA?AW4Platform@2@_K@Z"]
            pub fn CreateJobsRequest_GetEnabledPlatformAt(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
                index: usize,
            ) -> root::AssetBuilderSDK::Platform;
        }
        extern "C" {
            #[link_name = "\u{1}?IsPlatformEnabled@CreateJobsRequest@AssetBuilderSDK@@QEBA_NI@Z"]
            pub fn CreateJobsRequest_IsPlatformEnabled(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
                platform: root::AZ::u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?IsPlatformValid@CreateJobsRequest@AssetBuilderSDK@@QEBA_NI@Z"]
            pub fn CreateJobsRequest_IsPlatformValid(
                this: *const root::AssetBuilderSDK::CreateJobsRequest,
                platform: root::AZ::u32,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@CreateJobsRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn CreateJobsRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0CreateJobsRequest@AssetBuilderSDK@@QEAA@XZ"]
            pub fn CreateJobsRequest_CreateJobsRequest(
                this: *mut root::AssetBuilderSDK::CreateJobsRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0CreateJobsRequest@AssetBuilderSDK@@QEAA@UUuid@AZ@@V?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@1AEBV?$vector@UPlatformInfo@AssetBuilderSDK@@Vallocator@AZStd@@@5@AEBU23@@Z"]
            pub fn CreateJobsRequest_CreateJobsRequest1(
                this: *mut root::AssetBuilderSDK::CreateJobsRequest,
                builderid: root::AZ::Uuid,
                sourceFile: root::AZStd::string,
                watchFolder: root::AZStd::string,
                enabledPlatforms: *const root::AZStd::vector<
                    root::AssetBuilderSDK::PlatformInfo,
                    root::AZStd::allocator,
                >,
                sourceFileUuid: *const root::AZ::Uuid,
            );
        }
        impl CreateJobsRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                CreateJobsRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn HasPlatform(
                &self,
                platformIdentifier: *const ::std::os::raw::c_char,
            ) -> bool {
                CreateJobsRequest_HasPlatform(self, platformIdentifier)
            }
            #[inline]
            pub unsafe fn HasPlatformWithTag(
                &self,
                platformTag: *const ::std::os::raw::c_char,
            ) -> bool {
                CreateJobsRequest_HasPlatformWithTag(self, platformTag)
            }
            #[inline]
            pub unsafe fn GetEnabledPlatformsCount(&self) -> usize {
                CreateJobsRequest_GetEnabledPlatformsCount(self)
            }
            #[inline]
            pub unsafe fn GetEnabledPlatformAt(
                &self,
                index: usize,
            ) -> root::AssetBuilderSDK::Platform {
                CreateJobsRequest_GetEnabledPlatformAt(self, index)
            }
            #[inline]
            pub unsafe fn IsPlatformEnabled(&self, platform: root::AZ::u32) -> bool {
                CreateJobsRequest_IsPlatformEnabled(self, platform)
            }
            #[inline]
            pub unsafe fn IsPlatformValid(&self, platform: root::AZ::u32) -> bool {
                CreateJobsRequest_IsPlatformValid(self, platform)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                CreateJobsRequest_Reflect(context)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CreateJobsRequest_CreateJobsRequest(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                builderid: root::AZ::Uuid,
                sourceFile: root::AZStd::string,
                watchFolder: root::AZStd::string,
                enabledPlatforms: *const root::AZStd::vector<
                    root::AssetBuilderSDK::PlatformInfo,
                    root::AZStd::allocator,
                >,
                sourceFileUuid: *const root::AZ::Uuid,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                CreateJobsRequest_CreateJobsRequest1(
                    __bindgen_tmp.as_mut_ptr(),
                    builderid,
                    sourceFile,
                    watchFolder,
                    enabledPlatforms,
                    sourceFileUuid,
                );
                __bindgen_tmp.assume_init()
            }
        }
        pub const CreateJobsResultCode_Success: root::AssetBuilderSDK::CreateJobsResultCode = 0;
        pub const CreateJobsResultCode_Failed: root::AssetBuilderSDK::CreateJobsResultCode = 1;
        pub const CreateJobsResultCode_ShuttingDown: root::AssetBuilderSDK::CreateJobsResultCode =
            2;
        pub type CreateJobsResultCode = i32;
        #[repr(C)]
        pub struct CreateJobsResponse {
            pub m_result: root::AssetBuilderSDK::CreateJobsResultCode,
            pub m_sourceFileDependencyList: root::AZStd::vector<
                root::AssetBuilderSDK::SourceFileDependency,
                root::AZStd::allocator,
            >,
            pub m_createJobOutputs:
                root::AZStd::vector<root::AssetBuilderSDK::JobDescriptor, root::AZStd::allocator>,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@CreateJobsResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Succeeded@CreateJobsResponse@AssetBuilderSDK@@QEBA_NXZ"]
            pub fn CreateJobsResponse_Succeeded(
                this: *const root::AssetBuilderSDK::CreateJobsResponse,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@CreateJobsResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn CreateJobsResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl CreateJobsResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                CreateJobsResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Succeeded(&self) -> bool {
                CreateJobsResponse_Succeeded(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                CreateJobsResponse_Reflect(context)
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct ProductDependency {
            pub m_dependencyId: root::AZ::Data::AssetId,
            pub m_flags: [u32; 2usize],
            pub __bindgen_padding_0: u64,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProductDependency@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProductDependency_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProductDependency,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProductDependency@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProductDependency_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0ProductDependency@AssetBuilderSDK@@QEAA@UAssetId@Data@AZ@@AEBV?$bitset@$0EA@@AZStd@@@Z"]
            pub fn ProductDependency_ProductDependency(
                this: *mut root::AssetBuilderSDK::ProductDependency,
                dependencyId: root::AZ::Data::AssetId,
                flags: *const [u32; 2usize],
            );
        }
        impl ProductDependency {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProductDependency_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProductDependency_Reflect(context)
            }
            #[inline]
            pub unsafe fn new(
                dependencyId: root::AZ::Data::AssetId,
                flags: *const [u32; 2usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ProductDependency_ProductDependency(
                    __bindgen_tmp.as_mut_ptr(),
                    dependencyId,
                    flags,
                );
                __bindgen_tmp.assume_init()
            }
        }
        pub type ProductPathDependencySet = root::AZStd::unordered_set;
        #[repr(C)]
        #[repr(align(16))]
        pub struct JobProduct {
            pub m_productFileName: root::AZStd::string,
            pub __bindgen_padding_0: u64,
            pub m_productAssetType: root::AZ::Data::AssetType,
            pub m_productSubID: root::AZ::u32,
            pub m_legacySubIDs: root::AZStd::vector<root::AZ::u32, root::AZStd::allocator>,
            pub m_dependencies: root::AZStd::vector<
                root::AssetBuilderSDK::ProductDependency,
                root::AZStd::allocator,
            >,
            pub m_pathDependencies: root::AssetBuilderSDK::ProductPathDependencySet,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@JobProduct@AssetBuilderSDK@@QEAAXXZ"]
            pub fn JobProduct_TYPEINFO_Enable(this: *mut root::AssetBuilderSDK::JobProduct);
        }
        extern "C" {
            #[link_name = "\u{1}?InferAssetTypeByProductFileName@JobProduct@AssetBuilderSDK@@SA?AUUuid@AZ@@PEBD@Z"]
            pub fn JobProduct_InferAssetTypeByProductFileName(
                productFile: *const ::std::os::raw::c_char,
            ) -> root::AZ::Data::AssetType;
        }
        extern "C" {
            #[link_name = "\u{1}?InferSubIDFromProductFileName@JobProduct@AssetBuilderSDK@@SAIAEBUUuid@AZ@@PEBD@Z"]
            pub fn JobProduct_InferSubIDFromProductFileName(
                assetType: *const root::AZ::Data::AssetType,
                productFile: *const ::std::os::raw::c_char,
            ) -> root::AZ::u32;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@JobProduct@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn JobProduct_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}??0JobProduct@AssetBuilderSDK@@QEAA@AEBV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@UUuid@AZ@@I@Z"]
            pub fn JobProduct_JobProduct(
                this: *mut root::AssetBuilderSDK::JobProduct,
                productName: *const root::AZStd::string,
                productAssetType: root::AZ::Data::AssetType,
                productSubID: root::AZ::u32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}??0JobProduct@AssetBuilderSDK@@QEAA@$$QEAV?$basic_string@DU?$char_traits@D@AZStd@@Vallocator@2@@AZStd@@UUuid@AZ@@I@Z"]
            pub fn JobProduct_JobProduct1(
                this: *mut root::AssetBuilderSDK::JobProduct,
                productName: *mut root::AZStd::string,
                productAssetType: root::AZ::Data::AssetType,
                productSubID: root::AZ::u32,
            );
        }
        impl JobProduct {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                JobProduct_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn InferAssetTypeByProductFileName(
                productFile: *const ::std::os::raw::c_char,
            ) -> root::AZ::Data::AssetType {
                JobProduct_InferAssetTypeByProductFileName(productFile)
            }
            #[inline]
            pub unsafe fn InferSubIDFromProductFileName(
                assetType: *const root::AZ::Data::AssetType,
                productFile: *const ::std::os::raw::c_char,
            ) -> root::AZ::u32 {
                JobProduct_InferSubIDFromProductFileName(assetType, productFile)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                JobProduct_Reflect(context)
            }
            #[inline]
            pub unsafe fn new(
                productName: *const root::AZStd::string,
                productAssetType: root::AZ::Data::AssetType,
                productSubID: root::AZ::u32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobProduct_JobProduct(
                    __bindgen_tmp.as_mut_ptr(),
                    productName,
                    productAssetType,
                    productSubID,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                productName: *mut root::AZStd::string,
                productAssetType: root::AZ::Data::AssetType,
                productSubID: root::AZ::u32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobProduct_JobProduct1(
                    __bindgen_tmp.as_mut_ptr(),
                    productName,
                    productAssetType,
                    productSubID,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct ProcessJobRequest {
            pub m_sourceFile: root::AZStd::string,
            pub m_watchFolder: root::AZStd::string,
            pub m_fullPath: root::AZStd::string,
            pub __bindgen_padding_0: u64,
            pub m_builderGuid: root::AZ::Uuid,
            pub m_jobDescription: root::AssetBuilderSDK::JobDescriptor,
            pub m_platformInfo: root::AssetBuilderSDK::PlatformInfo,
            pub m_tempDirPath: root::AZStd::string,
            pub m_jobId: root::AZ::u64,
            pub __bindgen_padding_1: u64,
            pub m_sourceFileUUID: root::AZ::Uuid,
            pub m_sourceFileDependencyList: root::AZStd::vector<
                root::AssetBuilderSDK::SourceFileDependency,
                root::AZStd::allocator,
            >,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProcessJobRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProcessJobRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProcessJobRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl ProcessJobRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProcessJobRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProcessJobRequest_Reflect(context)
            }
        }
        pub const ProcessJobResultCode_ProcessJobResult_Success:
            root::AssetBuilderSDK::ProcessJobResultCode = 0;
        pub const ProcessJobResultCode_ProcessJobResult_Failed:
            root::AssetBuilderSDK::ProcessJobResultCode = 1;
        pub const ProcessJobResultCode_ProcessJobResult_Crashed:
            root::AssetBuilderSDK::ProcessJobResultCode = 2;
        pub const ProcessJobResultCode_ProcessJobResult_Cancelled:
            root::AssetBuilderSDK::ProcessJobResultCode = 3;
        pub type ProcessJobResultCode = i32;
        #[repr(C)]
        pub struct ProcessJobResponse {
            pub m_resultCode: root::AssetBuilderSDK::ProcessJobResultCode,
            pub m_outputProducts:
                root::AZStd::vector<root::AssetBuilderSDK::JobProduct, root::AZStd::allocator>,
            pub m_requiresSubIdGeneration: bool,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProcessJobResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Succeeded@ProcessJobResponse@AssetBuilderSDK@@QEBA_NXZ"]
            pub fn ProcessJobResponse_Succeeded(
                this: *const root::AssetBuilderSDK::ProcessJobResponse,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProcessJobResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProcessJobResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl ProcessJobResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProcessJobResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn Succeeded(&self) -> bool {
                ProcessJobResponse_Succeeded(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProcessJobResponse_Reflect(context)
            }
        }
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug)]
        pub struct BuilderHelloRequest {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_uuid: root::AZ::Uuid,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@BuilderHelloRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn BuilderHelloRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::BuilderHelloRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@BuilderHelloRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn BuilderHelloRequest_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::BuilderHelloRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@BuilderHelloRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn BuilderHelloRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?MessageType@BuilderHelloRequest@AssetBuilderSDK@@SAIXZ"]
            pub fn BuilderHelloRequest_MessageType() -> ::std::os::raw::c_uint;
        }
        impl BuilderHelloRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                BuilderHelloRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                BuilderHelloRequest_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                BuilderHelloRequest_Reflect(context)
            }
            #[inline]
            pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                BuilderHelloRequest_MessageType()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@BuilderHelloRequest@AssetBuilderSDK@@UEBAIXZ"]
            pub fn BuilderHelloRequest_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        #[repr(align(16))]
        #[derive(Debug)]
        pub struct BuilderHelloResponse {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_accepted: bool,
            pub __bindgen_padding_0: u64,
            pub m_uuid: root::AZ::Uuid,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@BuilderHelloResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn BuilderHelloResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::BuilderHelloResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@BuilderHelloResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn BuilderHelloResponse_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::BuilderHelloResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@BuilderHelloResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn BuilderHelloResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl BuilderHelloResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                BuilderHelloResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                BuilderHelloResponse_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                BuilderHelloResponse_Reflect(context)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@BuilderHelloResponse@AssetBuilderSDK@@UEBAIXZ"]
            pub fn BuilderHelloResponse_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct CreateJobsNetRequest {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_request: root::AssetBuilderSDK::CreateJobsRequest,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@CreateJobsNetRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsNetRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsNetRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@CreateJobsNetRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsNetRequest_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsNetRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@CreateJobsNetRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn CreateJobsNetRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?MessageType@CreateJobsNetRequest@AssetBuilderSDK@@SAIXZ"]
            pub fn CreateJobsNetRequest_MessageType() -> ::std::os::raw::c_uint;
        }
        impl CreateJobsNetRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                CreateJobsNetRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                CreateJobsNetRequest_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                CreateJobsNetRequest_Reflect(context)
            }
            #[inline]
            pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                CreateJobsNetRequest_MessageType()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@CreateJobsNetRequest@AssetBuilderSDK@@UEBAIXZ"]
            pub fn CreateJobsNetRequest_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        pub struct CreateJobsNetResponse {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_response: root::AssetBuilderSDK::CreateJobsResponse,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@CreateJobsNetResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsNetResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsNetResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@CreateJobsNetResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn CreateJobsNetResponse_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::CreateJobsNetResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@CreateJobsNetResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn CreateJobsNetResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl CreateJobsNetResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                CreateJobsNetResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                CreateJobsNetResponse_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                CreateJobsNetResponse_Reflect(context)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@CreateJobsNetResponse@AssetBuilderSDK@@UEBAIXZ"]
            pub fn CreateJobsNetResponse_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        #[repr(align(16))]
        pub struct ProcessJobNetRequest {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_request: root::AssetBuilderSDK::ProcessJobRequest,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProcessJobNetRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobNetRequest_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobNetRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@ProcessJobNetRequest@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobNetRequest_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobNetRequest,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProcessJobNetRequest@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProcessJobNetRequest_Reflect(context: *mut root::AZ::ReflectContext);
        }
        extern "C" {
            #[link_name = "\u{1}?MessageType@ProcessJobNetRequest@AssetBuilderSDK@@SAIXZ"]
            pub fn ProcessJobNetRequest_MessageType() -> ::std::os::raw::c_uint;
        }
        impl ProcessJobNetRequest {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProcessJobNetRequest_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                ProcessJobNetRequest_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProcessJobNetRequest_Reflect(context)
            }
            #[inline]
            pub unsafe fn MessageType() -> ::std::os::raw::c_uint {
                ProcessJobNetRequest_MessageType()
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@ProcessJobNetRequest@AssetBuilderSDK@@UEBAIXZ"]
            pub fn ProcessJobNetRequest_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        pub struct ProcessJobNetResponse {
            pub _base: root::AzFramework::AssetSystem::BaseAssetProcessorMessage,
            pub m_response: root::AssetBuilderSDK::ProcessJobResponse,
        }
        extern "C" {
            #[link_name = "\u{1}?TYPEINFO_Enable@ProcessJobNetResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobNetResponse_TYPEINFO_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobNetResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?RTTI_Enable@ProcessJobNetResponse@AssetBuilderSDK@@QEAAXXZ"]
            pub fn ProcessJobNetResponse_RTTI_Enable(
                this: *mut root::AssetBuilderSDK::ProcessJobNetResponse,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Reflect@ProcessJobNetResponse@AssetBuilderSDK@@SAXPEAVReflectContext@AZ@@@Z"]
            pub fn ProcessJobNetResponse_Reflect(context: *mut root::AZ::ReflectContext);
        }
        impl ProcessJobNetResponse {
            #[inline]
            pub unsafe fn TYPEINFO_Enable(&mut self) {
                ProcessJobNetResponse_TYPEINFO_Enable(self)
            }
            #[inline]
            pub unsafe fn RTTI_Enable(&mut self) {
                ProcessJobNetResponse_RTTI_Enable(self)
            }
            #[inline]
            pub unsafe fn Reflect(context: *mut root::AZ::ReflectContext) {
                ProcessJobNetResponse_Reflect(context)
            }
        }
        extern "C" {
            #[link_name = "\u{1}?GetMessageType@ProcessJobNetResponse@AssetBuilderSDK@@UEBAIXZ"]
            pub fn ProcessJobNetResponse_GetMessageType(
                this: *mut ::std::os::raw::c_void,
            ) -> ::std::os::raw::c_uint;
        }
        #[repr(C)]
        pub struct JobCancelListener__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct JobCancelListener {
            pub vtable_: *const JobCancelListener__bindgen_vtable,
            pub _base: [u64; 5usize],
            pub m_cancelled: root::std::atomic_bool,
        }
        extern "C" {
            #[link_name = "\u{1}?IsCancelled@JobCancelListener@AssetBuilderSDK@@QEBA_NXZ"]
            pub fn JobCancelListener_IsCancelled(
                this: *const root::AssetBuilderSDK::JobCancelListener,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0JobCancelListener@AssetBuilderSDK@@QEAA@_K@Z"]
            pub fn JobCancelListener_JobCancelListener(
                this: *mut root::AssetBuilderSDK::JobCancelListener,
                jobId: root::AZ::u64,
            );
        }
        impl JobCancelListener {
            #[inline]
            pub unsafe fn IsCancelled(&self) -> bool {
                JobCancelListener_IsCancelled(self)
            }
            #[inline]
            pub unsafe fn new(jobId: root::AZ::u64) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                JobCancelListener_JobCancelListener(__bindgen_tmp.as_mut_ptr(), jobId);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DJobCancelListener@AssetBuilderSDK@@QEAAXXZ"]
            pub fn JobCancelListener_JobCancelListener_destructor(
                this: *mut root::AssetBuilderSDK::JobCancelListener,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?Cancel@JobCancelListener@AssetBuilderSDK@@UEAAXXZ"]
            pub fn JobCancelListener_Cancel(this: *mut ::std::os::raw::c_void);
        }
        #[repr(C)]
        pub struct AssertAbsorber__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct AssertAbsorber {
            pub vtable_: *const AssertAbsorber__bindgen_vtable,
            pub _base: [u64; 4usize],
            pub m_assertMessage: root::AZStd::string,
        }
        extern "C" {
            #[link_name = "\u{1}?s_onAbsorbThread@AssertAbsorber@AssetBuilderSDK@@2_NA"]
            pub static mut AssertAbsorber_s_onAbsorbThread: bool;
        }
        extern "C" {
            #[link_name = "\u{1}??0AssertAbsorber@AssetBuilderSDK@@QEAA@XZ"]
            pub fn AssertAbsorber_AssertAbsorber(this: *mut root::AssetBuilderSDK::AssertAbsorber);
        }
        impl AssertAbsorber {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                AssertAbsorber_AssertAbsorber(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}??_DAssertAbsorber@AssetBuilderSDK@@QEAAXXZ"]
            pub fn AssertAbsorber_AssertAbsorber_destructor(
                this: *mut root::AssetBuilderSDK::AssertAbsorber,
            );
        }
        extern "C" {
            #[link_name = "\u{1}?OnAssert@AssertAbsorber@AssetBuilderSDK@@UEAA_NPEBD@Z"]
            pub fn AssertAbsorber_OnAssert(
                this: *mut ::std::os::raw::c_void,
                message: *const ::std::os::raw::c_char,
            ) -> bool;
        }
    }
    pub mod Utf8 {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod Unchecked {
            #[allow(unused_imports)]
            use self::super::super::super::root;
        }
    }
    pub mod AzToolsFramework {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub mod AssetSystem {
            #[allow(unused_imports)]
            use self::super::super::super::root;
            #[repr(C)]
            pub struct AssetSystemRequest__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetSystemRequest {
                pub vtable_: *const AssetSystemRequest__bindgen_vtable,
            }
            pub type AssetSystemRequest_MutexType = root::AZStd::recursive_mutex;
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetSystemRequest@AssetSystem@AzToolsFramework@@2W4EBusHandlerPolicy@AZ@@B"]
                pub static AssetSystemRequest_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetSystemRequest@AssetSystem@AzToolsFramework@@2W4EBusAddressPolicy@AZ@@B"]
                pub static AssetSystemRequest_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
            pub const AssetSystemRequest_LocklessDispatch: bool = true;
            #[repr(C)]
            pub struct AssetSystemNotifications__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetSystemNotifications {
                pub vtable_: *const AssetSystemNotifications__bindgen_vtable,
            }
            pub type AssetSystemNotifications_MutexType = root::AZStd::recursive_mutex;
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetSystemNotifications@AssetSystem@AzToolsFramework@@2W4EBusHandlerPolicy@AZ@@B"]
                pub static AssetSystemNotifications_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetSystemNotifications@AssetSystem@AzToolsFramework@@2W4EBusAddressPolicy@AZ@@B"]
                pub static AssetSystemNotifications_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
            pub const AssetSystemNotifications_EnableEventQueue: bool = true;
            pub const JobStatus_Any: root::AzToolsFramework::AssetSystem::JobStatus = -1;
            pub const JobStatus_Queued: root::AzToolsFramework::AssetSystem::JobStatus = 0;
            pub const JobStatus_InProgress: root::AzToolsFramework::AssetSystem::JobStatus = 1;
            pub const JobStatus_Failed: root::AzToolsFramework::AssetSystem::JobStatus = 2;
            pub const JobStatus_Failed_InvalidSourceNameExceedsMaxLimit:
                root::AzToolsFramework::AssetSystem::JobStatus = 3;
            pub const JobStatus_Completed: root::AzToolsFramework::AssetSystem::JobStatus = 4;
            pub const JobStatus_Missing: root::AzToolsFramework::AssetSystem::JobStatus = 5;
            pub type JobStatus = i32;
            #[repr(C)]
            #[repr(align(16))]
            pub struct JobInfo {
                pub m_sourceFile: root::AZStd::string,
                pub m_watchFolder: root::AZStd::string,
                pub m_platform: root::AZStd::string,
                pub __bindgen_padding_0: u64,
                pub m_builderGuid: root::AZ::Uuid,
                pub m_jobKey: root::AZStd::string,
                pub m_jobRunKey: root::AZ::u64,
                pub m_status: root::AzToolsFramework::AssetSystem::JobStatus,
                pub m_firstFailLogTime: root::AZ::s64,
                pub m_firstFailLogFile: root::AZStd::string,
                pub m_lastFailLogTime: root::AZ::s64,
                pub m_lastFailLogFile: root::AZStd::string,
                pub m_lastLogTime: root::AZ::s64,
                pub m_lastLogFile: root::AZStd::string,
                pub m_jobID: root::AZ::s64,
            }
            extern "C" {
                #[link_name = "\u{1}?TYPEINFO_Enable@JobInfo@AssetSystem@AzToolsFramework@@QEAAXXZ"]
                pub fn JobInfo_TYPEINFO_Enable(
                    this: *mut root::AzToolsFramework::AssetSystem::JobInfo,
                );
            }
            impl JobInfo {
                #[inline]
                pub unsafe fn TYPEINFO_Enable(&mut self) {
                    JobInfo_TYPEINFO_Enable(self)
                }
            }
            pub type JobInfoContainer = root::AZStd::vector<
                root::AzToolsFramework::AssetSystem::JobInfo,
                root::AZStd::allocator,
            >;
            #[repr(C)]
            pub struct AssetSystemJobRequest__bindgen_vtable(::std::os::raw::c_void);
            #[repr(C)]
            #[derive(Debug)]
            pub struct AssetSystemJobRequest {
                pub vtable_: *const AssetSystemJobRequest__bindgen_vtable,
            }
            extern "C" {
                #[link_name = "\u{1}?HandlerPolicy@AssetSystemJobRequest@AssetSystem@AzToolsFramework@@2W4EBusHandlerPolicy@AZ@@B"]
                pub static AssetSystemJobRequest_HandlerPolicy: root::AZ::EBusHandlerPolicy;
            }
            extern "C" {
                #[link_name = "\u{1}?AddressPolicy@AssetSystemJobRequest@AssetSystem@AzToolsFramework@@2W4EBusAddressPolicy@AZ@@B"]
                pub static AssetSystemJobRequest_AddressPolicy: root::AZ::EBusAddressPolicy;
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_20 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_21 {
        pub _address: u8,
    }
    pub type rep = ::std::os::raw::c_longlong;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_22 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_23 {
        pub _address: u8,
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct _bindgen_ty_24 {
        pub _address: u8,
    }
}
